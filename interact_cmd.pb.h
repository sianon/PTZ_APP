// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: interact_cmd.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_interact_5fcmd_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_interact_5fcmd_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_interact_5fcmd_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_interact_5fcmd_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_interact_5fcmd_2eproto;
class AccessoryControl;
struct AccessoryControlDefaultTypeInternal;
extern AccessoryControlDefaultTypeInternal _AccessoryControl_default_instance_;
class AlarmSettings;
struct AlarmSettingsDefaultTypeInternal;
extern AlarmSettingsDefaultTypeInternal _AlarmSettings_default_instance_;
class CruiseGroup;
struct CruiseGroupDefaultTypeInternal;
extern CruiseGroupDefaultTypeInternal _CruiseGroup_default_instance_;
class DayNightSwitchSettings;
struct DayNightSwitchSettingsDefaultTypeInternal;
extern DayNightSwitchSettingsDefaultTypeInternal _DayNightSwitchSettings_default_instance_;
class DetectionArea;
struct DetectionAreaDefaultTypeInternal;
extern DetectionAreaDefaultTypeInternal _DetectionArea_default_instance_;
class ExposureSettings;
struct ExposureSettingsDefaultTypeInternal;
extern ExposureSettingsDefaultTypeInternal _ExposureSettings_default_instance_;
class FTPSettings;
struct FTPSettingsDefaultTypeInternal;
extern FTPSettingsDefaultTypeInternal _FTPSettings_default_instance_;
class GasLeakageAlarmSettings;
struct GasLeakageAlarmSettingsDefaultTypeInternal;
extern GasLeakageAlarmSettingsDefaultTypeInternal _GasLeakageAlarmSettings_default_instance_;
class IPSettings;
struct IPSettingsDefaultTypeInternal;
extern IPSettingsDefaultTypeInternal _IPSettings_default_instance_;
class IPSettings_IPv4Config;
struct IPSettings_IPv4ConfigDefaultTypeInternal;
extern IPSettings_IPv4ConfigDefaultTypeInternal _IPSettings_IPv4Config_default_instance_;
class IPSettings_IPv6Config;
struct IPSettings_IPv6ConfigDefaultTypeInternal;
extern IPSettings_IPv6ConfigDefaultTypeInternal _IPSettings_IPv6Config_default_instance_;
class ImageEnhancement;
struct ImageEnhancementDefaultTypeInternal;
extern ImageEnhancementDefaultTypeInternal _ImageEnhancement_default_instance_;
class ImageModeMessage;
struct ImageModeMessageDefaultTypeInternal;
extern ImageModeMessageDefaultTypeInternal _ImageModeMessage_default_instance_;
class ImageSettings;
struct ImageSettingsDefaultTypeInternal;
extern ImageSettingsDefaultTypeInternal _ImageSettings_default_instance_;
class InfraredImageSettings;
struct InfraredImageSettingsDefaultTypeInternal;
extern InfraredImageSettingsDefaultTypeInternal _InfraredImageSettings_default_instance_;
class LensControl;
struct LensControlDefaultTypeInternal;
extern LensControlDefaultTypeInternal _LensControl_default_instance_;
class LinearScanControl;
struct LinearScanControlDefaultTypeInternal;
extern LinearScanControlDefaultTypeInternal _LinearScanControl_default_instance_;
class LinearScanSettings;
struct LinearScanSettingsDefaultTypeInternal;
extern LinearScanSettingsDefaultTypeInternal _LinearScanSettings_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class LoginSecuritySettings;
struct LoginSecuritySettingsDefaultTypeInternal;
extern LoginSecuritySettingsDefaultTypeInternal _LoginSecuritySettings_default_instance_;
class MediaSettings;
struct MediaSettingsDefaultTypeInternal;
extern MediaSettingsDefaultTypeInternal _MediaSettings_default_instance_;
class NoiseReduction;
struct NoiseReductionDefaultTypeInternal;
extern NoiseReductionDefaultTypeInternal _NoiseReduction_default_instance_;
class OSDSettings;
struct OSDSettingsDefaultTypeInternal;
extern OSDSettingsDefaultTypeInternal _OSDSettings_default_instance_;
class PTZControlProtol;
struct PTZControlProtolDefaultTypeInternal;
extern PTZControlProtolDefaultTypeInternal _PTZControlProtol_default_instance_;
class PTZDevice;
struct PTZDeviceDefaultTypeInternal;
extern PTZDeviceDefaultTypeInternal _PTZDevice_default_instance_;
class PlatformSettings;
struct PlatformSettingsDefaultTypeInternal;
extern PlatformSettingsDefaultTypeInternal _PlatformSettings_default_instance_;
class PortSettings;
struct PortSettingsDefaultTypeInternal;
extern PortSettingsDefaultTypeInternal _PortSettings_default_instance_;
class PresetList;
struct PresetListDefaultTypeInternal;
extern PresetListDefaultTypeInternal _PresetList_default_instance_;
class PresetPosition;
struct PresetPositionDefaultTypeInternal;
extern PresetPositionDefaultTypeInternal _PresetPosition_default_instance_;
class PresetPositionOp;
struct PresetPositionOpDefaultTypeInternal;
extern PresetPositionOpDefaultTypeInternal _PresetPositionOp_default_instance_;
class Reboot;
struct RebootDefaultTypeInternal;
extern RebootDefaultTypeInternal _Reboot_default_instance_;
class Reboot_WeeklyRebootSchedule;
struct Reboot_WeeklyRebootScheduleDefaultTypeInternal;
extern Reboot_WeeklyRebootScheduleDefaultTypeInternal _Reboot_WeeklyRebootSchedule_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class Scanning;
struct ScanningDefaultTypeInternal;
extern ScanningDefaultTypeInternal _Scanning_default_instance_;
class SystemInfo;
struct SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
class SystemLogsQuery;
struct SystemLogsQueryDefaultTypeInternal;
extern SystemLogsQueryDefaultTypeInternal _SystemLogsQuery_default_instance_;
class TimeSettings;
struct TimeSettingsDefaultTypeInternal;
extern TimeSettingsDefaultTypeInternal _TimeSettings_default_instance_;
class TrackingScan;
struct TrackingScanDefaultTypeInternal;
extern TrackingScanDefaultTypeInternal _TrackingScan_default_instance_;
class TrackingScanCmd;
struct TrackingScanCmdDefaultTypeInternal;
extern TrackingScanCmdDefaultTypeInternal _TrackingScanCmd_default_instance_;
class UserAccountSettings;
struct UserAccountSettingsDefaultTypeInternal;
extern UserAccountSettingsDefaultTypeInternal _UserAccountSettings_default_instance_;
class VideoAdjustment;
struct VideoAdjustmentDefaultTypeInternal;
extern VideoAdjustmentDefaultTypeInternal _VideoAdjustment_default_instance_;
class WhiteBalanceSettings;
struct WhiteBalanceSettingsDefaultTypeInternal;
extern WhiteBalanceSettingsDefaultTypeInternal _WhiteBalanceSettings_default_instance_;
class WhiteBalanceSettings_ManualWhiteBalance;
struct WhiteBalanceSettings_ManualWhiteBalanceDefaultTypeInternal;
extern WhiteBalanceSettings_ManualWhiteBalanceDefaultTypeInternal _WhiteBalanceSettings_ManualWhiteBalance_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum PTZDevice_DeviceStatus : int {
  PTZDevice_DeviceStatus_UNKNOWN = 0,
  PTZDevice_DeviceStatus_ONLINE = 1,
  PTZDevice_DeviceStatus_OFFLINE = 2,
  PTZDevice_DeviceStatus_PTZDevice_DeviceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PTZDevice_DeviceStatus_PTZDevice_DeviceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PTZDevice_DeviceStatus_IsValid(int value);
extern const uint32_t PTZDevice_DeviceStatus_internal_data_[];
constexpr PTZDevice_DeviceStatus PTZDevice_DeviceStatus_DeviceStatus_MIN = static_cast<PTZDevice_DeviceStatus>(0);
constexpr PTZDevice_DeviceStatus PTZDevice_DeviceStatus_DeviceStatus_MAX = static_cast<PTZDevice_DeviceStatus>(2);
constexpr int PTZDevice_DeviceStatus_DeviceStatus_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PTZDevice_DeviceStatus_descriptor();
template <typename T>
const std::string& PTZDevice_DeviceStatus_Name(T value) {
  static_assert(std::is_same<T, PTZDevice_DeviceStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceStatus_Name().");
  return PTZDevice_DeviceStatus_Name(static_cast<PTZDevice_DeviceStatus>(value));
}
template <>
inline const std::string& PTZDevice_DeviceStatus_Name(PTZDevice_DeviceStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PTZDevice_DeviceStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PTZDevice_DeviceStatus_Parse(absl::string_view name, PTZDevice_DeviceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PTZDevice_DeviceStatus>(
      PTZDevice_DeviceStatus_descriptor(), name, value);
}
enum ImageSettings_CaptureType : int {
  ImageSettings_CaptureType_SCHEDULED = 0,
  ImageSettings_CaptureType_TRIGGERED = 1,
  ImageSettings_CaptureType_ImageSettings_CaptureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImageSettings_CaptureType_ImageSettings_CaptureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ImageSettings_CaptureType_IsValid(int value);
extern const uint32_t ImageSettings_CaptureType_internal_data_[];
constexpr ImageSettings_CaptureType ImageSettings_CaptureType_CaptureType_MIN = static_cast<ImageSettings_CaptureType>(0);
constexpr ImageSettings_CaptureType ImageSettings_CaptureType_CaptureType_MAX = static_cast<ImageSettings_CaptureType>(1);
constexpr int ImageSettings_CaptureType_CaptureType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ImageSettings_CaptureType_descriptor();
template <typename T>
const std::string& ImageSettings_CaptureType_Name(T value) {
  static_assert(std::is_same<T, ImageSettings_CaptureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CaptureType_Name().");
  return ImageSettings_CaptureType_Name(static_cast<ImageSettings_CaptureType>(value));
}
template <>
inline const std::string& ImageSettings_CaptureType_Name(ImageSettings_CaptureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageSettings_CaptureType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ImageSettings_CaptureType_Parse(absl::string_view name, ImageSettings_CaptureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageSettings_CaptureType>(
      ImageSettings_CaptureType_descriptor(), name, value);
}
enum ImageSettings_ImageQuality : int {
  ImageSettings_ImageQuality_LOWEST = 0,
  ImageSettings_ImageQuality_LOWER = 1,
  ImageSettings_ImageQuality_LOW = 2,
  ImageSettings_ImageQuality_MEDIUM = 3,
  ImageSettings_ImageQuality_HIGHER = 4,
  ImageSettings_ImageQuality_HIGHEST = 5,
  ImageSettings_ImageQuality_ImageSettings_ImageQuality_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImageSettings_ImageQuality_ImageSettings_ImageQuality_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ImageSettings_ImageQuality_IsValid(int value);
extern const uint32_t ImageSettings_ImageQuality_internal_data_[];
constexpr ImageSettings_ImageQuality ImageSettings_ImageQuality_ImageQuality_MIN = static_cast<ImageSettings_ImageQuality>(0);
constexpr ImageSettings_ImageQuality ImageSettings_ImageQuality_ImageQuality_MAX = static_cast<ImageSettings_ImageQuality>(5);
constexpr int ImageSettings_ImageQuality_ImageQuality_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ImageSettings_ImageQuality_descriptor();
template <typename T>
const std::string& ImageSettings_ImageQuality_Name(T value) {
  static_assert(std::is_same<T, ImageSettings_ImageQuality>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImageQuality_Name().");
  return ImageSettings_ImageQuality_Name(static_cast<ImageSettings_ImageQuality>(value));
}
template <>
inline const std::string& ImageSettings_ImageQuality_Name(ImageSettings_ImageQuality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageSettings_ImageQuality_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ImageSettings_ImageQuality_Parse(absl::string_view name, ImageSettings_ImageQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageSettings_ImageQuality>(
      ImageSettings_ImageQuality_descriptor(), name, value);
}
enum VideoAdjustment_MirrorSetting : int {
  VideoAdjustment_MirrorSetting_NONE = 0,
  VideoAdjustment_MirrorSetting_HORIZONTAL = 1,
  VideoAdjustment_MirrorSetting_VERTICAL = 2,
  VideoAdjustment_MirrorSetting_VideoAdjustment_MirrorSetting_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoAdjustment_MirrorSetting_VideoAdjustment_MirrorSetting_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoAdjustment_MirrorSetting_IsValid(int value);
extern const uint32_t VideoAdjustment_MirrorSetting_internal_data_[];
constexpr VideoAdjustment_MirrorSetting VideoAdjustment_MirrorSetting_MirrorSetting_MIN = static_cast<VideoAdjustment_MirrorSetting>(0);
constexpr VideoAdjustment_MirrorSetting VideoAdjustment_MirrorSetting_MirrorSetting_MAX = static_cast<VideoAdjustment_MirrorSetting>(2);
constexpr int VideoAdjustment_MirrorSetting_MirrorSetting_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VideoAdjustment_MirrorSetting_descriptor();
template <typename T>
const std::string& VideoAdjustment_MirrorSetting_Name(T value) {
  static_assert(std::is_same<T, VideoAdjustment_MirrorSetting>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MirrorSetting_Name().");
  return VideoAdjustment_MirrorSetting_Name(static_cast<VideoAdjustment_MirrorSetting>(value));
}
template <>
inline const std::string& VideoAdjustment_MirrorSetting_Name(VideoAdjustment_MirrorSetting value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VideoAdjustment_MirrorSetting_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VideoAdjustment_MirrorSetting_Parse(absl::string_view name, VideoAdjustment_MirrorSetting* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoAdjustment_MirrorSetting>(
      VideoAdjustment_MirrorSetting_descriptor(), name, value);
}
enum VideoAdjustment_StabilizationSetting : int {
  VideoAdjustment_StabilizationSetting_OFF = 0,
  VideoAdjustment_StabilizationSetting_PAL = 1,
  VideoAdjustment_StabilizationSetting_NTSC = 2,
  VideoAdjustment_StabilizationSetting_VideoAdjustment_StabilizationSetting_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoAdjustment_StabilizationSetting_VideoAdjustment_StabilizationSetting_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoAdjustment_StabilizationSetting_IsValid(int value);
extern const uint32_t VideoAdjustment_StabilizationSetting_internal_data_[];
constexpr VideoAdjustment_StabilizationSetting VideoAdjustment_StabilizationSetting_StabilizationSetting_MIN = static_cast<VideoAdjustment_StabilizationSetting>(0);
constexpr VideoAdjustment_StabilizationSetting VideoAdjustment_StabilizationSetting_StabilizationSetting_MAX = static_cast<VideoAdjustment_StabilizationSetting>(2);
constexpr int VideoAdjustment_StabilizationSetting_StabilizationSetting_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VideoAdjustment_StabilizationSetting_descriptor();
template <typename T>
const std::string& VideoAdjustment_StabilizationSetting_Name(T value) {
  static_assert(std::is_same<T, VideoAdjustment_StabilizationSetting>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StabilizationSetting_Name().");
  return VideoAdjustment_StabilizationSetting_Name(static_cast<VideoAdjustment_StabilizationSetting>(value));
}
template <>
inline const std::string& VideoAdjustment_StabilizationSetting_Name(VideoAdjustment_StabilizationSetting value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VideoAdjustment_StabilizationSetting_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VideoAdjustment_StabilizationSetting_Parse(absl::string_view name, VideoAdjustment_StabilizationSetting* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoAdjustment_StabilizationSetting>(
      VideoAdjustment_StabilizationSetting_descriptor(), name, value);
}
enum ExposureSettings_ExposureMode : int {
  ExposureSettings_ExposureMode_AUTO = 0,
  ExposureSettings_ExposureMode_MANUAL = 1,
  ExposureSettings_ExposureMode_ExposureSettings_ExposureMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExposureSettings_ExposureMode_ExposureSettings_ExposureMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExposureSettings_ExposureMode_IsValid(int value);
extern const uint32_t ExposureSettings_ExposureMode_internal_data_[];
constexpr ExposureSettings_ExposureMode ExposureSettings_ExposureMode_ExposureMode_MIN = static_cast<ExposureSettings_ExposureMode>(0);
constexpr ExposureSettings_ExposureMode ExposureSettings_ExposureMode_ExposureMode_MAX = static_cast<ExposureSettings_ExposureMode>(1);
constexpr int ExposureSettings_ExposureMode_ExposureMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ExposureSettings_ExposureMode_descriptor();
template <typename T>
const std::string& ExposureSettings_ExposureMode_Name(T value) {
  static_assert(std::is_same<T, ExposureSettings_ExposureMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExposureMode_Name().");
  return ExposureSettings_ExposureMode_Name(static_cast<ExposureSettings_ExposureMode>(value));
}
template <>
inline const std::string& ExposureSettings_ExposureMode_Name(ExposureSettings_ExposureMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExposureSettings_ExposureMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ExposureSettings_ExposureMode_Parse(absl::string_view name, ExposureSettings_ExposureMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExposureSettings_ExposureMode>(
      ExposureSettings_ExposureMode_descriptor(), name, value);
}
enum DayNightSwitchSettings_Mode : int {
  DayNightSwitchSettings_Mode_AUTO = 0,
  DayNightSwitchSettings_Mode_DAY = 1,
  DayNightSwitchSettings_Mode_NIGHT = 2,
  DayNightSwitchSettings_Mode_TIMED = 3,
  DayNightSwitchSettings_Mode_DayNightSwitchSettings_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DayNightSwitchSettings_Mode_DayNightSwitchSettings_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DayNightSwitchSettings_Mode_IsValid(int value);
extern const uint32_t DayNightSwitchSettings_Mode_internal_data_[];
constexpr DayNightSwitchSettings_Mode DayNightSwitchSettings_Mode_Mode_MIN = static_cast<DayNightSwitchSettings_Mode>(0);
constexpr DayNightSwitchSettings_Mode DayNightSwitchSettings_Mode_Mode_MAX = static_cast<DayNightSwitchSettings_Mode>(3);
constexpr int DayNightSwitchSettings_Mode_Mode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DayNightSwitchSettings_Mode_descriptor();
template <typename T>
const std::string& DayNightSwitchSettings_Mode_Name(T value) {
  static_assert(std::is_same<T, DayNightSwitchSettings_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return DayNightSwitchSettings_Mode_Name(static_cast<DayNightSwitchSettings_Mode>(value));
}
template <>
inline const std::string& DayNightSwitchSettings_Mode_Name(DayNightSwitchSettings_Mode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DayNightSwitchSettings_Mode_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DayNightSwitchSettings_Mode_Parse(absl::string_view name, DayNightSwitchSettings_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DayNightSwitchSettings_Mode>(
      DayNightSwitchSettings_Mode_descriptor(), name, value);
}
enum WhiteBalanceSettings_WhiteBalanceMode : int {
  WhiteBalanceSettings_WhiteBalanceMode_AUTO = 0,
  WhiteBalanceSettings_WhiteBalanceMode_MANUAL = 1,
  WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceSettings_WhiteBalanceMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceSettings_WhiteBalanceMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WhiteBalanceSettings_WhiteBalanceMode_IsValid(int value);
extern const uint32_t WhiteBalanceSettings_WhiteBalanceMode_internal_data_[];
constexpr WhiteBalanceSettings_WhiteBalanceMode WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_MIN = static_cast<WhiteBalanceSettings_WhiteBalanceMode>(0);
constexpr WhiteBalanceSettings_WhiteBalanceMode WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_MAX = static_cast<WhiteBalanceSettings_WhiteBalanceMode>(1);
constexpr int WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
WhiteBalanceSettings_WhiteBalanceMode_descriptor();
template <typename T>
const std::string& WhiteBalanceSettings_WhiteBalanceMode_Name(T value) {
  static_assert(std::is_same<T, WhiteBalanceSettings_WhiteBalanceMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WhiteBalanceMode_Name().");
  return WhiteBalanceSettings_WhiteBalanceMode_Name(static_cast<WhiteBalanceSettings_WhiteBalanceMode>(value));
}
template <>
inline const std::string& WhiteBalanceSettings_WhiteBalanceMode_Name(WhiteBalanceSettings_WhiteBalanceMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WhiteBalanceSettings_WhiteBalanceMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool WhiteBalanceSettings_WhiteBalanceMode_Parse(absl::string_view name, WhiteBalanceSettings_WhiteBalanceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WhiteBalanceSettings_WhiteBalanceMode>(
      WhiteBalanceSettings_WhiteBalanceMode_descriptor(), name, value);
}
enum OSDSettings_Size : int {
  OSDSettings_Size_LARGE = 0,
  OSDSettings_Size_MEDIUM = 1,
  OSDSettings_Size_SMALL = 2,
  OSDSettings_Size_OSDSettings_Size_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OSDSettings_Size_OSDSettings_Size_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OSDSettings_Size_IsValid(int value);
extern const uint32_t OSDSettings_Size_internal_data_[];
constexpr OSDSettings_Size OSDSettings_Size_Size_MIN = static_cast<OSDSettings_Size>(0);
constexpr OSDSettings_Size OSDSettings_Size_Size_MAX = static_cast<OSDSettings_Size>(2);
constexpr int OSDSettings_Size_Size_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
OSDSettings_Size_descriptor();
template <typename T>
const std::string& OSDSettings_Size_Name(T value) {
  static_assert(std::is_same<T, OSDSettings_Size>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Size_Name().");
  return OSDSettings_Size_Name(static_cast<OSDSettings_Size>(value));
}
template <>
inline const std::string& OSDSettings_Size_Name(OSDSettings_Size value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OSDSettings_Size_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OSDSettings_Size_Parse(absl::string_view name, OSDSettings_Size* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSettings_Size>(
      OSDSettings_Size_descriptor(), name, value);
}
enum OSDSettings_Color : int {
  OSDSettings_Color_AUTO = 0,
  OSDSettings_Color_WHITE = 1,
  OSDSettings_Color_BLACK = 2,
  OSDSettings_Color_OSDSettings_Color_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OSDSettings_Color_OSDSettings_Color_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OSDSettings_Color_IsValid(int value);
extern const uint32_t OSDSettings_Color_internal_data_[];
constexpr OSDSettings_Color OSDSettings_Color_Color_MIN = static_cast<OSDSettings_Color>(0);
constexpr OSDSettings_Color OSDSettings_Color_Color_MAX = static_cast<OSDSettings_Color>(2);
constexpr int OSDSettings_Color_Color_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
OSDSettings_Color_descriptor();
template <typename T>
const std::string& OSDSettings_Color_Name(T value) {
  static_assert(std::is_same<T, OSDSettings_Color>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Color_Name().");
  return OSDSettings_Color_Name(static_cast<OSDSettings_Color>(value));
}
template <>
inline const std::string& OSDSettings_Color_Name(OSDSettings_Color value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OSDSettings_Color_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OSDSettings_Color_Parse(absl::string_view name, OSDSettings_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSettings_Color>(
      OSDSettings_Color_descriptor(), name, value);
}
enum OSDSettings_Alignment : int {
  OSDSettings_Alignment_LEFT = 0,
  OSDSettings_Alignment_CENTER = 1,
  OSDSettings_Alignment_RIGHT = 2,
  OSDSettings_Alignment_OSDSettings_Alignment_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OSDSettings_Alignment_OSDSettings_Alignment_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OSDSettings_Alignment_IsValid(int value);
extern const uint32_t OSDSettings_Alignment_internal_data_[];
constexpr OSDSettings_Alignment OSDSettings_Alignment_Alignment_MIN = static_cast<OSDSettings_Alignment>(0);
constexpr OSDSettings_Alignment OSDSettings_Alignment_Alignment_MAX = static_cast<OSDSettings_Alignment>(2);
constexpr int OSDSettings_Alignment_Alignment_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
OSDSettings_Alignment_descriptor();
template <typename T>
const std::string& OSDSettings_Alignment_Name(T value) {
  static_assert(std::is_same<T, OSDSettings_Alignment>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Alignment_Name().");
  return OSDSettings_Alignment_Name(static_cast<OSDSettings_Alignment>(value));
}
template <>
inline const std::string& OSDSettings_Alignment_Name(OSDSettings_Alignment value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OSDSettings_Alignment_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OSDSettings_Alignment_Parse(absl::string_view name, OSDSettings_Alignment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSettings_Alignment>(
      OSDSettings_Alignment_descriptor(), name, value);
}
enum OSDSettings_TimeFormat : int {
  OSDSettings_TimeFormat_TWENTY_FOUR_HOUR = 0,
  OSDSettings_TimeFormat_TWELVE_HOUR = 1,
  OSDSettings_TimeFormat_OSDSettings_TimeFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OSDSettings_TimeFormat_OSDSettings_TimeFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OSDSettings_TimeFormat_IsValid(int value);
extern const uint32_t OSDSettings_TimeFormat_internal_data_[];
constexpr OSDSettings_TimeFormat OSDSettings_TimeFormat_TimeFormat_MIN = static_cast<OSDSettings_TimeFormat>(0);
constexpr OSDSettings_TimeFormat OSDSettings_TimeFormat_TimeFormat_MAX = static_cast<OSDSettings_TimeFormat>(1);
constexpr int OSDSettings_TimeFormat_TimeFormat_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
OSDSettings_TimeFormat_descriptor();
template <typename T>
const std::string& OSDSettings_TimeFormat_Name(T value) {
  static_assert(std::is_same<T, OSDSettings_TimeFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimeFormat_Name().");
  return OSDSettings_TimeFormat_Name(static_cast<OSDSettings_TimeFormat>(value));
}
template <>
inline const std::string& OSDSettings_TimeFormat_Name(OSDSettings_TimeFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OSDSettings_TimeFormat_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool OSDSettings_TimeFormat_Parse(absl::string_view name, OSDSettings_TimeFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSettings_TimeFormat>(
      OSDSettings_TimeFormat_descriptor(), name, value);
}
enum OSDSettings_DateFormat : int {
  OSDSettings_DateFormat_YEAR_MONTH_DAY = 0,
  OSDSettings_DateFormat_MONTH_DAY_YEAR = 1,
  OSDSettings_DateFormat_DAY_MONTH_YEAR = 2,
  OSDSettings_DateFormat_OSDSettings_DateFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OSDSettings_DateFormat_OSDSettings_DateFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OSDSettings_DateFormat_IsValid(int value);
extern const uint32_t OSDSettings_DateFormat_internal_data_[];
constexpr OSDSettings_DateFormat OSDSettings_DateFormat_DateFormat_MIN = static_cast<OSDSettings_DateFormat>(0);
constexpr OSDSettings_DateFormat OSDSettings_DateFormat_DateFormat_MAX = static_cast<OSDSettings_DateFormat>(2);
constexpr int OSDSettings_DateFormat_DateFormat_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
OSDSettings_DateFormat_descriptor();
template <typename T>
const std::string& OSDSettings_DateFormat_Name(T value) {
  static_assert(std::is_same<T, OSDSettings_DateFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DateFormat_Name().");
  return OSDSettings_DateFormat_Name(static_cast<OSDSettings_DateFormat>(value));
}
template <>
inline const std::string& OSDSettings_DateFormat_Name(OSDSettings_DateFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OSDSettings_DateFormat_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OSDSettings_DateFormat_Parse(absl::string_view name, OSDSettings_DateFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSettings_DateFormat>(
      OSDSettings_DateFormat_descriptor(), name, value);
}
enum PlatformSettings_ProtocolType : int {
  PlatformSettings_ProtocolType_PROTOCOL_UNKNOWN = 0,
  PlatformSettings_ProtocolType_GB28181 = 1,
  PlatformSettings_ProtocolType_ONVIF = 2,
  PlatformSettings_ProtocolType_OTHER = 3,
  PlatformSettings_ProtocolType_PlatformSettings_ProtocolType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PlatformSettings_ProtocolType_PlatformSettings_ProtocolType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PlatformSettings_ProtocolType_IsValid(int value);
extern const uint32_t PlatformSettings_ProtocolType_internal_data_[];
constexpr PlatformSettings_ProtocolType PlatformSettings_ProtocolType_ProtocolType_MIN = static_cast<PlatformSettings_ProtocolType>(0);
constexpr PlatformSettings_ProtocolType PlatformSettings_ProtocolType_ProtocolType_MAX = static_cast<PlatformSettings_ProtocolType>(3);
constexpr int PlatformSettings_ProtocolType_ProtocolType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PlatformSettings_ProtocolType_descriptor();
template <typename T>
const std::string& PlatformSettings_ProtocolType_Name(T value) {
  static_assert(std::is_same<T, PlatformSettings_ProtocolType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProtocolType_Name().");
  return PlatformSettings_ProtocolType_Name(static_cast<PlatformSettings_ProtocolType>(value));
}
template <>
inline const std::string& PlatformSettings_ProtocolType_Name(PlatformSettings_ProtocolType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PlatformSettings_ProtocolType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PlatformSettings_ProtocolType_Parse(absl::string_view name, PlatformSettings_ProtocolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlatformSettings_ProtocolType>(
      PlatformSettings_ProtocolType_descriptor(), name, value);
}
enum AlarmSettings_AlarmType : int {
  AlarmSettings_AlarmType_MOTION = 0,
  AlarmSettings_AlarmType_COVER = 1,
  AlarmSettings_AlarmType_AlarmSettings_AlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AlarmSettings_AlarmType_AlarmSettings_AlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AlarmSettings_AlarmType_IsValid(int value);
extern const uint32_t AlarmSettings_AlarmType_internal_data_[];
constexpr AlarmSettings_AlarmType AlarmSettings_AlarmType_AlarmType_MIN = static_cast<AlarmSettings_AlarmType>(0);
constexpr AlarmSettings_AlarmType AlarmSettings_AlarmType_AlarmType_MAX = static_cast<AlarmSettings_AlarmType>(1);
constexpr int AlarmSettings_AlarmType_AlarmType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AlarmSettings_AlarmType_descriptor();
template <typename T>
const std::string& AlarmSettings_AlarmType_Name(T value) {
  static_assert(std::is_same<T, AlarmSettings_AlarmType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AlarmType_Name().");
  return AlarmSettings_AlarmType_Name(static_cast<AlarmSettings_AlarmType>(value));
}
template <>
inline const std::string& AlarmSettings_AlarmType_Name(AlarmSettings_AlarmType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AlarmSettings_AlarmType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AlarmSettings_AlarmType_Parse(absl::string_view name, AlarmSettings_AlarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmSettings_AlarmType>(
      AlarmSettings_AlarmType_descriptor(), name, value);
}
enum UserAccountSettings_OperationType : int {
  UserAccountSettings_OperationType_OPERATION_UNSPECIFIED = 0,
  UserAccountSettings_OperationType_ADD = 1,
  UserAccountSettings_OperationType_DELETE = 2,
  UserAccountSettings_OperationType_MODIFY = 3,
  UserAccountSettings_OperationType_SUSPEND = 4,
  UserAccountSettings_OperationType_RESUME = 5,
  UserAccountSettings_OperationType_UserAccountSettings_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UserAccountSettings_OperationType_UserAccountSettings_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UserAccountSettings_OperationType_IsValid(int value);
extern const uint32_t UserAccountSettings_OperationType_internal_data_[];
constexpr UserAccountSettings_OperationType UserAccountSettings_OperationType_OperationType_MIN = static_cast<UserAccountSettings_OperationType>(0);
constexpr UserAccountSettings_OperationType UserAccountSettings_OperationType_OperationType_MAX = static_cast<UserAccountSettings_OperationType>(5);
constexpr int UserAccountSettings_OperationType_OperationType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
UserAccountSettings_OperationType_descriptor();
template <typename T>
const std::string& UserAccountSettings_OperationType_Name(T value) {
  static_assert(std::is_same<T, UserAccountSettings_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return UserAccountSettings_OperationType_Name(static_cast<UserAccountSettings_OperationType>(value));
}
template <>
inline const std::string& UserAccountSettings_OperationType_Name(UserAccountSettings_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UserAccountSettings_OperationType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool UserAccountSettings_OperationType_Parse(absl::string_view name, UserAccountSettings_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserAccountSettings_OperationType>(
      UserAccountSettings_OperationType_descriptor(), name, value);
}
enum SystemLogsQuery_QueryType : int {
  SystemLogsQuery_QueryType_USER_ID = 0,
  SystemLogsQuery_QueryType_LOG_TYPE = 1,
  SystemLogsQuery_QueryType_OP_TYPE = 2,
  SystemLogsQuery_QueryType_OP_DATE = 3,
  SystemLogsQuery_QueryType_SystemLogsQuery_QueryType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SystemLogsQuery_QueryType_SystemLogsQuery_QueryType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SystemLogsQuery_QueryType_IsValid(int value);
extern const uint32_t SystemLogsQuery_QueryType_internal_data_[];
constexpr SystemLogsQuery_QueryType SystemLogsQuery_QueryType_QueryType_MIN = static_cast<SystemLogsQuery_QueryType>(0);
constexpr SystemLogsQuery_QueryType SystemLogsQuery_QueryType_QueryType_MAX = static_cast<SystemLogsQuery_QueryType>(3);
constexpr int SystemLogsQuery_QueryType_QueryType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SystemLogsQuery_QueryType_descriptor();
template <typename T>
const std::string& SystemLogsQuery_QueryType_Name(T value) {
  static_assert(std::is_same<T, SystemLogsQuery_QueryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QueryType_Name().");
  return SystemLogsQuery_QueryType_Name(static_cast<SystemLogsQuery_QueryType>(value));
}
template <>
inline const std::string& SystemLogsQuery_QueryType_Name(SystemLogsQuery_QueryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SystemLogsQuery_QueryType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SystemLogsQuery_QueryType_Parse(absl::string_view name, SystemLogsQuery_QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SystemLogsQuery_QueryType>(
      SystemLogsQuery_QueryType_descriptor(), name, value);
}
enum LogEntry_LogType : int {
  LogEntry_LogType_OPERATION_LOG = 0,
  LogEntry_LogType_QUERY_LOG = 1,
  LogEntry_LogType_LogEntry_LogType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogEntry_LogType_LogEntry_LogType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogEntry_LogType_IsValid(int value);
extern const uint32_t LogEntry_LogType_internal_data_[];
constexpr LogEntry_LogType LogEntry_LogType_LogType_MIN = static_cast<LogEntry_LogType>(0);
constexpr LogEntry_LogType LogEntry_LogType_LogType_MAX = static_cast<LogEntry_LogType>(1);
constexpr int LogEntry_LogType_LogType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
LogEntry_LogType_descriptor();
template <typename T>
const std::string& LogEntry_LogType_Name(T value) {
  static_assert(std::is_same<T, LogEntry_LogType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogType_Name().");
  return LogEntry_LogType_Name(static_cast<LogEntry_LogType>(value));
}
template <>
inline const std::string& LogEntry_LogType_Name(LogEntry_LogType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogEntry_LogType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool LogEntry_LogType_Parse(absl::string_view name, LogEntry_LogType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_LogType>(
      LogEntry_LogType_descriptor(), name, value);
}
enum LogEntry_AccountType : int {
  LogEntry_AccountType_SUPER_ADMIN = 0,
  LogEntry_AccountType_ADMIN = 1,
  LogEntry_AccountType_CUSTOMER = 2,
  LogEntry_AccountType_LogEntry_AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogEntry_AccountType_LogEntry_AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogEntry_AccountType_IsValid(int value);
extern const uint32_t LogEntry_AccountType_internal_data_[];
constexpr LogEntry_AccountType LogEntry_AccountType_AccountType_MIN = static_cast<LogEntry_AccountType>(0);
constexpr LogEntry_AccountType LogEntry_AccountType_AccountType_MAX = static_cast<LogEntry_AccountType>(2);
constexpr int LogEntry_AccountType_AccountType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
LogEntry_AccountType_descriptor();
template <typename T>
const std::string& LogEntry_AccountType_Name(T value) {
  static_assert(std::is_same<T, LogEntry_AccountType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountType_Name().");
  return LogEntry_AccountType_Name(static_cast<LogEntry_AccountType>(value));
}
template <>
inline const std::string& LogEntry_AccountType_Name(LogEntry_AccountType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogEntry_AccountType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool LogEntry_AccountType_Parse(absl::string_view name, LogEntry_AccountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_AccountType>(
      LogEntry_AccountType_descriptor(), name, value);
}
enum LogEntry_OperationResult : int {
  LogEntry_OperationResult_SUCCESS = 0,
  LogEntry_OperationResult_FAILURE = 1,
  LogEntry_OperationResult_LogEntry_OperationResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogEntry_OperationResult_LogEntry_OperationResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogEntry_OperationResult_IsValid(int value);
extern const uint32_t LogEntry_OperationResult_internal_data_[];
constexpr LogEntry_OperationResult LogEntry_OperationResult_OperationResult_MIN = static_cast<LogEntry_OperationResult>(0);
constexpr LogEntry_OperationResult LogEntry_OperationResult_OperationResult_MAX = static_cast<LogEntry_OperationResult>(1);
constexpr int LogEntry_OperationResult_OperationResult_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
LogEntry_OperationResult_descriptor();
template <typename T>
const std::string& LogEntry_OperationResult_Name(T value) {
  static_assert(std::is_same<T, LogEntry_OperationResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationResult_Name().");
  return LogEntry_OperationResult_Name(static_cast<LogEntry_OperationResult>(value));
}
template <>
inline const std::string& LogEntry_OperationResult_Name(LogEntry_OperationResult value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogEntry_OperationResult_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool LogEntry_OperationResult_Parse(absl::string_view name, LogEntry_OperationResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_OperationResult>(
      LogEntry_OperationResult_descriptor(), name, value);
}
enum LogEntry_OperationType : int {
  LogEntry_OperationType_INFO_QUERY = 0,
  LogEntry_OperationType_PARAM_CONFIG = 1,
  LogEntry_OperationType_ACCOUNT_MODIFY = 2,
  LogEntry_OperationType_ACCOUNT_DELETE = 3,
  LogEntry_OperationType_ACCOUNT_ADD = 4,
  LogEntry_OperationType_FACTORY_RESET = 5,
  LogEntry_OperationType_SYSTEM_UPGRADE = 6,
  LogEntry_OperationType_LogEntry_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogEntry_OperationType_LogEntry_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogEntry_OperationType_IsValid(int value);
extern const uint32_t LogEntry_OperationType_internal_data_[];
constexpr LogEntry_OperationType LogEntry_OperationType_OperationType_MIN = static_cast<LogEntry_OperationType>(0);
constexpr LogEntry_OperationType LogEntry_OperationType_OperationType_MAX = static_cast<LogEntry_OperationType>(6);
constexpr int LogEntry_OperationType_OperationType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
LogEntry_OperationType_descriptor();
template <typename T>
const std::string& LogEntry_OperationType_Name(T value) {
  static_assert(std::is_same<T, LogEntry_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return LogEntry_OperationType_Name(static_cast<LogEntry_OperationType>(value));
}
template <>
inline const std::string& LogEntry_OperationType_Name(LogEntry_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogEntry_OperationType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool LogEntry_OperationType_Parse(absl::string_view name, LogEntry_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_OperationType>(
      LogEntry_OperationType_descriptor(), name, value);
}
enum PresetPositionOp_PresetOperatType : int {
  PresetPositionOp_PresetOperatType_ADD = 0,
  PresetPositionOp_PresetOperatType_DEL = 1,
  PresetPositionOp_PresetOperatType_MODIFY = 2,
  PresetPositionOp_PresetOperatType_PresetPositionOp_PresetOperatType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetPositionOp_PresetOperatType_PresetPositionOp_PresetOperatType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetPositionOp_PresetOperatType_IsValid(int value);
extern const uint32_t PresetPositionOp_PresetOperatType_internal_data_[];
constexpr PresetPositionOp_PresetOperatType PresetPositionOp_PresetOperatType_PresetOperatType_MIN = static_cast<PresetPositionOp_PresetOperatType>(0);
constexpr PresetPositionOp_PresetOperatType PresetPositionOp_PresetOperatType_PresetOperatType_MAX = static_cast<PresetPositionOp_PresetOperatType>(2);
constexpr int PresetPositionOp_PresetOperatType_PresetOperatType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PresetPositionOp_PresetOperatType_descriptor();
template <typename T>
const std::string& PresetPositionOp_PresetOperatType_Name(T value) {
  static_assert(std::is_same<T, PresetPositionOp_PresetOperatType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetOperatType_Name().");
  return PresetPositionOp_PresetOperatType_Name(static_cast<PresetPositionOp_PresetOperatType>(value));
}
template <>
inline const std::string& PresetPositionOp_PresetOperatType_Name(PresetPositionOp_PresetOperatType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetPositionOp_PresetOperatType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PresetPositionOp_PresetOperatType_Parse(absl::string_view name, PresetPositionOp_PresetOperatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetPositionOp_PresetOperatType>(
      PresetPositionOp_PresetOperatType_descriptor(), name, value);
}
enum TrackingScanCmd_OperationType : int {
  TrackingScanCmd_OperationType_PAN_TILT = 0,
  TrackingScanCmd_OperationType_ZOOM = 1,
  TrackingScanCmd_OperationType_PRESET_CALL = 2,
  TrackingScanCmd_OperationType_TrackingScanCmd_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrackingScanCmd_OperationType_TrackingScanCmd_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrackingScanCmd_OperationType_IsValid(int value);
extern const uint32_t TrackingScanCmd_OperationType_internal_data_[];
constexpr TrackingScanCmd_OperationType TrackingScanCmd_OperationType_OperationType_MIN = static_cast<TrackingScanCmd_OperationType>(0);
constexpr TrackingScanCmd_OperationType TrackingScanCmd_OperationType_OperationType_MAX = static_cast<TrackingScanCmd_OperationType>(2);
constexpr int TrackingScanCmd_OperationType_OperationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TrackingScanCmd_OperationType_descriptor();
template <typename T>
const std::string& TrackingScanCmd_OperationType_Name(T value) {
  static_assert(std::is_same<T, TrackingScanCmd_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return TrackingScanCmd_OperationType_Name(static_cast<TrackingScanCmd_OperationType>(value));
}
template <>
inline const std::string& TrackingScanCmd_OperationType_Name(TrackingScanCmd_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrackingScanCmd_OperationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TrackingScanCmd_OperationType_Parse(absl::string_view name, TrackingScanCmd_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackingScanCmd_OperationType>(
      TrackingScanCmd_OperationType_descriptor(), name, value);
}
enum Scanning_ScanType : int {
  Scanning_ScanType_UNKNOWN = 0,
  Scanning_ScanType_CONTINUOUS = 1,
  Scanning_ScanType_TRACKING = 2,
  Scanning_ScanType_LINEAR = 3,
  Scanning_ScanType_Scanning_ScanType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Scanning_ScanType_Scanning_ScanType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Scanning_ScanType_IsValid(int value);
extern const uint32_t Scanning_ScanType_internal_data_[];
constexpr Scanning_ScanType Scanning_ScanType_ScanType_MIN = static_cast<Scanning_ScanType>(0);
constexpr Scanning_ScanType Scanning_ScanType_ScanType_MAX = static_cast<Scanning_ScanType>(3);
constexpr int Scanning_ScanType_ScanType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Scanning_ScanType_descriptor();
template <typename T>
const std::string& Scanning_ScanType_Name(T value) {
  static_assert(std::is_same<T, Scanning_ScanType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScanType_Name().");
  return Scanning_ScanType_Name(static_cast<Scanning_ScanType>(value));
}
template <>
inline const std::string& Scanning_ScanType_Name(Scanning_ScanType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Scanning_ScanType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Scanning_ScanType_Parse(absl::string_view name, Scanning_ScanType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scanning_ScanType>(
      Scanning_ScanType_descriptor(), name, value);
}
enum ImageModeMessage_ImageMode : int {
  ImageModeMessage_ImageMode_AIR_MEASUREMENT_CLOUD = 0,
  ImageModeMessage_ImageMode_TDLAS_CLOUD_CONCENTRATION = 1,
  ImageModeMessage_ImageMode_INFRARED_NORMAL = 2,
  ImageModeMessage_ImageMode_INFRARED_PIP = 3,
  ImageModeMessage_ImageMode_INFRARED_ENHANCED = 4,
  ImageModeMessage_ImageMode_INFRARED_FUSION = 5,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_WHITE_HOT = 6,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_BLACK_HOT = 7,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_IRON_RED = 8,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_CYAN = 9,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_RAINBOW = 10,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_INVERSE_RAINBOW = 11,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_RED_BROWN = 12,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_HEAT_IRON = 13,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_COLD = 14,
  ImageModeMessage_ImageMode_PSEUDO_COLOR_FIRE = 15,
  ImageModeMessage_ImageMode_ImageModeMessage_ImageMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImageModeMessage_ImageMode_ImageModeMessage_ImageMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ImageModeMessage_ImageMode_IsValid(int value);
extern const uint32_t ImageModeMessage_ImageMode_internal_data_[];
constexpr ImageModeMessage_ImageMode ImageModeMessage_ImageMode_ImageMode_MIN = static_cast<ImageModeMessage_ImageMode>(0);
constexpr ImageModeMessage_ImageMode ImageModeMessage_ImageMode_ImageMode_MAX = static_cast<ImageModeMessage_ImageMode>(15);
constexpr int ImageModeMessage_ImageMode_ImageMode_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
ImageModeMessage_ImageMode_descriptor();
template <typename T>
const std::string& ImageModeMessage_ImageMode_Name(T value) {
  static_assert(std::is_same<T, ImageModeMessage_ImageMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImageMode_Name().");
  return ImageModeMessage_ImageMode_Name(static_cast<ImageModeMessage_ImageMode>(value));
}
template <>
inline const std::string& ImageModeMessage_ImageMode_Name(ImageModeMessage_ImageMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageModeMessage_ImageMode_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool ImageModeMessage_ImageMode_Parse(absl::string_view name, ImageModeMessage_ImageMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageModeMessage_ImageMode>(
      ImageModeMessage_ImageMode_descriptor(), name, value);
}
enum MessageType : int {
  GET_PTZDevice = 0,
  SET_MediaSettings = 1,
  GET_MediaSettings = 2,
  GET_ImageSettings = 3,
  SET_ImageSettings = 4,
  GET_VideoAdjustment = 5,
  SET_VideoAdjustment = 6,
  GET_ExposureSettings = 7,
  SET_ExposureSettings = 8,
  GET_DayNightSwitchSettings = 9,
  SET_DayNightSwitchSettings = 10,
  GET_WhiteBalanceSettings = 11,
  SET_WhiteBalanceSettings = 12,
  GET_InfraredImageSettings = 13,
  SET_InfraredImageSettings = 14,
  GET_OSDSettings = 15,
  SET_OSDSettings = 16,
  GET_IPSettings = 17,
  SET_IPSettings = 18,
  GET_PortSettings = 19,
  SET_PortSettings = 20,
  GET_FTPSettings = 21,
  SET_FTPSettings = 22,
  GET_PlatformSettings = 23,
  SET_PlatformSettings = 24,
  GET_AlarmSettings = 25,
  SET_AlarmSettings = 26,
  GET_GasLeakageAlarmSettings = 27,
  SET_GasLeakageAlarmSettings = 28,
  SET_UserAccountSettings = 29,
  GET_UserAccountSettings = 30,
  GET_LoginSecuritySettings = 31,
  SET_LoginSecuritySettings = 32,
  GET_TimeSettings = 33,
  SET_TimeSettings = 34,
  GET_SystemInfo = 35,
  GET_Reboot = 36,
  SET_Reboot = 37,
  QUERY_SYSTEM_LOGS = 38,
  SET_TrackingScanCmd = 39,
  SET_LinearScanSettings = 40,
  SET_LinearScanControl = 41,
  SET_Rotation = 42,
  SET_LensControl = 43,
  GET_LensControl = 44,
  GET_AccessoryControl = 45,
  SET_AccessoryControl = 46,
  SET_Scanning = 47,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(47);
constexpr int MessageType_ARRAYSIZE = 47 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor,
                                                 0, 47>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
enum ControlType : int {
  UNKNOWN = 0,
  ROTATION = 1,
  LENS_CONTROL = 2,
  ACCESSORY_CONTROL = 3,
  PRESET_POSITION = 4,
  SCANNING = 5,
  ControlType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlType_IsValid(int value);
extern const uint32_t ControlType_internal_data_[];
constexpr ControlType ControlType_MIN = static_cast<ControlType>(0);
constexpr ControlType ControlType_MAX = static_cast<ControlType>(5);
constexpr int ControlType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ControlType_descriptor();
template <typename T>
const std::string& ControlType_Name(T value) {
  static_assert(std::is_same<T, ControlType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlType_Name().");
  return ControlType_Name(static_cast<ControlType>(value));
}
template <>
inline const std::string& ControlType_Name(ControlType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControlType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ControlType_Parse(absl::string_view name, ControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlType>(
      ControlType_descriptor(), name, value);
}
enum Direction : int {
  UP = 0,
  DOWN = 1,
  LEFT = 2,
  RIGHT = 3,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Direction_IsValid(int value);
extern const uint32_t Direction_internal_data_[];
constexpr Direction Direction_MIN = static_cast<Direction>(0);
constexpr Direction Direction_MAX = static_cast<Direction>(3);
constexpr int Direction_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Direction_descriptor();
template <typename T>
const std::string& Direction_Name(T value) {
  static_assert(std::is_same<T, Direction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return Direction_Name(static_cast<Direction>(value));
}
template <>
inline const std::string& Direction_Name(Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Direction_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Direction_Parse(absl::string_view name, Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Direction>(
      Direction_descriptor(), name, value);
}
enum StreamType : int {
  MAIN = 0,
  AUXILIARY = 1,
  THIRD = 2,
  FOURTH = 3,
  FIFTH = 4,
  StreamType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StreamType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StreamType_IsValid(int value);
extern const uint32_t StreamType_internal_data_[];
constexpr StreamType StreamType_MIN = static_cast<StreamType>(0);
constexpr StreamType StreamType_MAX = static_cast<StreamType>(4);
constexpr int StreamType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
StreamType_descriptor();
template <typename T>
const std::string& StreamType_Name(T value) {
  static_assert(std::is_same<T, StreamType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StreamType_Name().");
  return StreamType_Name(static_cast<StreamType>(value));
}
template <>
inline const std::string& StreamType_Name(StreamType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StreamType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool StreamType_Parse(absl::string_view name, StreamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamType>(
      StreamType_descriptor(), name, value);
}
enum VideoStreamType : int {
  VIDEO = 0,
  VIDEO_AUDIO = 1,
  VideoStreamType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoStreamType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoStreamType_IsValid(int value);
extern const uint32_t VideoStreamType_internal_data_[];
constexpr VideoStreamType VideoStreamType_MIN = static_cast<VideoStreamType>(0);
constexpr VideoStreamType VideoStreamType_MAX = static_cast<VideoStreamType>(1);
constexpr int VideoStreamType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
VideoStreamType_descriptor();
template <typename T>
const std::string& VideoStreamType_Name(T value) {
  static_assert(std::is_same<T, VideoStreamType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VideoStreamType_Name().");
  return VideoStreamType_Name(static_cast<VideoStreamType>(value));
}
template <>
inline const std::string& VideoStreamType_Name(VideoStreamType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VideoStreamType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool VideoStreamType_Parse(absl::string_view name, VideoStreamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoStreamType>(
      VideoStreamType_descriptor(), name, value);
}
enum Resolution : int {
  RESOLUTION_2560x1440 = 0,
  RESOLUTION_1920x1080 = 1,
  RESOLUTION_1280x960 = 2,
  RESOLUTION_1280x720 = 3,
  RESOLUTION_704x576 = 4,
  RESOLUTION_640x480 = 5,
  Resolution_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Resolution_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Resolution_IsValid(int value);
extern const uint32_t Resolution_internal_data_[];
constexpr Resolution Resolution_MIN = static_cast<Resolution>(0);
constexpr Resolution Resolution_MAX = static_cast<Resolution>(5);
constexpr int Resolution_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Resolution_descriptor();
template <typename T>
const std::string& Resolution_Name(T value) {
  static_assert(std::is_same<T, Resolution>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Resolution_Name().");
  return Resolution_Name(static_cast<Resolution>(value));
}
template <>
inline const std::string& Resolution_Name(Resolution value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Resolution_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Resolution_Parse(absl::string_view name, Resolution* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resolution>(
      Resolution_descriptor(), name, value);
}
enum BitrateType : int {
  CONSTANT = 0,
  VARIABLE = 1,
  BitrateType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BitrateType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BitrateType_IsValid(int value);
extern const uint32_t BitrateType_internal_data_[];
constexpr BitrateType BitrateType_MIN = static_cast<BitrateType>(0);
constexpr BitrateType BitrateType_MAX = static_cast<BitrateType>(1);
constexpr int BitrateType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
BitrateType_descriptor();
template <typename T>
const std::string& BitrateType_Name(T value) {
  static_assert(std::is_same<T, BitrateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BitrateType_Name().");
  return BitrateType_Name(static_cast<BitrateType>(value));
}
template <>
inline const std::string& BitrateType_Name(BitrateType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BitrateType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool BitrateType_Parse(absl::string_view name, BitrateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BitrateType>(
      BitrateType_descriptor(), name, value);
}
enum AudioSource : int {
  LineIn = 0,
  MicIn = 1,
  AudioSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AudioSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AudioSource_IsValid(int value);
extern const uint32_t AudioSource_internal_data_[];
constexpr AudioSource AudioSource_MIN = static_cast<AudioSource>(0);
constexpr AudioSource AudioSource_MAX = static_cast<AudioSource>(1);
constexpr int AudioSource_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AudioSource_descriptor();
template <typename T>
const std::string& AudioSource_Name(T value) {
  static_assert(std::is_same<T, AudioSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AudioSource_Name().");
  return AudioSource_Name(static_cast<AudioSource>(value));
}
template <>
inline const std::string& AudioSource_Name(AudioSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioSource_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AudioSource_Parse(absl::string_view name, AudioSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioSource>(
      AudioSource_descriptor(), name, value);
}
enum VideoCodec : int {
  H264 = 0,
  H265 = 1,
  MPEG4 = 2,
  MJPEG = 3,
  VideoCodec_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoCodec_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoCodec_IsValid(int value);
extern const uint32_t VideoCodec_internal_data_[];
constexpr VideoCodec VideoCodec_MIN = static_cast<VideoCodec>(0);
constexpr VideoCodec VideoCodec_MAX = static_cast<VideoCodec>(3);
constexpr int VideoCodec_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
VideoCodec_descriptor();
template <typename T>
const std::string& VideoCodec_Name(T value) {
  static_assert(std::is_same<T, VideoCodec>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VideoCodec_Name().");
  return VideoCodec_Name(static_cast<VideoCodec>(value));
}
template <>
inline const std::string& VideoCodec_Name(VideoCodec value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VideoCodec_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool VideoCodec_Parse(absl::string_view name, VideoCodec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoCodec>(
      VideoCodec_descriptor(), name, value);
}
enum AudioCodec : int {
  G722 = 0,
  G711 = 1,
  ACC = 2,
  AudioCodec_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AudioCodec_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AudioCodec_IsValid(int value);
extern const uint32_t AudioCodec_internal_data_[];
constexpr AudioCodec AudioCodec_MIN = static_cast<AudioCodec>(0);
constexpr AudioCodec AudioCodec_MAX = static_cast<AudioCodec>(2);
constexpr int AudioCodec_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AudioCodec_descriptor();
template <typename T>
const std::string& AudioCodec_Name(T value) {
  static_assert(std::is_same<T, AudioCodec>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AudioCodec_Name().");
  return AudioCodec_Name(static_cast<AudioCodec>(value));
}
template <>
inline const std::string& AudioCodec_Name(AudioCodec value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioCodec_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AudioCodec_Parse(absl::string_view name, AudioCodec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioCodec>(
      AudioCodec_descriptor(), name, value);
}
enum FrameRate : int {
  FPS_10 = 0,
  FPS_15 = 1,
  FPS_20 = 2,
  FPS_25 = 3,
  FPS_30 = 4,
  FPS_35 = 5,
  FPS_40 = 6,
  FPS_45 = 7,
  FPS_50 = 8,
  FPS_55 = 9,
  FPS_60 = 10,
  FrameRate_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FrameRate_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FrameRate_IsValid(int value);
extern const uint32_t FrameRate_internal_data_[];
constexpr FrameRate FrameRate_MIN = static_cast<FrameRate>(0);
constexpr FrameRate FrameRate_MAX = static_cast<FrameRate>(10);
constexpr int FrameRate_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
FrameRate_descriptor();
template <typename T>
const std::string& FrameRate_Name(T value) {
  static_assert(std::is_same<T, FrameRate>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FrameRate_Name().");
  return FrameRate_Name(static_cast<FrameRate>(value));
}
template <>
inline const std::string& FrameRate_Name(FrameRate value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FrameRate_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool FrameRate_Parse(absl::string_view name, FrameRate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FrameRate>(
      FrameRate_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WhiteBalanceSettings_ManualWhiteBalance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:WhiteBalanceSettings.ManualWhiteBalance) */ {
 public:
  inline WhiteBalanceSettings_ManualWhiteBalance() : WhiteBalanceSettings_ManualWhiteBalance(nullptr) {}
  ~WhiteBalanceSettings_ManualWhiteBalance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhiteBalanceSettings_ManualWhiteBalance(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhiteBalanceSettings_ManualWhiteBalance(const WhiteBalanceSettings_ManualWhiteBalance& from) : WhiteBalanceSettings_ManualWhiteBalance(nullptr, from) {}
  inline WhiteBalanceSettings_ManualWhiteBalance(WhiteBalanceSettings_ManualWhiteBalance&& from) noexcept
      : WhiteBalanceSettings_ManualWhiteBalance(nullptr, std::move(from)) {}
  inline WhiteBalanceSettings_ManualWhiteBalance& operator=(const WhiteBalanceSettings_ManualWhiteBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhiteBalanceSettings_ManualWhiteBalance& operator=(WhiteBalanceSettings_ManualWhiteBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhiteBalanceSettings_ManualWhiteBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhiteBalanceSettings_ManualWhiteBalance* internal_default_instance() {
    return reinterpret_cast<const WhiteBalanceSettings_ManualWhiteBalance*>(
        &_WhiteBalanceSettings_ManualWhiteBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(WhiteBalanceSettings_ManualWhiteBalance& a, WhiteBalanceSettings_ManualWhiteBalance& b) { a.Swap(&b); }
  inline void Swap(WhiteBalanceSettings_ManualWhiteBalance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhiteBalanceSettings_ManualWhiteBalance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhiteBalanceSettings_ManualWhiteBalance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WhiteBalanceSettings_ManualWhiteBalance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhiteBalanceSettings_ManualWhiteBalance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhiteBalanceSettings_ManualWhiteBalance& from) { WhiteBalanceSettings_ManualWhiteBalance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhiteBalanceSettings_ManualWhiteBalance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "WhiteBalanceSettings.ManualWhiteBalance"; }

 protected:
  explicit WhiteBalanceSettings_ManualWhiteBalance(::google::protobuf::Arena* arena);
  WhiteBalanceSettings_ManualWhiteBalance(::google::protobuf::Arena* arena, const WhiteBalanceSettings_ManualWhiteBalance& from);
  WhiteBalanceSettings_ManualWhiteBalance(::google::protobuf::Arena* arena, WhiteBalanceSettings_ManualWhiteBalance&& from) noexcept
      : WhiteBalanceSettings_ManualWhiteBalance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRedGainFieldNumber = 1,
    kBlueGainFieldNumber = 2,
  };
  // int32 red_gain = 1;
  void clear_red_gain() ;
  ::int32_t red_gain() const;
  void set_red_gain(::int32_t value);

  private:
  ::int32_t _internal_red_gain() const;
  void _internal_set_red_gain(::int32_t value);

  public:
  // int32 blue_gain = 2;
  void clear_blue_gain() ;
  ::int32_t blue_gain() const;
  void set_blue_gain(::int32_t value);

  private:
  ::int32_t _internal_blue_gain() const;
  void _internal_set_blue_gain(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:WhiteBalanceSettings.ManualWhiteBalance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WhiteBalanceSettings_ManualWhiteBalance_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhiteBalanceSettings_ManualWhiteBalance& from_msg);
    ::int32_t red_gain_;
    ::int32_t blue_gain_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class VideoAdjustment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VideoAdjustment) */ {
 public:
  inline VideoAdjustment() : VideoAdjustment(nullptr) {}
  ~VideoAdjustment() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VideoAdjustment(
      ::google::protobuf::internal::ConstantInitialized);

  inline VideoAdjustment(const VideoAdjustment& from) : VideoAdjustment(nullptr, from) {}
  inline VideoAdjustment(VideoAdjustment&& from) noexcept
      : VideoAdjustment(nullptr, std::move(from)) {}
  inline VideoAdjustment& operator=(const VideoAdjustment& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoAdjustment& operator=(VideoAdjustment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoAdjustment& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoAdjustment* internal_default_instance() {
    return reinterpret_cast<const VideoAdjustment*>(
        &_VideoAdjustment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(VideoAdjustment& a, VideoAdjustment& b) { a.Swap(&b); }
  inline void Swap(VideoAdjustment* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoAdjustment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoAdjustment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VideoAdjustment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VideoAdjustment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VideoAdjustment& from) { VideoAdjustment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoAdjustment* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "VideoAdjustment"; }

 protected:
  explicit VideoAdjustment(::google::protobuf::Arena* arena);
  VideoAdjustment(::google::protobuf::Arena* arena, const VideoAdjustment& from);
  VideoAdjustment(::google::protobuf::Arena* arena, VideoAdjustment&& from) noexcept
      : VideoAdjustment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MirrorSetting = VideoAdjustment_MirrorSetting;
  static constexpr MirrorSetting NONE = VideoAdjustment_MirrorSetting_NONE;
  static constexpr MirrorSetting HORIZONTAL = VideoAdjustment_MirrorSetting_HORIZONTAL;
  static constexpr MirrorSetting VERTICAL = VideoAdjustment_MirrorSetting_VERTICAL;
  static inline bool MirrorSetting_IsValid(int value) {
    return VideoAdjustment_MirrorSetting_IsValid(value);
  }
  static constexpr MirrorSetting MirrorSetting_MIN = VideoAdjustment_MirrorSetting_MirrorSetting_MIN;
  static constexpr MirrorSetting MirrorSetting_MAX = VideoAdjustment_MirrorSetting_MirrorSetting_MAX;
  static constexpr int MirrorSetting_ARRAYSIZE = VideoAdjustment_MirrorSetting_MirrorSetting_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MirrorSetting_descriptor() {
    return VideoAdjustment_MirrorSetting_descriptor();
  }
  template <typename T>
  static inline const std::string& MirrorSetting_Name(T value) {
    return VideoAdjustment_MirrorSetting_Name(value);
  }
  static inline bool MirrorSetting_Parse(absl::string_view name, MirrorSetting* value) {
    return VideoAdjustment_MirrorSetting_Parse(name, value);
  }
  using StabilizationSetting = VideoAdjustment_StabilizationSetting;
  static constexpr StabilizationSetting OFF = VideoAdjustment_StabilizationSetting_OFF;
  static constexpr StabilizationSetting PAL = VideoAdjustment_StabilizationSetting_PAL;
  static constexpr StabilizationSetting NTSC = VideoAdjustment_StabilizationSetting_NTSC;
  static inline bool StabilizationSetting_IsValid(int value) {
    return VideoAdjustment_StabilizationSetting_IsValid(value);
  }
  static constexpr StabilizationSetting StabilizationSetting_MIN = VideoAdjustment_StabilizationSetting_StabilizationSetting_MIN;
  static constexpr StabilizationSetting StabilizationSetting_MAX = VideoAdjustment_StabilizationSetting_StabilizationSetting_MAX;
  static constexpr int StabilizationSetting_ARRAYSIZE = VideoAdjustment_StabilizationSetting_StabilizationSetting_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StabilizationSetting_descriptor() {
    return VideoAdjustment_StabilizationSetting_descriptor();
  }
  template <typename T>
  static inline const std::string& StabilizationSetting_Name(T value) {
    return VideoAdjustment_StabilizationSetting_Name(value);
  }
  static inline bool StabilizationSetting_Parse(absl::string_view name, StabilizationSetting* value) {
    return VideoAdjustment_StabilizationSetting_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMirrorSettingFieldNumber = 1,
    kStabilizationSettingFieldNumber = 2,
  };
  // .VideoAdjustment.MirrorSetting mirror_setting = 1;
  void clear_mirror_setting() ;
  ::VideoAdjustment_MirrorSetting mirror_setting() const;
  void set_mirror_setting(::VideoAdjustment_MirrorSetting value);

  private:
  ::VideoAdjustment_MirrorSetting _internal_mirror_setting() const;
  void _internal_set_mirror_setting(::VideoAdjustment_MirrorSetting value);

  public:
  // .VideoAdjustment.StabilizationSetting stabilization_setting = 2;
  void clear_stabilization_setting() ;
  ::VideoAdjustment_StabilizationSetting stabilization_setting() const;
  void set_stabilization_setting(::VideoAdjustment_StabilizationSetting value);

  private:
  ::VideoAdjustment_StabilizationSetting _internal_stabilization_setting() const;
  void _internal_set_stabilization_setting(::VideoAdjustment_StabilizationSetting value);

  public:
  // @@protoc_insertion_point(class_scope:VideoAdjustment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VideoAdjustment_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VideoAdjustment& from_msg);
    int mirror_setting_;
    int stabilization_setting_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class UserAccountSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:UserAccountSettings) */ {
 public:
  inline UserAccountSettings() : UserAccountSettings(nullptr) {}
  ~UserAccountSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserAccountSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserAccountSettings(const UserAccountSettings& from) : UserAccountSettings(nullptr, from) {}
  inline UserAccountSettings(UserAccountSettings&& from) noexcept
      : UserAccountSettings(nullptr, std::move(from)) {}
  inline UserAccountSettings& operator=(const UserAccountSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAccountSettings& operator=(UserAccountSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAccountSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAccountSettings* internal_default_instance() {
    return reinterpret_cast<const UserAccountSettings*>(
        &_UserAccountSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(UserAccountSettings& a, UserAccountSettings& b) { a.Swap(&b); }
  inline void Swap(UserAccountSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAccountSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAccountSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserAccountSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserAccountSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserAccountSettings& from) { UserAccountSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserAccountSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "UserAccountSettings"; }

 protected:
  explicit UserAccountSettings(::google::protobuf::Arena* arena);
  UserAccountSettings(::google::protobuf::Arena* arena, const UserAccountSettings& from);
  UserAccountSettings(::google::protobuf::Arena* arena, UserAccountSettings&& from) noexcept
      : UserAccountSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = UserAccountSettings_OperationType;
  static constexpr OperationType OPERATION_UNSPECIFIED = UserAccountSettings_OperationType_OPERATION_UNSPECIFIED;
  static constexpr OperationType ADD = UserAccountSettings_OperationType_ADD;
  static constexpr OperationType DELETE = UserAccountSettings_OperationType_DELETE;
  static constexpr OperationType MODIFY = UserAccountSettings_OperationType_MODIFY;
  static constexpr OperationType SUSPEND = UserAccountSettings_OperationType_SUSPEND;
  static constexpr OperationType RESUME = UserAccountSettings_OperationType_RESUME;
  static inline bool OperationType_IsValid(int value) {
    return UserAccountSettings_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = UserAccountSettings_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = UserAccountSettings_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = UserAccountSettings_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return UserAccountSettings_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return UserAccountSettings_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return UserAccountSettings_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRequestIdFieldNumber = 1,
    kRequestPwdFieldNumber = 2,
    kTargetUserIdFieldNumber = 4,
    kNewPasswordFieldNumber = 5,
    kOperationTypeFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // string request_pwd = 2;
  void clear_request_pwd() ;
  const std::string& request_pwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_pwd(Arg_&& arg, Args_... args);
  std::string* mutable_request_pwd();
  PROTOBUF_NODISCARD std::string* release_request_pwd();
  void set_allocated_request_pwd(std::string* value);

  private:
  const std::string& _internal_request_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_pwd(
      const std::string& value);
  std::string* _internal_mutable_request_pwd();

  public:
  // string target_user_id = 4;
  void clear_target_user_id() ;
  const std::string& target_user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_user_id();
  PROTOBUF_NODISCARD std::string* release_target_user_id();
  void set_allocated_target_user_id(std::string* value);

  private:
  const std::string& _internal_target_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_user_id(
      const std::string& value);
  std::string* _internal_mutable_target_user_id();

  public:
  // string new_password = 5;
  void clear_new_password() ;
  const std::string& new_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_password(Arg_&& arg, Args_... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* value);

  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(
      const std::string& value);
  std::string* _internal_mutable_new_password();

  public:
  // .UserAccountSettings.OperationType operation_type = 3;
  void clear_operation_type() ;
  ::UserAccountSettings_OperationType operation_type() const;
  void set_operation_type(::UserAccountSettings_OperationType value);

  private:
  ::UserAccountSettings_OperationType _internal_operation_type() const;
  void _internal_set_operation_type(::UserAccountSettings_OperationType value);

  public:
  // @@protoc_insertion_point(class_scope:UserAccountSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      75, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UserAccountSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserAccountSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::google::protobuf::internal::ArenaStringPtr request_pwd_;
    ::google::protobuf::internal::ArenaStringPtr target_user_id_;
    ::google::protobuf::internal::ArenaStringPtr new_password_;
    int operation_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class TrackingScanCmd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TrackingScanCmd) */ {
 public:
  inline TrackingScanCmd() : TrackingScanCmd(nullptr) {}
  ~TrackingScanCmd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackingScanCmd(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackingScanCmd(const TrackingScanCmd& from) : TrackingScanCmd(nullptr, from) {}
  inline TrackingScanCmd(TrackingScanCmd&& from) noexcept
      : TrackingScanCmd(nullptr, std::move(from)) {}
  inline TrackingScanCmd& operator=(const TrackingScanCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingScanCmd& operator=(TrackingScanCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingScanCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingScanCmd* internal_default_instance() {
    return reinterpret_cast<const TrackingScanCmd*>(
        &_TrackingScanCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(TrackingScanCmd& a, TrackingScanCmd& b) { a.Swap(&b); }
  inline void Swap(TrackingScanCmd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingScanCmd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingScanCmd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TrackingScanCmd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackingScanCmd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackingScanCmd& from) { TrackingScanCmd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrackingScanCmd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TrackingScanCmd"; }

 protected:
  explicit TrackingScanCmd(::google::protobuf::Arena* arena);
  TrackingScanCmd(::google::protobuf::Arena* arena, const TrackingScanCmd& from);
  TrackingScanCmd(::google::protobuf::Arena* arena, TrackingScanCmd&& from) noexcept
      : TrackingScanCmd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = TrackingScanCmd_OperationType;
  static constexpr OperationType PAN_TILT = TrackingScanCmd_OperationType_PAN_TILT;
  static constexpr OperationType ZOOM = TrackingScanCmd_OperationType_ZOOM;
  static constexpr OperationType PRESET_CALL = TrackingScanCmd_OperationType_PRESET_CALL;
  static inline bool OperationType_IsValid(int value) {
    return TrackingScanCmd_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = TrackingScanCmd_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = TrackingScanCmd_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = TrackingScanCmd_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return TrackingScanCmd_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return TrackingScanCmd_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return TrackingScanCmd_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kPanAngleFieldNumber = 2,
    kTiltAngleFieldNumber = 3,
    kZoomFactorFieldNumber = 4,
    kPresetNumberFieldNumber = 5,
  };
  // .TrackingScanCmd.OperationType type = 1;
  void clear_type() ;
  ::TrackingScanCmd_OperationType type() const;
  void set_type(::TrackingScanCmd_OperationType value);

  private:
  ::TrackingScanCmd_OperationType _internal_type() const;
  void _internal_set_type(::TrackingScanCmd_OperationType value);

  public:
  // float pan_angle = 2;
  void clear_pan_angle() ;
  float pan_angle() const;
  void set_pan_angle(float value);

  private:
  float _internal_pan_angle() const;
  void _internal_set_pan_angle(float value);

  public:
  // float tilt_angle = 3;
  void clear_tilt_angle() ;
  float tilt_angle() const;
  void set_tilt_angle(float value);

  private:
  float _internal_tilt_angle() const;
  void _internal_set_tilt_angle(float value);

  public:
  // float zoom_factor = 4;
  void clear_zoom_factor() ;
  float zoom_factor() const;
  void set_zoom_factor(float value);

  private:
  float _internal_zoom_factor() const;
  void _internal_set_zoom_factor(float value);

  public:
  // int32 preset_number = 5;
  void clear_preset_number() ;
  ::int32_t preset_number() const;
  void set_preset_number(::int32_t value);

  private:
  ::int32_t _internal_preset_number() const;
  void _internal_set_preset_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TrackingScanCmd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TrackingScanCmd_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackingScanCmd& from_msg);
    int type_;
    float pan_angle_;
    float tilt_angle_;
    float zoom_factor_;
    ::int32_t preset_number_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class TimeSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TimeSettings) */ {
 public:
  inline TimeSettings() : TimeSettings(nullptr) {}
  ~TimeSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimeSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimeSettings(const TimeSettings& from) : TimeSettings(nullptr, from) {}
  inline TimeSettings(TimeSettings&& from) noexcept
      : TimeSettings(nullptr, std::move(from)) {}
  inline TimeSettings& operator=(const TimeSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeSettings& operator=(TimeSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeSettings* internal_default_instance() {
    return reinterpret_cast<const TimeSettings*>(
        &_TimeSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(TimeSettings& a, TimeSettings& b) { a.Swap(&b); }
  inline void Swap(TimeSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TimeSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimeSettings& from) { TimeSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TimeSettings"; }

 protected:
  explicit TimeSettings(::google::protobuf::Arena* arena);
  TimeSettings(::google::protobuf::Arena* arena, const TimeSettings& from);
  TimeSettings(::google::protobuf::Arena* arena, TimeSettings&& from) noexcept
      : TimeSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNtpServerFieldNumber = 4,
    kManualTimeFieldNumber = 6,
    kTimeZoneFieldNumber = 1,
    kAutoSyncLocalTimeFieldNumber = 2,
    kEnableNtpSyncFieldNumber = 3,
    kSyncIntervalFieldNumber = 5,
  };
  // string ntp_server = 4;
  void clear_ntp_server() ;
  const std::string& ntp_server() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ntp_server(Arg_&& arg, Args_... args);
  std::string* mutable_ntp_server();
  PROTOBUF_NODISCARD std::string* release_ntp_server();
  void set_allocated_ntp_server(std::string* value);

  private:
  const std::string& _internal_ntp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ntp_server(
      const std::string& value);
  std::string* _internal_mutable_ntp_server();

  public:
  // string manual_time = 6;
  void clear_manual_time() ;
  const std::string& manual_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_manual_time(Arg_&& arg, Args_... args);
  std::string* mutable_manual_time();
  PROTOBUF_NODISCARD std::string* release_manual_time();
  void set_allocated_manual_time(std::string* value);

  private:
  const std::string& _internal_manual_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manual_time(
      const std::string& value);
  std::string* _internal_mutable_manual_time();

  public:
  // int32 time_zone = 1;
  void clear_time_zone() ;
  ::int32_t time_zone() const;
  void set_time_zone(::int32_t value);

  private:
  ::int32_t _internal_time_zone() const;
  void _internal_set_time_zone(::int32_t value);

  public:
  // bool auto_sync_local_time = 2;
  void clear_auto_sync_local_time() ;
  bool auto_sync_local_time() const;
  void set_auto_sync_local_time(bool value);

  private:
  bool _internal_auto_sync_local_time() const;
  void _internal_set_auto_sync_local_time(bool value);

  public:
  // bool enable_ntp_sync = 3;
  void clear_enable_ntp_sync() ;
  bool enable_ntp_sync() const;
  void set_enable_ntp_sync(bool value);

  private:
  bool _internal_enable_ntp_sync() const;
  void _internal_set_enable_ntp_sync(bool value);

  public:
  // int32 sync_interval = 5;
  void clear_sync_interval() ;
  ::int32_t sync_interval() const;
  void set_sync_interval(::int32_t value);

  private:
  ::int32_t _internal_sync_interval() const;
  void _internal_set_sync_interval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:TimeSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      42, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TimeSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimeSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ntp_server_;
    ::google::protobuf::internal::ArenaStringPtr manual_time_;
    ::int32_t time_zone_;
    bool auto_sync_local_time_;
    bool enable_ntp_sync_;
    ::int32_t sync_interval_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class SystemInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SystemInfo) */ {
 public:
  inline SystemInfo() : SystemInfo(nullptr) {}
  ~SystemInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SystemInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SystemInfo(const SystemInfo& from) : SystemInfo(nullptr, from) {}
  inline SystemInfo(SystemInfo&& from) noexcept
      : SystemInfo(nullptr, std::move(from)) {}
  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
        &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(SystemInfo& a, SystemInfo& b) { a.Swap(&b); }
  inline void Swap(SystemInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SystemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SystemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SystemInfo& from) { SystemInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SystemInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SystemInfo"; }

 protected:
  explicit SystemInfo(::google::protobuf::Arena* arena);
  SystemInfo(::google::protobuf::Arena* arena, const SystemInfo& from);
  SystemInfo(::google::protobuf::Arena* arena, SystemInfo&& from) noexcept
      : SystemInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceNameFieldNumber = 1,
    kMainControllerVersionFieldNumber = 3,
    kAlgorithmVersionFieldNumber = 4,
    kModelVersionFieldNumber = 5,
  };
  // string device_name = 1;
  void clear_device_name() ;
  const std::string& device_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(Arg_&& arg, Args_... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* value);

  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(
      const std::string& value);
  std::string* _internal_mutable_device_name();

  public:
  // string main_controller_version = 3;
  void clear_main_controller_version() ;
  const std::string& main_controller_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_main_controller_version(Arg_&& arg, Args_... args);
  std::string* mutable_main_controller_version();
  PROTOBUF_NODISCARD std::string* release_main_controller_version();
  void set_allocated_main_controller_version(std::string* value);

  private:
  const std::string& _internal_main_controller_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_controller_version(
      const std::string& value);
  std::string* _internal_mutable_main_controller_version();

  public:
  // string algorithm_version = 4;
  void clear_algorithm_version() ;
  const std::string& algorithm_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm_version(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm_version();
  PROTOBUF_NODISCARD std::string* release_algorithm_version();
  void set_allocated_algorithm_version(std::string* value);

  private:
  const std::string& _internal_algorithm_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm_version(
      const std::string& value);
  std::string* _internal_mutable_algorithm_version();

  public:
  // string model_version = 5;
  void clear_model_version() ;
  const std::string& model_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_version(Arg_&& arg, Args_... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* value);

  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(
      const std::string& value);
  std::string* _internal_mutable_model_version();

  public:
  // @@protoc_insertion_point(class_scope:SystemInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      83, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SystemInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SystemInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_name_;
    ::google::protobuf::internal::ArenaStringPtr main_controller_version_;
    ::google::protobuf::internal::ArenaStringPtr algorithm_version_;
    ::google::protobuf::internal::ArenaStringPtr model_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Scanning final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Scanning) */ {
 public:
  inline Scanning() : Scanning(nullptr) {}
  ~Scanning() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Scanning(
      ::google::protobuf::internal::ConstantInitialized);

  inline Scanning(const Scanning& from) : Scanning(nullptr, from) {}
  inline Scanning(Scanning&& from) noexcept
      : Scanning(nullptr, std::move(from)) {}
  inline Scanning& operator=(const Scanning& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scanning& operator=(Scanning&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scanning& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scanning* internal_default_instance() {
    return reinterpret_cast<const Scanning*>(
        &_Scanning_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(Scanning& a, Scanning& b) { a.Swap(&b); }
  inline void Swap(Scanning* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scanning* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scanning* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Scanning>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Scanning& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Scanning& from) { Scanning::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Scanning* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Scanning"; }

 protected:
  explicit Scanning(::google::protobuf::Arena* arena);
  Scanning(::google::protobuf::Arena* arena, const Scanning& from);
  Scanning(::google::protobuf::Arena* arena, Scanning&& from) noexcept
      : Scanning(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ScanType = Scanning_ScanType;
  static constexpr ScanType UNKNOWN = Scanning_ScanType_UNKNOWN;
  static constexpr ScanType CONTINUOUS = Scanning_ScanType_CONTINUOUS;
  static constexpr ScanType TRACKING = Scanning_ScanType_TRACKING;
  static constexpr ScanType LINEAR = Scanning_ScanType_LINEAR;
  static inline bool ScanType_IsValid(int value) {
    return Scanning_ScanType_IsValid(value);
  }
  static constexpr ScanType ScanType_MIN = Scanning_ScanType_ScanType_MIN;
  static constexpr ScanType ScanType_MAX = Scanning_ScanType_ScanType_MAX;
  static constexpr int ScanType_ARRAYSIZE = Scanning_ScanType_ScanType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ScanType_descriptor() {
    return Scanning_ScanType_descriptor();
  }
  template <typename T>
  static inline const std::string& ScanType_Name(T value) {
    return Scanning_ScanType_Name(value);
  }
  static inline bool ScanType_Parse(absl::string_view name, ScanType* value) {
    return Scanning_ScanType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kScanTypeFieldNumber = 1,
  };
  // .Scanning.ScanType scan_type = 1;
  void clear_scan_type() ;
  ::Scanning_ScanType scan_type() const;
  void set_scan_type(::Scanning_ScanType value);

  private:
  ::Scanning_ScanType _internal_scan_type() const;
  void _internal_set_scan_type(::Scanning_ScanType value);

  public:
  // @@protoc_insertion_point(class_scope:Scanning)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Scanning_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Scanning& from_msg);
    int scan_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Rotation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Rotation(const Rotation& from) : Rotation(nullptr, from) {}
  inline Rotation(Rotation&& from) noexcept
      : Rotation(nullptr, std::move(from)) {}
  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
        &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(Rotation& a, Rotation& b) { a.Swap(&b); }
  inline void Swap(Rotation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rotation& from) { Rotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rotation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Rotation"; }

 protected:
  explicit Rotation(::google::protobuf::Arena* arena);
  Rotation(::google::protobuf::Arena* arena, const Rotation& from);
  Rotation(::google::protobuf::Arena* arena, Rotation&& from) noexcept
      : Rotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirectionFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // .Direction direction = 1;
  void clear_direction() ;
  ::Direction direction() const;
  void set_direction(::Direction value);

  private:
  ::Direction _internal_direction() const;
  void _internal_set_direction(::Direction value);

  public:
  // float speed = 2;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:Rotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Rotation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Rotation& from_msg);
    int direction_;
    float speed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Reboot_WeeklyRebootSchedule final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Reboot.WeeklyRebootSchedule) */ {
 public:
  inline Reboot_WeeklyRebootSchedule() : Reboot_WeeklyRebootSchedule(nullptr) {}
  ~Reboot_WeeklyRebootSchedule() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Reboot_WeeklyRebootSchedule(
      ::google::protobuf::internal::ConstantInitialized);

  inline Reboot_WeeklyRebootSchedule(const Reboot_WeeklyRebootSchedule& from) : Reboot_WeeklyRebootSchedule(nullptr, from) {}
  inline Reboot_WeeklyRebootSchedule(Reboot_WeeklyRebootSchedule&& from) noexcept
      : Reboot_WeeklyRebootSchedule(nullptr, std::move(from)) {}
  inline Reboot_WeeklyRebootSchedule& operator=(const Reboot_WeeklyRebootSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reboot_WeeklyRebootSchedule& operator=(Reboot_WeeklyRebootSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reboot_WeeklyRebootSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reboot_WeeklyRebootSchedule* internal_default_instance() {
    return reinterpret_cast<const Reboot_WeeklyRebootSchedule*>(
        &_Reboot_WeeklyRebootSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(Reboot_WeeklyRebootSchedule& a, Reboot_WeeklyRebootSchedule& b) { a.Swap(&b); }
  inline void Swap(Reboot_WeeklyRebootSchedule* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reboot_WeeklyRebootSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reboot_WeeklyRebootSchedule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Reboot_WeeklyRebootSchedule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Reboot_WeeklyRebootSchedule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Reboot_WeeklyRebootSchedule& from) { Reboot_WeeklyRebootSchedule::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Reboot_WeeklyRebootSchedule* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Reboot.WeeklyRebootSchedule"; }

 protected:
  explicit Reboot_WeeklyRebootSchedule(::google::protobuf::Arena* arena);
  Reboot_WeeklyRebootSchedule(::google::protobuf::Arena* arena, const Reboot_WeeklyRebootSchedule& from);
  Reboot_WeeklyRebootSchedule(::google::protobuf::Arena* arena, Reboot_WeeklyRebootSchedule&& from) noexcept
      : Reboot_WeeklyRebootSchedule(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeOfDayFieldNumber = 2,
    kDayOfWeekFieldNumber = 1,
  };
  // string time_of_day = 2;
  void clear_time_of_day() ;
  const std::string& time_of_day() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_of_day(Arg_&& arg, Args_... args);
  std::string* mutable_time_of_day();
  PROTOBUF_NODISCARD std::string* release_time_of_day();
  void set_allocated_time_of_day(std::string* value);

  private:
  const std::string& _internal_time_of_day() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_of_day(
      const std::string& value);
  std::string* _internal_mutable_time_of_day();

  public:
  // int32 day_of_week = 1;
  void clear_day_of_week() ;
  ::int32_t day_of_week() const;
  void set_day_of_week(::int32_t value);

  private:
  ::int32_t _internal_day_of_week() const;
  void _internal_set_day_of_week(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Reboot.WeeklyRebootSchedule)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Reboot_WeeklyRebootSchedule_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Reboot_WeeklyRebootSchedule& from_msg);
    ::google::protobuf::internal::ArenaStringPtr time_of_day_;
    ::int32_t day_of_week_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PresetPositionOp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PresetPositionOp) */ {
 public:
  inline PresetPositionOp() : PresetPositionOp(nullptr) {}
  ~PresetPositionOp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PresetPositionOp(
      ::google::protobuf::internal::ConstantInitialized);

  inline PresetPositionOp(const PresetPositionOp& from) : PresetPositionOp(nullptr, from) {}
  inline PresetPositionOp(PresetPositionOp&& from) noexcept
      : PresetPositionOp(nullptr, std::move(from)) {}
  inline PresetPositionOp& operator=(const PresetPositionOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresetPositionOp& operator=(PresetPositionOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PresetPositionOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresetPositionOp* internal_default_instance() {
    return reinterpret_cast<const PresetPositionOp*>(
        &_PresetPositionOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(PresetPositionOp& a, PresetPositionOp& b) { a.Swap(&b); }
  inline void Swap(PresetPositionOp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresetPositionOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresetPositionOp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PresetPositionOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PresetPositionOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PresetPositionOp& from) { PresetPositionOp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PresetPositionOp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PresetPositionOp"; }

 protected:
  explicit PresetPositionOp(::google::protobuf::Arena* arena);
  PresetPositionOp(::google::protobuf::Arena* arena, const PresetPositionOp& from);
  PresetPositionOp(::google::protobuf::Arena* arena, PresetPositionOp&& from) noexcept
      : PresetPositionOp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PresetOperatType = PresetPositionOp_PresetOperatType;
  static constexpr PresetOperatType ADD = PresetPositionOp_PresetOperatType_ADD;
  static constexpr PresetOperatType DEL = PresetPositionOp_PresetOperatType_DEL;
  static constexpr PresetOperatType MODIFY = PresetPositionOp_PresetOperatType_MODIFY;
  static inline bool PresetOperatType_IsValid(int value) {
    return PresetPositionOp_PresetOperatType_IsValid(value);
  }
  static constexpr PresetOperatType PresetOperatType_MIN = PresetPositionOp_PresetOperatType_PresetOperatType_MIN;
  static constexpr PresetOperatType PresetOperatType_MAX = PresetPositionOp_PresetOperatType_PresetOperatType_MAX;
  static constexpr int PresetOperatType_ARRAYSIZE = PresetPositionOp_PresetOperatType_PresetOperatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetOperatType_descriptor() {
    return PresetPositionOp_PresetOperatType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetOperatType_Name(T value) {
    return PresetPositionOp_PresetOperatType_Name(value);
  }
  static inline bool PresetOperatType_Parse(absl::string_view name, PresetOperatType* value) {
    return PresetPositionOp_PresetOperatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1;
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:PresetPositionOp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      31, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PresetPositionOp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PresetPositionOp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PresetPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PresetPosition) */ {
 public:
  inline PresetPosition() : PresetPosition(nullptr) {}
  ~PresetPosition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PresetPosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline PresetPosition(const PresetPosition& from) : PresetPosition(nullptr, from) {}
  inline PresetPosition(PresetPosition&& from) noexcept
      : PresetPosition(nullptr, std::move(from)) {}
  inline PresetPosition& operator=(const PresetPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresetPosition& operator=(PresetPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PresetPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresetPosition* internal_default_instance() {
    return reinterpret_cast<const PresetPosition*>(
        &_PresetPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(PresetPosition& a, PresetPosition& b) { a.Swap(&b); }
  inline void Swap(PresetPosition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresetPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresetPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PresetPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PresetPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PresetPosition& from) { PresetPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PresetPosition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PresetPosition"; }

 protected:
  explicit PresetPosition(::google::protobuf::Arena* arena);
  PresetPosition(::google::protobuf::Arena* arena, const PresetPosition& from);
  PresetPosition(::google::protobuf::Arena* arena, PresetPosition&& from) noexcept
      : PresetPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
    kDwellTimeSecondsFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 number = 2;
  void clear_number() ;
  ::int32_t number() const;
  void set_number(::int32_t value);

  private:
  ::int32_t _internal_number() const;
  void _internal_set_number(::int32_t value);

  public:
  // int32 dwell_time_seconds = 3;
  void clear_dwell_time_seconds() ;
  ::int32_t dwell_time_seconds() const;
  void set_dwell_time_seconds(::int32_t value);

  private:
  ::int32_t _internal_dwell_time_seconds() const;
  void _internal_set_dwell_time_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PresetPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      27, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PresetPosition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PresetPosition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t number_;
    ::int32_t dwell_time_seconds_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PortSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PortSettings) */ {
 public:
  inline PortSettings() : PortSettings(nullptr) {}
  ~PortSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortSettings(const PortSettings& from) : PortSettings(nullptr, from) {}
  inline PortSettings(PortSettings&& from) noexcept
      : PortSettings(nullptr, std::move(from)) {}
  inline PortSettings& operator=(const PortSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortSettings& operator=(PortSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortSettings* internal_default_instance() {
    return reinterpret_cast<const PortSettings*>(
        &_PortSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(PortSettings& a, PortSettings& b) { a.Swap(&b); }
  inline void Swap(PortSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortSettings& from) { PortSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PortSettings"; }

 protected:
  explicit PortSettings(::google::protobuf::Arena* arena);
  PortSettings(::google::protobuf::Arena* arena, const PortSettings& from);
  PortSettings(::google::protobuf::Arena* arena, PortSettings&& from) noexcept
      : PortSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxConnectionsFieldNumber = 1,
    kListenPortFieldNumber = 2,
    kVideoDataPortFieldNumber = 3,
    kHttpPortFieldNumber = 4,
    kRtspPortFieldNumber = 5,
    kHttpsPortFieldNumber = 6,
  };
  // string max_connections = 1;
  void clear_max_connections() ;
  const std::string& max_connections() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_connections(Arg_&& arg, Args_... args);
  std::string* mutable_max_connections();
  PROTOBUF_NODISCARD std::string* release_max_connections();
  void set_allocated_max_connections(std::string* value);

  private:
  const std::string& _internal_max_connections() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_connections(
      const std::string& value);
  std::string* _internal_mutable_max_connections();

  public:
  // string listen_port = 2;
  void clear_listen_port() ;
  const std::string& listen_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_listen_port(Arg_&& arg, Args_... args);
  std::string* mutable_listen_port();
  PROTOBUF_NODISCARD std::string* release_listen_port();
  void set_allocated_listen_port(std::string* value);

  private:
  const std::string& _internal_listen_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_listen_port(
      const std::string& value);
  std::string* _internal_mutable_listen_port();

  public:
  // string video_data_port = 3;
  void clear_video_data_port() ;
  const std::string& video_data_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_video_data_port(Arg_&& arg, Args_... args);
  std::string* mutable_video_data_port();
  PROTOBUF_NODISCARD std::string* release_video_data_port();
  void set_allocated_video_data_port(std::string* value);

  private:
  const std::string& _internal_video_data_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_data_port(
      const std::string& value);
  std::string* _internal_mutable_video_data_port();

  public:
  // string http_port = 4;
  void clear_http_port() ;
  const std::string& http_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_http_port(Arg_&& arg, Args_... args);
  std::string* mutable_http_port();
  PROTOBUF_NODISCARD std::string* release_http_port();
  void set_allocated_http_port(std::string* value);

  private:
  const std::string& _internal_http_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_http_port(
      const std::string& value);
  std::string* _internal_mutable_http_port();

  public:
  // string rtsp_port = 5;
  void clear_rtsp_port() ;
  const std::string& rtsp_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rtsp_port(Arg_&& arg, Args_... args);
  std::string* mutable_rtsp_port();
  PROTOBUF_NODISCARD std::string* release_rtsp_port();
  void set_allocated_rtsp_port(std::string* value);

  private:
  const std::string& _internal_rtsp_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtsp_port(
      const std::string& value);
  std::string* _internal_mutable_rtsp_port();

  public:
  // string https_port = 6;
  void clear_https_port() ;
  const std::string& https_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_https_port(Arg_&& arg, Args_... args);
  std::string* mutable_https_port();
  PROTOBUF_NODISCARD std::string* release_https_port();
  void set_allocated_https_port(std::string* value);

  private:
  const std::string& _internal_https_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_https_port(
      const std::string& value);
  std::string* _internal_mutable_https_port();

  public:
  // @@protoc_insertion_point(class_scope:PortSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      90, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr max_connections_;
    ::google::protobuf::internal::ArenaStringPtr listen_port_;
    ::google::protobuf::internal::ArenaStringPtr video_data_port_;
    ::google::protobuf::internal::ArenaStringPtr http_port_;
    ::google::protobuf::internal::ArenaStringPtr rtsp_port_;
    ::google::protobuf::internal::ArenaStringPtr https_port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PlatformSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlatformSettings) */ {
 public:
  inline PlatformSettings() : PlatformSettings(nullptr) {}
  ~PlatformSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlatformSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlatformSettings(const PlatformSettings& from) : PlatformSettings(nullptr, from) {}
  inline PlatformSettings(PlatformSettings&& from) noexcept
      : PlatformSettings(nullptr, std::move(from)) {}
  inline PlatformSettings& operator=(const PlatformSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatformSettings& operator=(PlatformSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatformSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatformSettings* internal_default_instance() {
    return reinterpret_cast<const PlatformSettings*>(
        &_PlatformSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(PlatformSettings& a, PlatformSettings& b) { a.Swap(&b); }
  inline void Swap(PlatformSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatformSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatformSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlatformSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlatformSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlatformSettings& from) { PlatformSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlatformSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlatformSettings"; }

 protected:
  explicit PlatformSettings(::google::protobuf::Arena* arena);
  PlatformSettings(::google::protobuf::Arena* arena, const PlatformSettings& from);
  PlatformSettings(::google::protobuf::Arena* arena, PlatformSettings&& from) noexcept
      : PlatformSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ProtocolType = PlatformSettings_ProtocolType;
  static constexpr ProtocolType PROTOCOL_UNKNOWN = PlatformSettings_ProtocolType_PROTOCOL_UNKNOWN;
  static constexpr ProtocolType GB28181 = PlatformSettings_ProtocolType_GB28181;
  static constexpr ProtocolType ONVIF = PlatformSettings_ProtocolType_ONVIF;
  static constexpr ProtocolType OTHER = PlatformSettings_ProtocolType_OTHER;
  static inline bool ProtocolType_IsValid(int value) {
    return PlatformSettings_ProtocolType_IsValid(value);
  }
  static constexpr ProtocolType ProtocolType_MIN = PlatformSettings_ProtocolType_ProtocolType_MIN;
  static constexpr ProtocolType ProtocolType_MAX = PlatformSettings_ProtocolType_ProtocolType_MAX;
  static constexpr int ProtocolType_ARRAYSIZE = PlatformSettings_ProtocolType_ProtocolType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ProtocolType_descriptor() {
    return PlatformSettings_ProtocolType_descriptor();
  }
  template <typename T>
  static inline const std::string& ProtocolType_Name(T value) {
    return PlatformSettings_ProtocolType_Name(value);
  }
  static inline bool ProtocolType_Parse(absl::string_view name, ProtocolType* value) {
    return PlatformSettings_ProtocolType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPlatformIpFieldNumber = 1,
    kPlatformPortFieldNumber = 2,
    kKeyFieldNumber = 4,
    kSecretFieldNumber = 5,
    kProtocolFieldNumber = 3,
  };
  // string platform_ip = 1;
  void clear_platform_ip() ;
  const std::string& platform_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform_ip(Arg_&& arg, Args_... args);
  std::string* mutable_platform_ip();
  PROTOBUF_NODISCARD std::string* release_platform_ip();
  void set_allocated_platform_ip(std::string* value);

  private:
  const std::string& _internal_platform_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_ip(
      const std::string& value);
  std::string* _internal_mutable_platform_ip();

  public:
  // string platform_port = 2;
  void clear_platform_port() ;
  const std::string& platform_port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform_port(Arg_&& arg, Args_... args);
  std::string* mutable_platform_port();
  PROTOBUF_NODISCARD std::string* release_platform_port();
  void set_allocated_platform_port(std::string* value);

  private:
  const std::string& _internal_platform_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_port(
      const std::string& value);
  std::string* _internal_mutable_platform_port();

  public:
  // string key = 4;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string secret = 5;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .PlatformSettings.ProtocolType protocol = 3;
  void clear_protocol() ;
  ::PlatformSettings_ProtocolType protocol() const;
  void set_protocol(::PlatformSettings_ProtocolType value);

  private:
  ::PlatformSettings_ProtocolType _internal_protocol() const;
  void _internal_set_protocol(::PlatformSettings_ProtocolType value);

  public:
  // @@protoc_insertion_point(class_scope:PlatformSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlatformSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlatformSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr platform_ip_;
    ::google::protobuf::internal::ArenaStringPtr platform_port_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    int protocol_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PTZDevice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PTZDevice) */ {
 public:
  inline PTZDevice() : PTZDevice(nullptr) {}
  ~PTZDevice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PTZDevice(
      ::google::protobuf::internal::ConstantInitialized);

  inline PTZDevice(const PTZDevice& from) : PTZDevice(nullptr, from) {}
  inline PTZDevice(PTZDevice&& from) noexcept
      : PTZDevice(nullptr, std::move(from)) {}
  inline PTZDevice& operator=(const PTZDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline PTZDevice& operator=(PTZDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PTZDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const PTZDevice* internal_default_instance() {
    return reinterpret_cast<const PTZDevice*>(
        &_PTZDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(PTZDevice& a, PTZDevice& b) { a.Swap(&b); }
  inline void Swap(PTZDevice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PTZDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PTZDevice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PTZDevice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PTZDevice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PTZDevice& from) { PTZDevice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PTZDevice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PTZDevice"; }

 protected:
  explicit PTZDevice(::google::protobuf::Arena* arena);
  PTZDevice(::google::protobuf::Arena* arena, const PTZDevice& from);
  PTZDevice(::google::protobuf::Arena* arena, PTZDevice&& from) noexcept
      : PTZDevice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DeviceStatus = PTZDevice_DeviceStatus;
  static constexpr DeviceStatus UNKNOWN = PTZDevice_DeviceStatus_UNKNOWN;
  static constexpr DeviceStatus ONLINE = PTZDevice_DeviceStatus_ONLINE;
  static constexpr DeviceStatus OFFLINE = PTZDevice_DeviceStatus_OFFLINE;
  static inline bool DeviceStatus_IsValid(int value) {
    return PTZDevice_DeviceStatus_IsValid(value);
  }
  static constexpr DeviceStatus DeviceStatus_MIN = PTZDevice_DeviceStatus_DeviceStatus_MIN;
  static constexpr DeviceStatus DeviceStatus_MAX = PTZDevice_DeviceStatus_DeviceStatus_MAX;
  static constexpr int DeviceStatus_ARRAYSIZE = PTZDevice_DeviceStatus_DeviceStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DeviceStatus_descriptor() {
    return PTZDevice_DeviceStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& DeviceStatus_Name(T value) {
    return PTZDevice_DeviceStatus_Name(value);
  }
  static inline bool DeviceStatus_Parse(absl::string_view name, DeviceStatus* value) {
    return PTZDevice_DeviceStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kIpAddressFieldNumber = 4,
    kGroupFieldNumber = 5,
    kPortFieldNumber = 3,
    kStatusFieldNumber = 6,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string ip_address = 4;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string group = 5;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* value);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // int32 port = 3;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // .PTZDevice.DeviceStatus status = 6;
  void clear_status() ;
  ::PTZDevice_DeviceStatus status() const;
  void set_status(::PTZDevice_DeviceStatus value);

  private:
  ::PTZDevice_DeviceStatus _internal_status() const;
  void _internal_set_status(::PTZDevice_DeviceStatus value);

  public:
  // @@protoc_insertion_point(class_scope:PTZDevice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PTZDevice_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PTZDevice& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::int32_t port_;
    int status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class OSDSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:OSDSettings) */ {
 public:
  inline OSDSettings() : OSDSettings(nullptr) {}
  ~OSDSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OSDSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline OSDSettings(const OSDSettings& from) : OSDSettings(nullptr, from) {}
  inline OSDSettings(OSDSettings&& from) noexcept
      : OSDSettings(nullptr, std::move(from)) {}
  inline OSDSettings& operator=(const OSDSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline OSDSettings& operator=(OSDSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OSDSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const OSDSettings* internal_default_instance() {
    return reinterpret_cast<const OSDSettings*>(
        &_OSDSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(OSDSettings& a, OSDSettings& b) { a.Swap(&b); }
  inline void Swap(OSDSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OSDSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OSDSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OSDSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OSDSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OSDSettings& from) { OSDSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OSDSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "OSDSettings"; }

 protected:
  explicit OSDSettings(::google::protobuf::Arena* arena);
  OSDSettings(::google::protobuf::Arena* arena, const OSDSettings& from);
  OSDSettings(::google::protobuf::Arena* arena, OSDSettings&& from) noexcept
      : OSDSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Size = OSDSettings_Size;
  static constexpr Size LARGE = OSDSettings_Size_LARGE;
  static constexpr Size MEDIUM = OSDSettings_Size_MEDIUM;
  static constexpr Size SMALL = OSDSettings_Size_SMALL;
  static inline bool Size_IsValid(int value) {
    return OSDSettings_Size_IsValid(value);
  }
  static constexpr Size Size_MIN = OSDSettings_Size_Size_MIN;
  static constexpr Size Size_MAX = OSDSettings_Size_Size_MAX;
  static constexpr int Size_ARRAYSIZE = OSDSettings_Size_Size_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Size_descriptor() {
    return OSDSettings_Size_descriptor();
  }
  template <typename T>
  static inline const std::string& Size_Name(T value) {
    return OSDSettings_Size_Name(value);
  }
  static inline bool Size_Parse(absl::string_view name, Size* value) {
    return OSDSettings_Size_Parse(name, value);
  }
  using Color = OSDSettings_Color;
  static constexpr Color AUTO = OSDSettings_Color_AUTO;
  static constexpr Color WHITE = OSDSettings_Color_WHITE;
  static constexpr Color BLACK = OSDSettings_Color_BLACK;
  static inline bool Color_IsValid(int value) {
    return OSDSettings_Color_IsValid(value);
  }
  static constexpr Color Color_MIN = OSDSettings_Color_Color_MIN;
  static constexpr Color Color_MAX = OSDSettings_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE = OSDSettings_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Color_descriptor() {
    return OSDSettings_Color_descriptor();
  }
  template <typename T>
  static inline const std::string& Color_Name(T value) {
    return OSDSettings_Color_Name(value);
  }
  static inline bool Color_Parse(absl::string_view name, Color* value) {
    return OSDSettings_Color_Parse(name, value);
  }
  using Alignment = OSDSettings_Alignment;
  static constexpr Alignment LEFT = OSDSettings_Alignment_LEFT;
  static constexpr Alignment CENTER = OSDSettings_Alignment_CENTER;
  static constexpr Alignment RIGHT = OSDSettings_Alignment_RIGHT;
  static inline bool Alignment_IsValid(int value) {
    return OSDSettings_Alignment_IsValid(value);
  }
  static constexpr Alignment Alignment_MIN = OSDSettings_Alignment_Alignment_MIN;
  static constexpr Alignment Alignment_MAX = OSDSettings_Alignment_Alignment_MAX;
  static constexpr int Alignment_ARRAYSIZE = OSDSettings_Alignment_Alignment_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Alignment_descriptor() {
    return OSDSettings_Alignment_descriptor();
  }
  template <typename T>
  static inline const std::string& Alignment_Name(T value) {
    return OSDSettings_Alignment_Name(value);
  }
  static inline bool Alignment_Parse(absl::string_view name, Alignment* value) {
    return OSDSettings_Alignment_Parse(name, value);
  }
  using TimeFormat = OSDSettings_TimeFormat;
  static constexpr TimeFormat TWENTY_FOUR_HOUR = OSDSettings_TimeFormat_TWENTY_FOUR_HOUR;
  static constexpr TimeFormat TWELVE_HOUR = OSDSettings_TimeFormat_TWELVE_HOUR;
  static inline bool TimeFormat_IsValid(int value) {
    return OSDSettings_TimeFormat_IsValid(value);
  }
  static constexpr TimeFormat TimeFormat_MIN = OSDSettings_TimeFormat_TimeFormat_MIN;
  static constexpr TimeFormat TimeFormat_MAX = OSDSettings_TimeFormat_TimeFormat_MAX;
  static constexpr int TimeFormat_ARRAYSIZE = OSDSettings_TimeFormat_TimeFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TimeFormat_descriptor() {
    return OSDSettings_TimeFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& TimeFormat_Name(T value) {
    return OSDSettings_TimeFormat_Name(value);
  }
  static inline bool TimeFormat_Parse(absl::string_view name, TimeFormat* value) {
    return OSDSettings_TimeFormat_Parse(name, value);
  }
  using DateFormat = OSDSettings_DateFormat;
  static constexpr DateFormat YEAR_MONTH_DAY = OSDSettings_DateFormat_YEAR_MONTH_DAY;
  static constexpr DateFormat MONTH_DAY_YEAR = OSDSettings_DateFormat_MONTH_DAY_YEAR;
  static constexpr DateFormat DAY_MONTH_YEAR = OSDSettings_DateFormat_DAY_MONTH_YEAR;
  static inline bool DateFormat_IsValid(int value) {
    return OSDSettings_DateFormat_IsValid(value);
  }
  static constexpr DateFormat DateFormat_MIN = OSDSettings_DateFormat_DateFormat_MIN;
  static constexpr DateFormat DateFormat_MAX = OSDSettings_DateFormat_DateFormat_MAX;
  static constexpr int DateFormat_ARRAYSIZE = OSDSettings_DateFormat_DateFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DateFormat_descriptor() {
    return OSDSettings_DateFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& DateFormat_Name(T value) {
    return OSDSettings_DateFormat_Name(value);
  }
  static inline bool DateFormat_Parse(absl::string_view name, DateFormat* value) {
    return OSDSettings_DateFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kEnabledFieldNumber = 1,
    kTimeEnabledFieldNumber = 3,
    kShowWeekdayFieldNumber = 4,
    kPresetEnabledFieldNumber = 7,
    kTimeFormatFieldNumber = 5,
    kDateFormatFieldNumber = 6,
    kZoomEnabledFieldNumber = 8,
    kCruiseEnabledFieldNumber = 9,
    kTrackingEnabledFieldNumber = 10,
    kScanEnabledFieldNumber = 11,
    kSizeFieldNumber = 12,
    kColorFieldNumber = 13,
    kAlignmentFieldNumber = 14,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // bool time_enabled = 3;
  void clear_time_enabled() ;
  bool time_enabled() const;
  void set_time_enabled(bool value);

  private:
  bool _internal_time_enabled() const;
  void _internal_set_time_enabled(bool value);

  public:
  // bool show_weekday = 4;
  void clear_show_weekday() ;
  bool show_weekday() const;
  void set_show_weekday(bool value);

  private:
  bool _internal_show_weekday() const;
  void _internal_set_show_weekday(bool value);

  public:
  // bool preset_enabled = 7;
  void clear_preset_enabled() ;
  bool preset_enabled() const;
  void set_preset_enabled(bool value);

  private:
  bool _internal_preset_enabled() const;
  void _internal_set_preset_enabled(bool value);

  public:
  // .OSDSettings.TimeFormat time_format = 5;
  void clear_time_format() ;
  ::OSDSettings_TimeFormat time_format() const;
  void set_time_format(::OSDSettings_TimeFormat value);

  private:
  ::OSDSettings_TimeFormat _internal_time_format() const;
  void _internal_set_time_format(::OSDSettings_TimeFormat value);

  public:
  // .OSDSettings.DateFormat date_format = 6;
  void clear_date_format() ;
  ::OSDSettings_DateFormat date_format() const;
  void set_date_format(::OSDSettings_DateFormat value);

  private:
  ::OSDSettings_DateFormat _internal_date_format() const;
  void _internal_set_date_format(::OSDSettings_DateFormat value);

  public:
  // bool zoom_enabled = 8;
  void clear_zoom_enabled() ;
  bool zoom_enabled() const;
  void set_zoom_enabled(bool value);

  private:
  bool _internal_zoom_enabled() const;
  void _internal_set_zoom_enabled(bool value);

  public:
  // bool cruise_enabled = 9;
  void clear_cruise_enabled() ;
  bool cruise_enabled() const;
  void set_cruise_enabled(bool value);

  private:
  bool _internal_cruise_enabled() const;
  void _internal_set_cruise_enabled(bool value);

  public:
  // bool tracking_enabled = 10;
  void clear_tracking_enabled() ;
  bool tracking_enabled() const;
  void set_tracking_enabled(bool value);

  private:
  bool _internal_tracking_enabled() const;
  void _internal_set_tracking_enabled(bool value);

  public:
  // bool scan_enabled = 11;
  void clear_scan_enabled() ;
  bool scan_enabled() const;
  void set_scan_enabled(bool value);

  private:
  bool _internal_scan_enabled() const;
  void _internal_set_scan_enabled(bool value);

  public:
  // .OSDSettings.Size size = 12;
  void clear_size() ;
  ::OSDSettings_Size size() const;
  void set_size(::OSDSettings_Size value);

  private:
  ::OSDSettings_Size _internal_size() const;
  void _internal_set_size(::OSDSettings_Size value);

  public:
  // .OSDSettings.Color color = 13;
  void clear_color() ;
  ::OSDSettings_Color color() const;
  void set_color(::OSDSettings_Color value);

  private:
  ::OSDSettings_Color _internal_color() const;
  void _internal_set_color(::OSDSettings_Color value);

  public:
  // .OSDSettings.Alignment alignment = 14;
  void clear_alignment() ;
  ::OSDSettings_Alignment alignment() const;
  void set_alignment(::OSDSettings_Alignment value);

  private:
  ::OSDSettings_Alignment _internal_alignment() const;
  void _internal_set_alignment(::OSDSettings_Alignment value);

  public:
  // @@protoc_insertion_point(class_scope:OSDSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      32, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OSDSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OSDSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool enabled_;
    bool time_enabled_;
    bool show_weekday_;
    bool preset_enabled_;
    int time_format_;
    int date_format_;
    bool zoom_enabled_;
    bool cruise_enabled_;
    bool tracking_enabled_;
    bool scan_enabled_;
    int size_;
    int color_;
    int alignment_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class NoiseReduction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NoiseReduction) */ {
 public:
  inline NoiseReduction() : NoiseReduction(nullptr) {}
  ~NoiseReduction() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoiseReduction(
      ::google::protobuf::internal::ConstantInitialized);

  inline NoiseReduction(const NoiseReduction& from) : NoiseReduction(nullptr, from) {}
  inline NoiseReduction(NoiseReduction&& from) noexcept
      : NoiseReduction(nullptr, std::move(from)) {}
  inline NoiseReduction& operator=(const NoiseReduction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoiseReduction& operator=(NoiseReduction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoiseReduction& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoiseReduction* internal_default_instance() {
    return reinterpret_cast<const NoiseReduction*>(
        &_NoiseReduction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(NoiseReduction& a, NoiseReduction& b) { a.Swap(&b); }
  inline void Swap(NoiseReduction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoiseReduction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoiseReduction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NoiseReduction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoiseReduction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NoiseReduction& from) { NoiseReduction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoiseReduction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NoiseReduction"; }

 protected:
  explicit NoiseReduction(::google::protobuf::Arena* arena);
  NoiseReduction(::google::protobuf::Arena* arena, const NoiseReduction& from);
  NoiseReduction(::google::protobuf::Arena* arena, NoiseReduction&& from) noexcept
      : NoiseReduction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnabledFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // int32 level = 2;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NoiseReduction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NoiseReduction_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NoiseReduction& from_msg);
    bool enabled_;
    ::int32_t level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class MediaSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MediaSettings) */ {
 public:
  inline MediaSettings() : MediaSettings(nullptr) {}
  ~MediaSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MediaSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline MediaSettings(const MediaSettings& from) : MediaSettings(nullptr, from) {}
  inline MediaSettings(MediaSettings&& from) noexcept
      : MediaSettings(nullptr, std::move(from)) {}
  inline MediaSettings& operator=(const MediaSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaSettings& operator=(MediaSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaSettings* internal_default_instance() {
    return reinterpret_cast<const MediaSettings*>(
        &_MediaSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(MediaSettings& a, MediaSettings& b) { a.Swap(&b); }
  inline void Swap(MediaSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MediaSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MediaSettings& from) { MediaSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MediaSettings"; }

 protected:
  explicit MediaSettings(::google::protobuf::Arena* arena);
  MediaSettings(::google::protobuf::Arena* arena, const MediaSettings& from);
  MediaSettings(::google::protobuf::Arena* arena, MediaSettings&& from) noexcept
      : MediaSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStreamTypeFieldNumber = 1,
    kVideoStreamTypeFieldNumber = 2,
    kResolutionFieldNumber = 3,
    kBitrateTypeFieldNumber = 4,
    kBitrateFieldNumber = 5,
    kFrameRateFieldNumber = 6,
    kEncodingModeFieldNumber = 7,
    kIframeIntervalFieldNumber = 8,
    kAudioInputFieldNumber = 11,
    kAuxiliaryStreamEnabledFieldNumber = 9,
    kNoiseReductionEnabledFieldNumber = 13,
    kSamplingRateFieldNumber = 12,
    kMicrophoneVolumeFieldNumber = 14,
    kSpeakerVolumeFieldNumber = 15,
  };
  // .StreamType stream_type = 1;
  void clear_stream_type() ;
  ::StreamType stream_type() const;
  void set_stream_type(::StreamType value);

  private:
  ::StreamType _internal_stream_type() const;
  void _internal_set_stream_type(::StreamType value);

  public:
  // .VideoStreamType video_stream_type = 2;
  void clear_video_stream_type() ;
  ::VideoStreamType video_stream_type() const;
  void set_video_stream_type(::VideoStreamType value);

  private:
  ::VideoStreamType _internal_video_stream_type() const;
  void _internal_set_video_stream_type(::VideoStreamType value);

  public:
  // .Resolution resolution = 3;
  void clear_resolution() ;
  ::Resolution resolution() const;
  void set_resolution(::Resolution value);

  private:
  ::Resolution _internal_resolution() const;
  void _internal_set_resolution(::Resolution value);

  public:
  // .BitrateType bitrate_type = 4;
  void clear_bitrate_type() ;
  ::BitrateType bitrate_type() const;
  void set_bitrate_type(::BitrateType value);

  private:
  ::BitrateType _internal_bitrate_type() const;
  void _internal_set_bitrate_type(::BitrateType value);

  public:
  // int32 bitrate = 5;
  void clear_bitrate() ;
  ::int32_t bitrate() const;
  void set_bitrate(::int32_t value);

  private:
  ::int32_t _internal_bitrate() const;
  void _internal_set_bitrate(::int32_t value);

  public:
  // .FrameRate frame_rate = 6;
  void clear_frame_rate() ;
  ::FrameRate frame_rate() const;
  void set_frame_rate(::FrameRate value);

  private:
  ::FrameRate _internal_frame_rate() const;
  void _internal_set_frame_rate(::FrameRate value);

  public:
  // .VideoCodec encoding_mode = 7;
  void clear_encoding_mode() ;
  ::VideoCodec encoding_mode() const;
  void set_encoding_mode(::VideoCodec value);

  private:
  ::VideoCodec _internal_encoding_mode() const;
  void _internal_set_encoding_mode(::VideoCodec value);

  public:
  // int32 iframe_interval = 8;
  void clear_iframe_interval() ;
  ::int32_t iframe_interval() const;
  void set_iframe_interval(::int32_t value);

  private:
  ::int32_t _internal_iframe_interval() const;
  void _internal_set_iframe_interval(::int32_t value);

  public:
  // .AudioSource audio_input = 11;
  void clear_audio_input() ;
  ::AudioSource audio_input() const;
  void set_audio_input(::AudioSource value);

  private:
  ::AudioSource _internal_audio_input() const;
  void _internal_set_audio_input(::AudioSource value);

  public:
  // bool auxiliary_stream_enabled = 9;
  void clear_auxiliary_stream_enabled() ;
  bool auxiliary_stream_enabled() const;
  void set_auxiliary_stream_enabled(bool value);

  private:
  bool _internal_auxiliary_stream_enabled() const;
  void _internal_set_auxiliary_stream_enabled(bool value);

  public:
  // bool noise_reduction_enabled = 13;
  void clear_noise_reduction_enabled() ;
  bool noise_reduction_enabled() const;
  void set_noise_reduction_enabled(bool value);

  private:
  bool _internal_noise_reduction_enabled() const;
  void _internal_set_noise_reduction_enabled(bool value);

  public:
  // int32 sampling_rate = 12;
  void clear_sampling_rate() ;
  ::int32_t sampling_rate() const;
  void set_sampling_rate(::int32_t value);

  private:
  ::int32_t _internal_sampling_rate() const;
  void _internal_set_sampling_rate(::int32_t value);

  public:
  // int32 microphone_volume = 14;
  void clear_microphone_volume() ;
  ::int32_t microphone_volume() const;
  void set_microphone_volume(::int32_t value);

  private:
  ::int32_t _internal_microphone_volume() const;
  void _internal_set_microphone_volume(::int32_t value);

  public:
  // int32 speaker_volume = 15;
  void clear_speaker_volume() ;
  ::int32_t speaker_volume() const;
  void set_speaker_volume(::int32_t value);

  private:
  ::int32_t _internal_speaker_volume() const;
  void _internal_set_speaker_volume(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MediaSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MediaSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MediaSettings& from_msg);
    int stream_type_;
    int video_stream_type_;
    int resolution_;
    int bitrate_type_;
    ::int32_t bitrate_;
    int frame_rate_;
    int encoding_mode_;
    ::int32_t iframe_interval_;
    int audio_input_;
    bool auxiliary_stream_enabled_;
    bool noise_reduction_enabled_;
    ::int32_t sampling_rate_;
    ::int32_t microphone_volume_;
    ::int32_t speaker_volume_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class LoginSecuritySettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LoginSecuritySettings) */ {
 public:
  inline LoginSecuritySettings() : LoginSecuritySettings(nullptr) {}
  ~LoginSecuritySettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginSecuritySettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginSecuritySettings(const LoginSecuritySettings& from) : LoginSecuritySettings(nullptr, from) {}
  inline LoginSecuritySettings(LoginSecuritySettings&& from) noexcept
      : LoginSecuritySettings(nullptr, std::move(from)) {}
  inline LoginSecuritySettings& operator=(const LoginSecuritySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSecuritySettings& operator=(LoginSecuritySettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginSecuritySettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginSecuritySettings* internal_default_instance() {
    return reinterpret_cast<const LoginSecuritySettings*>(
        &_LoginSecuritySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(LoginSecuritySettings& a, LoginSecuritySettings& b) { a.Swap(&b); }
  inline void Swap(LoginSecuritySettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginSecuritySettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginSecuritySettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoginSecuritySettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginSecuritySettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginSecuritySettings& from) { LoginSecuritySettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginSecuritySettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LoginSecuritySettings"; }

 protected:
  explicit LoginSecuritySettings(::google::protobuf::Arena* arena);
  LoginSecuritySettings(::google::protobuf::Arena* arena, const LoginSecuritySettings& from);
  LoginSecuritySettings(::google::protobuf::Arena* arena, LoginSecuritySettings&& from) noexcept
      : LoginSecuritySettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxFailedAttemptsFieldNumber = 1,
    kLockoutDurationFieldNumber = 2,
  };
  // int32 max_failed_attempts = 1;
  void clear_max_failed_attempts() ;
  ::int32_t max_failed_attempts() const;
  void set_max_failed_attempts(::int32_t value);

  private:
  ::int32_t _internal_max_failed_attempts() const;
  void _internal_set_max_failed_attempts(::int32_t value);

  public:
  // int32 lockout_duration = 2;
  void clear_lockout_duration() ;
  ::int32_t lockout_duration() const;
  void set_lockout_duration(::int32_t value);

  private:
  ::int32_t _internal_lockout_duration() const;
  void _internal_set_lockout_duration(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:LoginSecuritySettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoginSecuritySettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginSecuritySettings& from_msg);
    ::int32_t max_failed_attempts_;
    ::int32_t lockout_duration_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LogEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline LogEntry(const LogEntry& from) : LogEntry(nullptr, from) {}
  inline LogEntry(LogEntry&& from) noexcept
      : LogEntry(nullptr, std::move(from)) {}
  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
        &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(LogEntry& a, LogEntry& b) { a.Swap(&b); }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LogEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LogEntry& from) { LogEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LogEntry"; }

 protected:
  explicit LogEntry(::google::protobuf::Arena* arena);
  LogEntry(::google::protobuf::Arena* arena, const LogEntry& from);
  LogEntry(::google::protobuf::Arena* arena, LogEntry&& from) noexcept
      : LogEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LogType = LogEntry_LogType;
  static constexpr LogType OPERATION_LOG = LogEntry_LogType_OPERATION_LOG;
  static constexpr LogType QUERY_LOG = LogEntry_LogType_QUERY_LOG;
  static inline bool LogType_IsValid(int value) {
    return LogEntry_LogType_IsValid(value);
  }
  static constexpr LogType LogType_MIN = LogEntry_LogType_LogType_MIN;
  static constexpr LogType LogType_MAX = LogEntry_LogType_LogType_MAX;
  static constexpr int LogType_ARRAYSIZE = LogEntry_LogType_LogType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LogType_descriptor() {
    return LogEntry_LogType_descriptor();
  }
  template <typename T>
  static inline const std::string& LogType_Name(T value) {
    return LogEntry_LogType_Name(value);
  }
  static inline bool LogType_Parse(absl::string_view name, LogType* value) {
    return LogEntry_LogType_Parse(name, value);
  }
  using AccountType = LogEntry_AccountType;
  static constexpr AccountType SUPER_ADMIN = LogEntry_AccountType_SUPER_ADMIN;
  static constexpr AccountType ADMIN = LogEntry_AccountType_ADMIN;
  static constexpr AccountType CUSTOMER = LogEntry_AccountType_CUSTOMER;
  static inline bool AccountType_IsValid(int value) {
    return LogEntry_AccountType_IsValid(value);
  }
  static constexpr AccountType AccountType_MIN = LogEntry_AccountType_AccountType_MIN;
  static constexpr AccountType AccountType_MAX = LogEntry_AccountType_AccountType_MAX;
  static constexpr int AccountType_ARRAYSIZE = LogEntry_AccountType_AccountType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AccountType_descriptor() {
    return LogEntry_AccountType_descriptor();
  }
  template <typename T>
  static inline const std::string& AccountType_Name(T value) {
    return LogEntry_AccountType_Name(value);
  }
  static inline bool AccountType_Parse(absl::string_view name, AccountType* value) {
    return LogEntry_AccountType_Parse(name, value);
  }
  using OperationResult = LogEntry_OperationResult;
  static constexpr OperationResult SUCCESS = LogEntry_OperationResult_SUCCESS;
  static constexpr OperationResult FAILURE = LogEntry_OperationResult_FAILURE;
  static inline bool OperationResult_IsValid(int value) {
    return LogEntry_OperationResult_IsValid(value);
  }
  static constexpr OperationResult OperationResult_MIN = LogEntry_OperationResult_OperationResult_MIN;
  static constexpr OperationResult OperationResult_MAX = LogEntry_OperationResult_OperationResult_MAX;
  static constexpr int OperationResult_ARRAYSIZE = LogEntry_OperationResult_OperationResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationResult_descriptor() {
    return LogEntry_OperationResult_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationResult_Name(T value) {
    return LogEntry_OperationResult_Name(value);
  }
  static inline bool OperationResult_Parse(absl::string_view name, OperationResult* value) {
    return LogEntry_OperationResult_Parse(name, value);
  }
  using OperationType = LogEntry_OperationType;
  static constexpr OperationType INFO_QUERY = LogEntry_OperationType_INFO_QUERY;
  static constexpr OperationType PARAM_CONFIG = LogEntry_OperationType_PARAM_CONFIG;
  static constexpr OperationType ACCOUNT_MODIFY = LogEntry_OperationType_ACCOUNT_MODIFY;
  static constexpr OperationType ACCOUNT_DELETE = LogEntry_OperationType_ACCOUNT_DELETE;
  static constexpr OperationType ACCOUNT_ADD = LogEntry_OperationType_ACCOUNT_ADD;
  static constexpr OperationType FACTORY_RESET = LogEntry_OperationType_FACTORY_RESET;
  static constexpr OperationType SYSTEM_UPGRADE = LogEntry_OperationType_SYSTEM_UPGRADE;
  static inline bool OperationType_IsValid(int value) {
    return LogEntry_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = LogEntry_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = LogEntry_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = LogEntry_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return LogEntry_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return LogEntry_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return LogEntry_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOperationDatetimeFieldNumber = 3,
    kRequestIpFieldNumber = 4,
    kLogTypeFieldNumber = 1,
    kAccountTypeFieldNumber = 2,
    kOperationTypeFieldNumber = 5,
    kOperationResultFieldNumber = 6,
  };
  // string operation_datetime = 3;
  void clear_operation_datetime() ;
  const std::string& operation_datetime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_datetime(Arg_&& arg, Args_... args);
  std::string* mutable_operation_datetime();
  PROTOBUF_NODISCARD std::string* release_operation_datetime();
  void set_allocated_operation_datetime(std::string* value);

  private:
  const std::string& _internal_operation_datetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_datetime(
      const std::string& value);
  std::string* _internal_mutable_operation_datetime();

  public:
  // string request_ip = 4;
  void clear_request_ip() ;
  const std::string& request_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_ip(Arg_&& arg, Args_... args);
  std::string* mutable_request_ip();
  PROTOBUF_NODISCARD std::string* release_request_ip();
  void set_allocated_request_ip(std::string* value);

  private:
  const std::string& _internal_request_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_ip(
      const std::string& value);
  std::string* _internal_mutable_request_ip();

  public:
  // .LogEntry.LogType log_type = 1;
  void clear_log_type() ;
  ::LogEntry_LogType log_type() const;
  void set_log_type(::LogEntry_LogType value);

  private:
  ::LogEntry_LogType _internal_log_type() const;
  void _internal_set_log_type(::LogEntry_LogType value);

  public:
  // .LogEntry.AccountType account_type = 2;
  void clear_account_type() ;
  ::LogEntry_AccountType account_type() const;
  void set_account_type(::LogEntry_AccountType value);

  private:
  ::LogEntry_AccountType _internal_account_type() const;
  void _internal_set_account_type(::LogEntry_AccountType value);

  public:
  // .LogEntry.OperationType operation_type = 5;
  void clear_operation_type() ;
  ::LogEntry_OperationType operation_type() const;
  void set_operation_type(::LogEntry_OperationType value);

  private:
  ::LogEntry_OperationType _internal_operation_type() const;
  void _internal_set_operation_type(::LogEntry_OperationType value);

  public:
  // .LogEntry.OperationResult operation_result = 6;
  void clear_operation_result() ;
  ::LogEntry_OperationResult operation_result() const;
  void set_operation_result(::LogEntry_OperationResult value);

  private:
  ::LogEntry_OperationResult _internal_operation_result() const;
  void _internal_set_operation_result(::LogEntry_OperationResult value);

  public:
  // @@protoc_insertion_point(class_scope:LogEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LogEntry_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LogEntry& from_msg);
    ::google::protobuf::internal::ArenaStringPtr operation_datetime_;
    ::google::protobuf::internal::ArenaStringPtr request_ip_;
    int log_type_;
    int account_type_;
    int operation_type_;
    int operation_result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class LinearScanSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LinearScanSettings) */ {
 public:
  inline LinearScanSettings() : LinearScanSettings(nullptr) {}
  ~LinearScanSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearScanSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline LinearScanSettings(const LinearScanSettings& from) : LinearScanSettings(nullptr, from) {}
  inline LinearScanSettings(LinearScanSettings&& from) noexcept
      : LinearScanSettings(nullptr, std::move(from)) {}
  inline LinearScanSettings& operator=(const LinearScanSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearScanSettings& operator=(LinearScanSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearScanSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearScanSettings* internal_default_instance() {
    return reinterpret_cast<const LinearScanSettings*>(
        &_LinearScanSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(LinearScanSettings& a, LinearScanSettings& b) { a.Swap(&b); }
  inline void Swap(LinearScanSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearScanSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearScanSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LinearScanSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearScanSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearScanSettings& from) { LinearScanSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LinearScanSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LinearScanSettings"; }

 protected:
  explicit LinearScanSettings(::google::protobuf::Arena* arena);
  LinearScanSettings(::google::protobuf::Arena* arena, const LinearScanSettings& from);
  LinearScanSettings(::google::protobuf::Arena* arena, LinearScanSettings&& from) noexcept
      : LinearScanSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScanIdFieldNumber = 1,
    kScanSpeedFieldNumber = 2,
    kLeftPauseTimeFieldNumber = 3,
    kRightPauseTimeFieldNumber = 4,
    kLeftBoundaryFieldNumber = 5,
    kRightBoundaryFieldNumber = 6,
  };
  // int32 scan_id = 1;
  void clear_scan_id() ;
  ::int32_t scan_id() const;
  void set_scan_id(::int32_t value);

  private:
  ::int32_t _internal_scan_id() const;
  void _internal_set_scan_id(::int32_t value);

  public:
  // int32 scan_speed = 2;
  void clear_scan_speed() ;
  ::int32_t scan_speed() const;
  void set_scan_speed(::int32_t value);

  private:
  ::int32_t _internal_scan_speed() const;
  void _internal_set_scan_speed(::int32_t value);

  public:
  // int32 left_pause_time = 3;
  void clear_left_pause_time() ;
  ::int32_t left_pause_time() const;
  void set_left_pause_time(::int32_t value);

  private:
  ::int32_t _internal_left_pause_time() const;
  void _internal_set_left_pause_time(::int32_t value);

  public:
  // int32 right_pause_time = 4;
  void clear_right_pause_time() ;
  ::int32_t right_pause_time() const;
  void set_right_pause_time(::int32_t value);

  private:
  ::int32_t _internal_right_pause_time() const;
  void _internal_set_right_pause_time(::int32_t value);

  public:
  // int32 left_boundary = 5;
  void clear_left_boundary() ;
  ::int32_t left_boundary() const;
  void set_left_boundary(::int32_t value);

  private:
  ::int32_t _internal_left_boundary() const;
  void _internal_set_left_boundary(::int32_t value);

  public:
  // int32 right_boundary = 6;
  void clear_right_boundary() ;
  ::int32_t right_boundary() const;
  void set_right_boundary(::int32_t value);

  private:
  ::int32_t _internal_right_boundary() const;
  void _internal_set_right_boundary(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:LinearScanSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LinearScanSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LinearScanSettings& from_msg);
    ::int32_t scan_id_;
    ::int32_t scan_speed_;
    ::int32_t left_pause_time_;
    ::int32_t right_pause_time_;
    ::int32_t left_boundary_;
    ::int32_t right_boundary_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class LinearScanControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LinearScanControl) */ {
 public:
  inline LinearScanControl() : LinearScanControl(nullptr) {}
  ~LinearScanControl() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearScanControl(
      ::google::protobuf::internal::ConstantInitialized);

  inline LinearScanControl(const LinearScanControl& from) : LinearScanControl(nullptr, from) {}
  inline LinearScanControl(LinearScanControl&& from) noexcept
      : LinearScanControl(nullptr, std::move(from)) {}
  inline LinearScanControl& operator=(const LinearScanControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearScanControl& operator=(LinearScanControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearScanControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearScanControl* internal_default_instance() {
    return reinterpret_cast<const LinearScanControl*>(
        &_LinearScanControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(LinearScanControl& a, LinearScanControl& b) { a.Swap(&b); }
  inline void Swap(LinearScanControl* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearScanControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearScanControl* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LinearScanControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearScanControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearScanControl& from) { LinearScanControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LinearScanControl* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LinearScanControl"; }

 protected:
  explicit LinearScanControl(::google::protobuf::Arena* arena);
  LinearScanControl(::google::protobuf::Arena* arena, const LinearScanControl& from);
  LinearScanControl(::google::protobuf::Arena* arena, LinearScanControl&& from) noexcept
      : LinearScanControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScanIdFieldNumber = 1,
    kStartFieldNumber = 2,
  };
  // int32 scan_id = 1;
  void clear_scan_id() ;
  ::int32_t scan_id() const;
  void set_scan_id(::int32_t value);

  private:
  ::int32_t _internal_scan_id() const;
  void _internal_set_scan_id(::int32_t value);

  public:
  // bool start = 2;
  void clear_start() ;
  bool start() const;
  void set_start(bool value);

  private:
  bool _internal_start() const;
  void _internal_set_start(bool value);

  public:
  // @@protoc_insertion_point(class_scope:LinearScanControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LinearScanControl_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LinearScanControl& from_msg);
    ::int32_t scan_id_;
    bool start_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class LensControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LensControl) */ {
 public:
  inline LensControl() : LensControl(nullptr) {}
  ~LensControl() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LensControl(
      ::google::protobuf::internal::ConstantInitialized);

  inline LensControl(const LensControl& from) : LensControl(nullptr, from) {}
  inline LensControl(LensControl&& from) noexcept
      : LensControl(nullptr, std::move(from)) {}
  inline LensControl& operator=(const LensControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline LensControl& operator=(LensControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LensControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const LensControl* internal_default_instance() {
    return reinterpret_cast<const LensControl*>(
        &_LensControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(LensControl& a, LensControl& b) { a.Swap(&b); }
  inline void Swap(LensControl* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LensControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LensControl* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LensControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LensControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LensControl& from) { LensControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LensControl* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LensControl"; }

 protected:
  explicit LensControl(::google::protobuf::Arena* arena);
  LensControl(::google::protobuf::Arena* arena, const LensControl& from);
  LensControl(::google::protobuf::Arena* arena, LensControl&& from) noexcept
      : LensControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kZoomLevelFieldNumber = 1,
    kFocusFieldNumber = 2,
    kApertureFieldNumber = 3,
  };
  // float zoom_level = 1;
  void clear_zoom_level() ;
  float zoom_level() const;
  void set_zoom_level(float value);

  private:
  float _internal_zoom_level() const;
  void _internal_set_zoom_level(float value);

  public:
  // float focus = 2;
  void clear_focus() ;
  float focus() const;
  void set_focus(float value);

  private:
  float _internal_focus() const;
  void _internal_set_focus(float value);

  public:
  // float aperture = 3;
  void clear_aperture() ;
  float aperture() const;
  void set_aperture(float value);

  private:
  float _internal_aperture() const;
  void _internal_set_aperture(float value);

  public:
  // @@protoc_insertion_point(class_scope:LensControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LensControl_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LensControl& from_msg);
    float zoom_level_;
    float focus_;
    float aperture_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class InfraredImageSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InfraredImageSettings) */ {
 public:
  inline InfraredImageSettings() : InfraredImageSettings(nullptr) {}
  ~InfraredImageSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InfraredImageSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline InfraredImageSettings(const InfraredImageSettings& from) : InfraredImageSettings(nullptr, from) {}
  inline InfraredImageSettings(InfraredImageSettings&& from) noexcept
      : InfraredImageSettings(nullptr, std::move(from)) {}
  inline InfraredImageSettings& operator=(const InfraredImageSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfraredImageSettings& operator=(InfraredImageSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfraredImageSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfraredImageSettings* internal_default_instance() {
    return reinterpret_cast<const InfraredImageSettings*>(
        &_InfraredImageSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(InfraredImageSettings& a, InfraredImageSettings& b) { a.Swap(&b); }
  inline void Swap(InfraredImageSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfraredImageSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfraredImageSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InfraredImageSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfraredImageSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InfraredImageSettings& from) { InfraredImageSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InfraredImageSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InfraredImageSettings"; }

 protected:
  explicit InfraredImageSettings(::google::protobuf::Arena* arena);
  InfraredImageSettings(::google::protobuf::Arena* arena, const InfraredImageSettings& from);
  InfraredImageSettings(::google::protobuf::Arena* arena, InfraredImageSettings&& from) noexcept
      : InfraredImageSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBrightnessFieldNumber = 1,
    kContrastFieldNumber = 2,
    kDenoiseFieldNumber = 3,
    kIntensityFieldNumber = 4,
    kDetailEnhancementFieldNumber = 5,
    kEdgeEnhancementFieldNumber = 6,
    kStripeFilterFieldNumber = 7,
  };
  // int32 brightness = 1;
  void clear_brightness() ;
  ::int32_t brightness() const;
  void set_brightness(::int32_t value);

  private:
  ::int32_t _internal_brightness() const;
  void _internal_set_brightness(::int32_t value);

  public:
  // int32 contrast = 2;
  void clear_contrast() ;
  ::int32_t contrast() const;
  void set_contrast(::int32_t value);

  private:
  ::int32_t _internal_contrast() const;
  void _internal_set_contrast(::int32_t value);

  public:
  // int32 denoise = 3;
  void clear_denoise() ;
  ::int32_t denoise() const;
  void set_denoise(::int32_t value);

  private:
  ::int32_t _internal_denoise() const;
  void _internal_set_denoise(::int32_t value);

  public:
  // int32 intensity = 4;
  void clear_intensity() ;
  ::int32_t intensity() const;
  void set_intensity(::int32_t value);

  private:
  ::int32_t _internal_intensity() const;
  void _internal_set_intensity(::int32_t value);

  public:
  // bool detail_enhancement = 5;
  void clear_detail_enhancement() ;
  bool detail_enhancement() const;
  void set_detail_enhancement(bool value);

  private:
  bool _internal_detail_enhancement() const;
  void _internal_set_detail_enhancement(bool value);

  public:
  // bool edge_enhancement = 6;
  void clear_edge_enhancement() ;
  bool edge_enhancement() const;
  void set_edge_enhancement(bool value);

  private:
  bool _internal_edge_enhancement() const;
  void _internal_set_edge_enhancement(bool value);

  public:
  // bool stripe_filter = 7;
  void clear_stripe_filter() ;
  bool stripe_filter() const;
  void set_stripe_filter(bool value);

  private:
  bool _internal_stripe_filter() const;
  void _internal_set_stripe_filter(bool value);

  public:
  // @@protoc_insertion_point(class_scope:InfraredImageSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InfraredImageSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InfraredImageSettings& from_msg);
    ::int32_t brightness_;
    ::int32_t contrast_;
    ::int32_t denoise_;
    ::int32_t intensity_;
    bool detail_enhancement_;
    bool edge_enhancement_;
    bool stripe_filter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class ImageSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ImageSettings) */ {
 public:
  inline ImageSettings() : ImageSettings(nullptr) {}
  ~ImageSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImageSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImageSettings(const ImageSettings& from) : ImageSettings(nullptr, from) {}
  inline ImageSettings(ImageSettings&& from) noexcept
      : ImageSettings(nullptr, std::move(from)) {}
  inline ImageSettings& operator=(const ImageSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSettings& operator=(ImageSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageSettings* internal_default_instance() {
    return reinterpret_cast<const ImageSettings*>(
        &_ImageSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ImageSettings& a, ImageSettings& b) { a.Swap(&b); }
  inline void Swap(ImageSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImageSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImageSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImageSettings& from) { ImageSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImageSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ImageSettings"; }

 protected:
  explicit ImageSettings(::google::protobuf::Arena* arena);
  ImageSettings(::google::protobuf::Arena* arena, const ImageSettings& from);
  ImageSettings(::google::protobuf::Arena* arena, ImageSettings&& from) noexcept
      : ImageSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CaptureType = ImageSettings_CaptureType;
  static constexpr CaptureType SCHEDULED = ImageSettings_CaptureType_SCHEDULED;
  static constexpr CaptureType TRIGGERED = ImageSettings_CaptureType_TRIGGERED;
  static inline bool CaptureType_IsValid(int value) {
    return ImageSettings_CaptureType_IsValid(value);
  }
  static constexpr CaptureType CaptureType_MIN = ImageSettings_CaptureType_CaptureType_MIN;
  static constexpr CaptureType CaptureType_MAX = ImageSettings_CaptureType_CaptureType_MAX;
  static constexpr int CaptureType_ARRAYSIZE = ImageSettings_CaptureType_CaptureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CaptureType_descriptor() {
    return ImageSettings_CaptureType_descriptor();
  }
  template <typename T>
  static inline const std::string& CaptureType_Name(T value) {
    return ImageSettings_CaptureType_Name(value);
  }
  static inline bool CaptureType_Parse(absl::string_view name, CaptureType* value) {
    return ImageSettings_CaptureType_Parse(name, value);
  }
  using ImageQuality = ImageSettings_ImageQuality;
  static constexpr ImageQuality LOWEST = ImageSettings_ImageQuality_LOWEST;
  static constexpr ImageQuality LOWER = ImageSettings_ImageQuality_LOWER;
  static constexpr ImageQuality LOW = ImageSettings_ImageQuality_LOW;
  static constexpr ImageQuality MEDIUM = ImageSettings_ImageQuality_MEDIUM;
  static constexpr ImageQuality HIGHER = ImageSettings_ImageQuality_HIGHER;
  static constexpr ImageQuality HIGHEST = ImageSettings_ImageQuality_HIGHEST;
  static inline bool ImageQuality_IsValid(int value) {
    return ImageSettings_ImageQuality_IsValid(value);
  }
  static constexpr ImageQuality ImageQuality_MIN = ImageSettings_ImageQuality_ImageQuality_MIN;
  static constexpr ImageQuality ImageQuality_MAX = ImageSettings_ImageQuality_ImageQuality_MAX;
  static constexpr int ImageQuality_ARRAYSIZE = ImageSettings_ImageQuality_ImageQuality_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ImageQuality_descriptor() {
    return ImageSettings_ImageQuality_descriptor();
  }
  template <typename T>
  static inline const std::string& ImageQuality_Name(T value) {
    return ImageSettings_ImageQuality_Name(value);
  }
  static inline bool ImageQuality_Parse(absl::string_view name, ImageQuality* value) {
    return ImageSettings_ImageQuality_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kContrastFieldNumber = 1,
    kBrightnessFieldNumber = 2,
    kSaturationFieldNumber = 3,
    kSharpnessFieldNumber = 4,
    kWideDynamicRangeFieldNumber = 5,
    kVisibleLightEnhancementFieldNumber = 6,
    kCaptureTypeFieldNumber = 7,
    kImageQualityFieldNumber = 9,
  };
  // int32 contrast = 1;
  void clear_contrast() ;
  ::int32_t contrast() const;
  void set_contrast(::int32_t value);

  private:
  ::int32_t _internal_contrast() const;
  void _internal_set_contrast(::int32_t value);

  public:
  // int32 brightness = 2;
  void clear_brightness() ;
  ::int32_t brightness() const;
  void set_brightness(::int32_t value);

  private:
  ::int32_t _internal_brightness() const;
  void _internal_set_brightness(::int32_t value);

  public:
  // int32 saturation = 3;
  void clear_saturation() ;
  ::int32_t saturation() const;
  void set_saturation(::int32_t value);

  private:
  ::int32_t _internal_saturation() const;
  void _internal_set_saturation(::int32_t value);

  public:
  // int32 sharpness = 4;
  void clear_sharpness() ;
  ::int32_t sharpness() const;
  void set_sharpness(::int32_t value);

  private:
  ::int32_t _internal_sharpness() const;
  void _internal_set_sharpness(::int32_t value);

  public:
  // bool wide_dynamic_range = 5;
  void clear_wide_dynamic_range() ;
  bool wide_dynamic_range() const;
  void set_wide_dynamic_range(bool value);

  private:
  bool _internal_wide_dynamic_range() const;
  void _internal_set_wide_dynamic_range(bool value);

  public:
  // bool visible_light_enhancement = 6;
  void clear_visible_light_enhancement() ;
  bool visible_light_enhancement() const;
  void set_visible_light_enhancement(bool value);

  private:
  bool _internal_visible_light_enhancement() const;
  void _internal_set_visible_light_enhancement(bool value);

  public:
  // .ImageSettings.CaptureType capture_type = 7;
  void clear_capture_type() ;
  ::ImageSettings_CaptureType capture_type() const;
  void set_capture_type(::ImageSettings_CaptureType value);

  private:
  ::ImageSettings_CaptureType _internal_capture_type() const;
  void _internal_set_capture_type(::ImageSettings_CaptureType value);

  public:
  // .ImageSettings.ImageQuality image_quality = 9;
  void clear_image_quality() ;
  ::ImageSettings_ImageQuality image_quality() const;
  void set_image_quality(::ImageSettings_ImageQuality value);

  private:
  ::ImageSettings_ImageQuality _internal_image_quality() const;
  void _internal_set_image_quality(::ImageSettings_ImageQuality value);

  public:
  // @@protoc_insertion_point(class_scope:ImageSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ImageSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ImageSettings& from_msg);
    ::int32_t contrast_;
    ::int32_t brightness_;
    ::int32_t saturation_;
    ::int32_t sharpness_;
    bool wide_dynamic_range_;
    bool visible_light_enhancement_;
    int capture_type_;
    int image_quality_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class ImageModeMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ImageModeMessage) */ {
 public:
  inline ImageModeMessage() : ImageModeMessage(nullptr) {}
  ~ImageModeMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImageModeMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImageModeMessage(const ImageModeMessage& from) : ImageModeMessage(nullptr, from) {}
  inline ImageModeMessage(ImageModeMessage&& from) noexcept
      : ImageModeMessage(nullptr, std::move(from)) {}
  inline ImageModeMessage& operator=(const ImageModeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageModeMessage& operator=(ImageModeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageModeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageModeMessage* internal_default_instance() {
    return reinterpret_cast<const ImageModeMessage*>(
        &_ImageModeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(ImageModeMessage& a, ImageModeMessage& b) { a.Swap(&b); }
  inline void Swap(ImageModeMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageModeMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageModeMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImageModeMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImageModeMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImageModeMessage& from) { ImageModeMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImageModeMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ImageModeMessage"; }

 protected:
  explicit ImageModeMessage(::google::protobuf::Arena* arena);
  ImageModeMessage(::google::protobuf::Arena* arena, const ImageModeMessage& from);
  ImageModeMessage(::google::protobuf::Arena* arena, ImageModeMessage&& from) noexcept
      : ImageModeMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ImageMode = ImageModeMessage_ImageMode;
  static constexpr ImageMode AIR_MEASUREMENT_CLOUD = ImageModeMessage_ImageMode_AIR_MEASUREMENT_CLOUD;
  static constexpr ImageMode TDLAS_CLOUD_CONCENTRATION = ImageModeMessage_ImageMode_TDLAS_CLOUD_CONCENTRATION;
  static constexpr ImageMode INFRARED_NORMAL = ImageModeMessage_ImageMode_INFRARED_NORMAL;
  static constexpr ImageMode INFRARED_PIP = ImageModeMessage_ImageMode_INFRARED_PIP;
  static constexpr ImageMode INFRARED_ENHANCED = ImageModeMessage_ImageMode_INFRARED_ENHANCED;
  static constexpr ImageMode INFRARED_FUSION = ImageModeMessage_ImageMode_INFRARED_FUSION;
  static constexpr ImageMode PSEUDO_COLOR_WHITE_HOT = ImageModeMessage_ImageMode_PSEUDO_COLOR_WHITE_HOT;
  static constexpr ImageMode PSEUDO_COLOR_BLACK_HOT = ImageModeMessage_ImageMode_PSEUDO_COLOR_BLACK_HOT;
  static constexpr ImageMode PSEUDO_COLOR_IRON_RED = ImageModeMessage_ImageMode_PSEUDO_COLOR_IRON_RED;
  static constexpr ImageMode PSEUDO_COLOR_CYAN = ImageModeMessage_ImageMode_PSEUDO_COLOR_CYAN;
  static constexpr ImageMode PSEUDO_COLOR_RAINBOW = ImageModeMessage_ImageMode_PSEUDO_COLOR_RAINBOW;
  static constexpr ImageMode PSEUDO_COLOR_INVERSE_RAINBOW = ImageModeMessage_ImageMode_PSEUDO_COLOR_INVERSE_RAINBOW;
  static constexpr ImageMode PSEUDO_COLOR_RED_BROWN = ImageModeMessage_ImageMode_PSEUDO_COLOR_RED_BROWN;
  static constexpr ImageMode PSEUDO_COLOR_HEAT_IRON = ImageModeMessage_ImageMode_PSEUDO_COLOR_HEAT_IRON;
  static constexpr ImageMode PSEUDO_COLOR_COLD = ImageModeMessage_ImageMode_PSEUDO_COLOR_COLD;
  static constexpr ImageMode PSEUDO_COLOR_FIRE = ImageModeMessage_ImageMode_PSEUDO_COLOR_FIRE;
  static inline bool ImageMode_IsValid(int value) {
    return ImageModeMessage_ImageMode_IsValid(value);
  }
  static constexpr ImageMode ImageMode_MIN = ImageModeMessage_ImageMode_ImageMode_MIN;
  static constexpr ImageMode ImageMode_MAX = ImageModeMessage_ImageMode_ImageMode_MAX;
  static constexpr int ImageMode_ARRAYSIZE = ImageModeMessage_ImageMode_ImageMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ImageMode_descriptor() {
    return ImageModeMessage_ImageMode_descriptor();
  }
  template <typename T>
  static inline const std::string& ImageMode_Name(T value) {
    return ImageModeMessage_ImageMode_Name(value);
  }
  static inline bool ImageMode_Parse(absl::string_view name, ImageMode* value) {
    return ImageModeMessage_ImageMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kModeFieldNumber = 1,
  };
  // .ImageModeMessage.ImageMode mode = 1;
  void clear_mode() ;
  ::ImageModeMessage_ImageMode mode() const;
  void set_mode(::ImageModeMessage_ImageMode value);

  private:
  ::ImageModeMessage_ImageMode _internal_mode() const;
  void _internal_set_mode(::ImageModeMessage_ImageMode value);

  public:
  // @@protoc_insertion_point(class_scope:ImageModeMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ImageModeMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ImageModeMessage& from_msg);
    int mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class IPSettings_IPv6Config final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:IPSettings.IPv6Config) */ {
 public:
  inline IPSettings_IPv6Config() : IPSettings_IPv6Config(nullptr) {}
  ~IPSettings_IPv6Config() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IPSettings_IPv6Config(
      ::google::protobuf::internal::ConstantInitialized);

  inline IPSettings_IPv6Config(const IPSettings_IPv6Config& from) : IPSettings_IPv6Config(nullptr, from) {}
  inline IPSettings_IPv6Config(IPSettings_IPv6Config&& from) noexcept
      : IPSettings_IPv6Config(nullptr, std::move(from)) {}
  inline IPSettings_IPv6Config& operator=(const IPSettings_IPv6Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSettings_IPv6Config& operator=(IPSettings_IPv6Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSettings_IPv6Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPSettings_IPv6Config* internal_default_instance() {
    return reinterpret_cast<const IPSettings_IPv6Config*>(
        &_IPSettings_IPv6Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(IPSettings_IPv6Config& a, IPSettings_IPv6Config& b) { a.Swap(&b); }
  inline void Swap(IPSettings_IPv6Config* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSettings_IPv6Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSettings_IPv6Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IPSettings_IPv6Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IPSettings_IPv6Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IPSettings_IPv6Config& from) { IPSettings_IPv6Config::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IPSettings_IPv6Config* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "IPSettings.IPv6Config"; }

 protected:
  explicit IPSettings_IPv6Config(::google::protobuf::Arena* arena);
  IPSettings_IPv6Config(::google::protobuf::Arena* arena, const IPSettings_IPv6Config& from);
  IPSettings_IPv6Config(::google::protobuf::Arena* arena, IPSettings_IPv6Config&& from) noexcept
      : IPSettings_IPv6Config(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpAddressFieldNumber = 1,
    kSubnetPrefixFieldNumber = 2,
    kDefaultGatewayFieldNumber = 3,
    kPrimaryDnsFieldNumber = 4,
    kSecondaryDnsFieldNumber = 5,
  };
  // string ip_address = 1;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string subnet_prefix = 2;
  void clear_subnet_prefix() ;
  const std::string& subnet_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subnet_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_subnet_prefix();
  PROTOBUF_NODISCARD std::string* release_subnet_prefix();
  void set_allocated_subnet_prefix(std::string* value);

  private:
  const std::string& _internal_subnet_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnet_prefix(
      const std::string& value);
  std::string* _internal_mutable_subnet_prefix();

  public:
  // string default_gateway = 3;
  void clear_default_gateway() ;
  const std::string& default_gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_default_gateway();
  PROTOBUF_NODISCARD std::string* release_default_gateway();
  void set_allocated_default_gateway(std::string* value);

  private:
  const std::string& _internal_default_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_gateway(
      const std::string& value);
  std::string* _internal_mutable_default_gateway();

  public:
  // string primary_dns = 4;
  void clear_primary_dns() ;
  const std::string& primary_dns() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_dns(Arg_&& arg, Args_... args);
  std::string* mutable_primary_dns();
  PROTOBUF_NODISCARD std::string* release_primary_dns();
  void set_allocated_primary_dns(std::string* value);

  private:
  const std::string& _internal_primary_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_dns(
      const std::string& value);
  std::string* _internal_mutable_primary_dns();

  public:
  // string secondary_dns = 5;
  void clear_secondary_dns() ;
  const std::string& secondary_dns() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secondary_dns(Arg_&& arg, Args_... args);
  std::string* mutable_secondary_dns();
  PROTOBUF_NODISCARD std::string* release_secondary_dns();
  void set_allocated_secondary_dns(std::string* value);

  private:
  const std::string& _internal_secondary_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secondary_dns(
      const std::string& value);
  std::string* _internal_mutable_secondary_dns();

  public:
  // @@protoc_insertion_point(class_scope:IPSettings.IPv6Config)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      92, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IPSettings_IPv6Config_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IPSettings_IPv6Config& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr subnet_prefix_;
    ::google::protobuf::internal::ArenaStringPtr default_gateway_;
    ::google::protobuf::internal::ArenaStringPtr primary_dns_;
    ::google::protobuf::internal::ArenaStringPtr secondary_dns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class IPSettings_IPv4Config final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:IPSettings.IPv4Config) */ {
 public:
  inline IPSettings_IPv4Config() : IPSettings_IPv4Config(nullptr) {}
  ~IPSettings_IPv4Config() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IPSettings_IPv4Config(
      ::google::protobuf::internal::ConstantInitialized);

  inline IPSettings_IPv4Config(const IPSettings_IPv4Config& from) : IPSettings_IPv4Config(nullptr, from) {}
  inline IPSettings_IPv4Config(IPSettings_IPv4Config&& from) noexcept
      : IPSettings_IPv4Config(nullptr, std::move(from)) {}
  inline IPSettings_IPv4Config& operator=(const IPSettings_IPv4Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSettings_IPv4Config& operator=(IPSettings_IPv4Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSettings_IPv4Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPSettings_IPv4Config* internal_default_instance() {
    return reinterpret_cast<const IPSettings_IPv4Config*>(
        &_IPSettings_IPv4Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(IPSettings_IPv4Config& a, IPSettings_IPv4Config& b) { a.Swap(&b); }
  inline void Swap(IPSettings_IPv4Config* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSettings_IPv4Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSettings_IPv4Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IPSettings_IPv4Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IPSettings_IPv4Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IPSettings_IPv4Config& from) { IPSettings_IPv4Config::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IPSettings_IPv4Config* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "IPSettings.IPv4Config"; }

 protected:
  explicit IPSettings_IPv4Config(::google::protobuf::Arena* arena);
  IPSettings_IPv4Config(::google::protobuf::Arena* arena, const IPSettings_IPv4Config& from);
  IPSettings_IPv4Config(::google::protobuf::Arena* arena, IPSettings_IPv4Config&& from) noexcept
      : IPSettings_IPv4Config(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpAddressFieldNumber = 1,
    kSubnetMaskFieldNumber = 2,
    kDefaultGatewayFieldNumber = 3,
    kPrimaryDnsFieldNumber = 4,
    kSecondaryDnsFieldNumber = 5,
  };
  // string ip_address = 1;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string subnet_mask = 2;
  void clear_subnet_mask() ;
  const std::string& subnet_mask() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subnet_mask(Arg_&& arg, Args_... args);
  std::string* mutable_subnet_mask();
  PROTOBUF_NODISCARD std::string* release_subnet_mask();
  void set_allocated_subnet_mask(std::string* value);

  private:
  const std::string& _internal_subnet_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnet_mask(
      const std::string& value);
  std::string* _internal_mutable_subnet_mask();

  public:
  // string default_gateway = 3;
  void clear_default_gateway() ;
  const std::string& default_gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_default_gateway();
  PROTOBUF_NODISCARD std::string* release_default_gateway();
  void set_allocated_default_gateway(std::string* value);

  private:
  const std::string& _internal_default_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_gateway(
      const std::string& value);
  std::string* _internal_mutable_default_gateway();

  public:
  // string primary_dns = 4;
  void clear_primary_dns() ;
  const std::string& primary_dns() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_dns(Arg_&& arg, Args_... args);
  std::string* mutable_primary_dns();
  PROTOBUF_NODISCARD std::string* release_primary_dns();
  void set_allocated_primary_dns(std::string* value);

  private:
  const std::string& _internal_primary_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_dns(
      const std::string& value);
  std::string* _internal_mutable_primary_dns();

  public:
  // string secondary_dns = 5;
  void clear_secondary_dns() ;
  const std::string& secondary_dns() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secondary_dns(Arg_&& arg, Args_... args);
  std::string* mutable_secondary_dns();
  PROTOBUF_NODISCARD std::string* release_secondary_dns();
  void set_allocated_secondary_dns(std::string* value);

  private:
  const std::string& _internal_secondary_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secondary_dns(
      const std::string& value);
  std::string* _internal_mutable_secondary_dns();

  public:
  // @@protoc_insertion_point(class_scope:IPSettings.IPv4Config)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      90, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IPSettings_IPv4Config_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IPSettings_IPv4Config& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr subnet_mask_;
    ::google::protobuf::internal::ArenaStringPtr default_gateway_;
    ::google::protobuf::internal::ArenaStringPtr primary_dns_;
    ::google::protobuf::internal::ArenaStringPtr secondary_dns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class IPSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:IPSettings) */ {
 public:
  inline IPSettings() : IPSettings(nullptr) {}
  ~IPSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IPSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline IPSettings(const IPSettings& from) : IPSettings(nullptr, from) {}
  inline IPSettings(IPSettings&& from) noexcept
      : IPSettings(nullptr, std::move(from)) {}
  inline IPSettings& operator=(const IPSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPSettings& operator=(IPSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPSettings* internal_default_instance() {
    return reinterpret_cast<const IPSettings*>(
        &_IPSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(IPSettings& a, IPSettings& b) { a.Swap(&b); }
  inline void Swap(IPSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IPSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IPSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IPSettings& from) { IPSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IPSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "IPSettings"; }

 protected:
  explicit IPSettings(::google::protobuf::Arena* arena);
  IPSettings(::google::protobuf::Arena* arena, const IPSettings& from);
  IPSettings(::google::protobuf::Arena* arena, IPSettings&& from) noexcept
      : IPSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using IPv4Config = IPSettings_IPv4Config;
  using IPv6Config = IPSettings_IPv6Config;

  // accessors -------------------------------------------------------
  enum : int {
    kIsStaticIpFieldNumber = 1,
  };
  // bool is_static_ip = 1;
  void clear_is_static_ip() ;
  bool is_static_ip() const;
  void set_is_static_ip(bool value);

  private:
  bool _internal_is_static_ip() const;
  void _internal_set_is_static_ip(bool value);

  public:
  // @@protoc_insertion_point(class_scope:IPSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IPSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IPSettings& from_msg);
    bool is_static_ip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class GasLeakageAlarmSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GasLeakageAlarmSettings) */ {
 public:
  inline GasLeakageAlarmSettings() : GasLeakageAlarmSettings(nullptr) {}
  ~GasLeakageAlarmSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GasLeakageAlarmSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline GasLeakageAlarmSettings(const GasLeakageAlarmSettings& from) : GasLeakageAlarmSettings(nullptr, from) {}
  inline GasLeakageAlarmSettings(GasLeakageAlarmSettings&& from) noexcept
      : GasLeakageAlarmSettings(nullptr, std::move(from)) {}
  inline GasLeakageAlarmSettings& operator=(const GasLeakageAlarmSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline GasLeakageAlarmSettings& operator=(GasLeakageAlarmSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GasLeakageAlarmSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const GasLeakageAlarmSettings* internal_default_instance() {
    return reinterpret_cast<const GasLeakageAlarmSettings*>(
        &_GasLeakageAlarmSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GasLeakageAlarmSettings& a, GasLeakageAlarmSettings& b) { a.Swap(&b); }
  inline void Swap(GasLeakageAlarmSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GasLeakageAlarmSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GasLeakageAlarmSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GasLeakageAlarmSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GasLeakageAlarmSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GasLeakageAlarmSettings& from) { GasLeakageAlarmSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GasLeakageAlarmSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GasLeakageAlarmSettings"; }

 protected:
  explicit GasLeakageAlarmSettings(::google::protobuf::Arena* arena);
  GasLeakageAlarmSettings(::google::protobuf::Arena* arena, const GasLeakageAlarmSettings& from);
  GasLeakageAlarmSettings(::google::protobuf::Arena* arena, GasLeakageAlarmSettings&& from) noexcept
      : GasLeakageAlarmSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmailAddressFieldNumber = 10,
    kAlarmConcentrationFieldNumber = 2,
    kSnapshotIntervalFieldNumber = 4,
    kAlarmEnableFieldNumber = 1,
    kAutoSnapshotFieldNumber = 3,
    kAutoRecordVideoFieldNumber = 5,
    kAlarmOutputFieldNumber = 7,
    kRecordDelayFieldNumber = 6,
    kAlarmDelayFieldNumber = 8,
    kSendEmailFieldNumber = 9,
  };
  // string email_address = 10;
  void clear_email_address() ;
  const std::string& email_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email_address(Arg_&& arg, Args_... args);
  std::string* mutable_email_address();
  PROTOBUF_NODISCARD std::string* release_email_address();
  void set_allocated_email_address(std::string* value);

  private:
  const std::string& _internal_email_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_address(
      const std::string& value);
  std::string* _internal_mutable_email_address();

  public:
  // float alarm_concentration = 2;
  void clear_alarm_concentration() ;
  float alarm_concentration() const;
  void set_alarm_concentration(float value);

  private:
  float _internal_alarm_concentration() const;
  void _internal_set_alarm_concentration(float value);

  public:
  // int32 snapshot_interval = 4;
  void clear_snapshot_interval() ;
  ::int32_t snapshot_interval() const;
  void set_snapshot_interval(::int32_t value);

  private:
  ::int32_t _internal_snapshot_interval() const;
  void _internal_set_snapshot_interval(::int32_t value);

  public:
  // bool alarm_enable = 1;
  void clear_alarm_enable() ;
  bool alarm_enable() const;
  void set_alarm_enable(bool value);

  private:
  bool _internal_alarm_enable() const;
  void _internal_set_alarm_enable(bool value);

  public:
  // bool auto_snapshot = 3;
  void clear_auto_snapshot() ;
  bool auto_snapshot() const;
  void set_auto_snapshot(bool value);

  private:
  bool _internal_auto_snapshot() const;
  void _internal_set_auto_snapshot(bool value);

  public:
  // bool auto_record_video = 5;
  void clear_auto_record_video() ;
  bool auto_record_video() const;
  void set_auto_record_video(bool value);

  private:
  bool _internal_auto_record_video() const;
  void _internal_set_auto_record_video(bool value);

  public:
  // bool alarm_output = 7;
  void clear_alarm_output() ;
  bool alarm_output() const;
  void set_alarm_output(bool value);

  private:
  bool _internal_alarm_output() const;
  void _internal_set_alarm_output(bool value);

  public:
  // int32 record_delay = 6;
  void clear_record_delay() ;
  ::int32_t record_delay() const;
  void set_record_delay(::int32_t value);

  private:
  ::int32_t _internal_record_delay() const;
  void _internal_set_record_delay(::int32_t value);

  public:
  // int32 alarm_delay = 8;
  void clear_alarm_delay() ;
  ::int32_t alarm_delay() const;
  void set_alarm_delay(::int32_t value);

  private:
  ::int32_t _internal_alarm_delay() const;
  void _internal_set_alarm_delay(::int32_t value);

  public:
  // bool send_email = 9;
  void clear_send_email() ;
  bool send_email() const;
  void set_send_email(bool value);

  private:
  bool _internal_send_email() const;
  void _internal_set_send_email(bool value);

  public:
  // @@protoc_insertion_point(class_scope:GasLeakageAlarmSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GasLeakageAlarmSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GasLeakageAlarmSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr email_address_;
    float alarm_concentration_;
    ::int32_t snapshot_interval_;
    bool alarm_enable_;
    bool auto_snapshot_;
    bool auto_record_video_;
    bool alarm_output_;
    ::int32_t record_delay_;
    ::int32_t alarm_delay_;
    bool send_email_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class FTPSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:FTPSettings) */ {
 public:
  inline FTPSettings() : FTPSettings(nullptr) {}
  ~FTPSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FTPSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline FTPSettings(const FTPSettings& from) : FTPSettings(nullptr, from) {}
  inline FTPSettings(FTPSettings&& from) noexcept
      : FTPSettings(nullptr, std::move(from)) {}
  inline FTPSettings& operator=(const FTPSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline FTPSettings& operator=(FTPSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FTPSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const FTPSettings* internal_default_instance() {
    return reinterpret_cast<const FTPSettings*>(
        &_FTPSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(FTPSettings& a, FTPSettings& b) { a.Swap(&b); }
  inline void Swap(FTPSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FTPSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FTPSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FTPSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FTPSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FTPSettings& from) { FTPSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FTPSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "FTPSettings"; }

 protected:
  explicit FTPSettings(::google::protobuf::Arena* arena);
  FTPSettings(::google::protobuf::Arena* arena, const FTPSettings& from);
  FTPSettings(::google::protobuf::Arena* arena, FTPSettings&& from) noexcept
      : FTPSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFtpIpFieldNumber = 1,
    kStoragePathFieldNumber = 2,
    kPortFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
  };
  // string ftp_ip = 1;
  void clear_ftp_ip() ;
  const std::string& ftp_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ftp_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ftp_ip();
  PROTOBUF_NODISCARD std::string* release_ftp_ip();
  void set_allocated_ftp_ip(std::string* value);

  private:
  const std::string& _internal_ftp_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ftp_ip(
      const std::string& value);
  std::string* _internal_mutable_ftp_ip();

  public:
  // string storage_path = 2;
  void clear_storage_path() ;
  const std::string& storage_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_storage_path(Arg_&& arg, Args_... args);
  std::string* mutable_storage_path();
  PROTOBUF_NODISCARD std::string* release_storage_path();
  void set_allocated_storage_path(std::string* value);

  private:
  const std::string& _internal_storage_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_path(
      const std::string& value);
  std::string* _internal_mutable_storage_path();

  public:
  // string port = 3;
  void clear_port() ;
  const std::string& port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port(Arg_&& arg, Args_... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* value);

  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(
      const std::string& value);
  std::string* _internal_mutable_port();

  public:
  // string username = 4;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 5;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:FTPSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FTPSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FTPSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ftp_ip_;
    ::google::protobuf::internal::ArenaStringPtr storage_path_;
    ::google::protobuf::internal::ArenaStringPtr port_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class ExposureSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ExposureSettings) */ {
 public:
  inline ExposureSettings() : ExposureSettings(nullptr) {}
  ~ExposureSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExposureSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExposureSettings(const ExposureSettings& from) : ExposureSettings(nullptr, from) {}
  inline ExposureSettings(ExposureSettings&& from) noexcept
      : ExposureSettings(nullptr, std::move(from)) {}
  inline ExposureSettings& operator=(const ExposureSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExposureSettings& operator=(ExposureSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExposureSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExposureSettings* internal_default_instance() {
    return reinterpret_cast<const ExposureSettings*>(
        &_ExposureSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ExposureSettings& a, ExposureSettings& b) { a.Swap(&b); }
  inline void Swap(ExposureSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExposureSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExposureSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExposureSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExposureSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExposureSettings& from) { ExposureSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExposureSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ExposureSettings"; }

 protected:
  explicit ExposureSettings(::google::protobuf::Arena* arena);
  ExposureSettings(::google::protobuf::Arena* arena, const ExposureSettings& from);
  ExposureSettings(::google::protobuf::Arena* arena, ExposureSettings&& from) noexcept
      : ExposureSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ExposureMode = ExposureSettings_ExposureMode;
  static constexpr ExposureMode AUTO = ExposureSettings_ExposureMode_AUTO;
  static constexpr ExposureMode MANUAL = ExposureSettings_ExposureMode_MANUAL;
  static inline bool ExposureMode_IsValid(int value) {
    return ExposureSettings_ExposureMode_IsValid(value);
  }
  static constexpr ExposureMode ExposureMode_MIN = ExposureSettings_ExposureMode_ExposureMode_MIN;
  static constexpr ExposureMode ExposureMode_MAX = ExposureSettings_ExposureMode_ExposureMode_MAX;
  static constexpr int ExposureMode_ARRAYSIZE = ExposureSettings_ExposureMode_ExposureMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ExposureMode_descriptor() {
    return ExposureSettings_ExposureMode_descriptor();
  }
  template <typename T>
  static inline const std::string& ExposureMode_Name(T value) {
    return ExposureSettings_ExposureMode_Name(value);
  }
  static inline bool ExposureMode_Parse(absl::string_view name, ExposureMode* value) {
    return ExposureSettings_ExposureMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kExposureModeFieldNumber = 1,
    kExposureTimeFieldNumber = 2,
  };
  // .ExposureSettings.ExposureMode exposure_mode = 1;
  void clear_exposure_mode() ;
  ::ExposureSettings_ExposureMode exposure_mode() const;
  void set_exposure_mode(::ExposureSettings_ExposureMode value);

  private:
  ::ExposureSettings_ExposureMode _internal_exposure_mode() const;
  void _internal_set_exposure_mode(::ExposureSettings_ExposureMode value);

  public:
  // int32 exposure_time = 2;
  void clear_exposure_time() ;
  ::int32_t exposure_time() const;
  void set_exposure_time(::int32_t value);

  private:
  ::int32_t _internal_exposure_time() const;
  void _internal_set_exposure_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ExposureSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExposureSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExposureSettings& from_msg);
    int exposure_mode_;
    ::int32_t exposure_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class DetectionArea final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DetectionArea) */ {
 public:
  inline DetectionArea() : DetectionArea(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DetectionArea(
      ::google::protobuf::internal::ConstantInitialized);

  inline DetectionArea(const DetectionArea& from) : DetectionArea(nullptr, from) {}
  inline DetectionArea(DetectionArea&& from) noexcept
      : DetectionArea(nullptr, std::move(from)) {}
  inline DetectionArea& operator=(const DetectionArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionArea& operator=(DetectionArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectionArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionArea* internal_default_instance() {
    return reinterpret_cast<const DetectionArea*>(
        &_DetectionArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(DetectionArea& a, DetectionArea& b) { a.Swap(&b); }
  inline void Swap(DetectionArea* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionArea* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectionArea* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DetectionArea>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DetectionArea& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DetectionArea& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DetectionArea"; }

 protected:
  explicit DetectionArea(::google::protobuf::Arena* arena);
  DetectionArea(::google::protobuf::Arena* arena, const DetectionArea& from);
  DetectionArea(::google::protobuf::Arena* arena, DetectionArea&& from) noexcept
      : DetectionArea(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DetectionArea)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DetectionArea_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DetectionArea& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class DayNightSwitchSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DayNightSwitchSettings) */ {
 public:
  inline DayNightSwitchSettings() : DayNightSwitchSettings(nullptr) {}
  ~DayNightSwitchSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DayNightSwitchSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline DayNightSwitchSettings(const DayNightSwitchSettings& from) : DayNightSwitchSettings(nullptr, from) {}
  inline DayNightSwitchSettings(DayNightSwitchSettings&& from) noexcept
      : DayNightSwitchSettings(nullptr, std::move(from)) {}
  inline DayNightSwitchSettings& operator=(const DayNightSwitchSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline DayNightSwitchSettings& operator=(DayNightSwitchSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DayNightSwitchSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const DayNightSwitchSettings* internal_default_instance() {
    return reinterpret_cast<const DayNightSwitchSettings*>(
        &_DayNightSwitchSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(DayNightSwitchSettings& a, DayNightSwitchSettings& b) { a.Swap(&b); }
  inline void Swap(DayNightSwitchSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DayNightSwitchSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DayNightSwitchSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DayNightSwitchSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DayNightSwitchSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DayNightSwitchSettings& from) { DayNightSwitchSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DayNightSwitchSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DayNightSwitchSettings"; }

 protected:
  explicit DayNightSwitchSettings(::google::protobuf::Arena* arena);
  DayNightSwitchSettings(::google::protobuf::Arena* arena, const DayNightSwitchSettings& from);
  DayNightSwitchSettings(::google::protobuf::Arena* arena, DayNightSwitchSettings&& from) noexcept
      : DayNightSwitchSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Mode = DayNightSwitchSettings_Mode;
  static constexpr Mode AUTO = DayNightSwitchSettings_Mode_AUTO;
  static constexpr Mode DAY = DayNightSwitchSettings_Mode_DAY;
  static constexpr Mode NIGHT = DayNightSwitchSettings_Mode_NIGHT;
  static constexpr Mode TIMED = DayNightSwitchSettings_Mode_TIMED;
  static inline bool Mode_IsValid(int value) {
    return DayNightSwitchSettings_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = DayNightSwitchSettings_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = DayNightSwitchSettings_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = DayNightSwitchSettings_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Mode_descriptor() {
    return DayNightSwitchSettings_Mode_descriptor();
  }
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return DayNightSwitchSettings_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return DayNightSwitchSettings_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kModeFieldNumber = 1,
  };
  // string start_time = 2;
  void clear_start_time() ;
  const std::string& start_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* value);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // string end_time = 3;
  void clear_end_time() ;
  const std::string& end_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_time(Arg_&& arg, Args_... args);
  std::string* mutable_end_time();
  PROTOBUF_NODISCARD std::string* release_end_time();
  void set_allocated_end_time(std::string* value);

  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(
      const std::string& value);
  std::string* _internal_mutable_end_time();

  public:
  // .DayNightSwitchSettings.Mode mode = 1;
  void clear_mode() ;
  ::DayNightSwitchSettings_Mode mode() const;
  void set_mode(::DayNightSwitchSettings_Mode value);

  private:
  ::DayNightSwitchSettings_Mode _internal_mode() const;
  void _internal_set_mode(::DayNightSwitchSettings_Mode value);

  public:
  // @@protoc_insertion_point(class_scope:DayNightSwitchSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DayNightSwitchSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DayNightSwitchSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr start_time_;
    ::google::protobuf::internal::ArenaStringPtr end_time_;
    int mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class AccessoryControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AccessoryControl) */ {
 public:
  inline AccessoryControl() : AccessoryControl(nullptr) {}
  ~AccessoryControl() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessoryControl(
      ::google::protobuf::internal::ConstantInitialized);

  inline AccessoryControl(const AccessoryControl& from) : AccessoryControl(nullptr, from) {}
  inline AccessoryControl(AccessoryControl&& from) noexcept
      : AccessoryControl(nullptr, std::move(from)) {}
  inline AccessoryControl& operator=(const AccessoryControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessoryControl& operator=(AccessoryControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessoryControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessoryControl* internal_default_instance() {
    return reinterpret_cast<const AccessoryControl*>(
        &_AccessoryControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(AccessoryControl& a, AccessoryControl& b) { a.Swap(&b); }
  inline void Swap(AccessoryControl* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessoryControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessoryControl* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AccessoryControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccessoryControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccessoryControl& from) { AccessoryControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AccessoryControl* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "AccessoryControl"; }

 protected:
  explicit AccessoryControl(::google::protobuf::Arena* arena);
  AccessoryControl(::google::protobuf::Arena* arena, const AccessoryControl& from);
  AccessoryControl(::google::protobuf::Arena* arena, AccessoryControl&& from) noexcept
      : AccessoryControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLightFieldNumber = 1,
    kWiperFieldNumber = 2,
  };
  // bool light = 1;
  void clear_light() ;
  bool light() const;
  void set_light(bool value);

  private:
  bool _internal_light() const;
  void _internal_set_light(bool value);

  public:
  // bool wiper = 2;
  void clear_wiper() ;
  bool wiper() const;
  void set_wiper(bool value);

  private:
  bool _internal_wiper() const;
  void _internal_set_wiper(bool value);

  public:
  // @@protoc_insertion_point(class_scope:AccessoryControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AccessoryControl_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AccessoryControl& from_msg);
    bool light_;
    bool wiper_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class WhiteBalanceSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:WhiteBalanceSettings) */ {
 public:
  inline WhiteBalanceSettings() : WhiteBalanceSettings(nullptr) {}
  ~WhiteBalanceSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhiteBalanceSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhiteBalanceSettings(const WhiteBalanceSettings& from) : WhiteBalanceSettings(nullptr, from) {}
  inline WhiteBalanceSettings(WhiteBalanceSettings&& from) noexcept
      : WhiteBalanceSettings(nullptr, std::move(from)) {}
  inline WhiteBalanceSettings& operator=(const WhiteBalanceSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhiteBalanceSettings& operator=(WhiteBalanceSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhiteBalanceSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhiteBalanceSettings* internal_default_instance() {
    return reinterpret_cast<const WhiteBalanceSettings*>(
        &_WhiteBalanceSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(WhiteBalanceSettings& a, WhiteBalanceSettings& b) { a.Swap(&b); }
  inline void Swap(WhiteBalanceSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhiteBalanceSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhiteBalanceSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WhiteBalanceSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhiteBalanceSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhiteBalanceSettings& from) { WhiteBalanceSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhiteBalanceSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "WhiteBalanceSettings"; }

 protected:
  explicit WhiteBalanceSettings(::google::protobuf::Arena* arena);
  WhiteBalanceSettings(::google::protobuf::Arena* arena, const WhiteBalanceSettings& from);
  WhiteBalanceSettings(::google::protobuf::Arena* arena, WhiteBalanceSettings&& from) noexcept
      : WhiteBalanceSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ManualWhiteBalance = WhiteBalanceSettings_ManualWhiteBalance;
  using WhiteBalanceMode = WhiteBalanceSettings_WhiteBalanceMode;
  static constexpr WhiteBalanceMode AUTO = WhiteBalanceSettings_WhiteBalanceMode_AUTO;
  static constexpr WhiteBalanceMode MANUAL = WhiteBalanceSettings_WhiteBalanceMode_MANUAL;
  static inline bool WhiteBalanceMode_IsValid(int value) {
    return WhiteBalanceSettings_WhiteBalanceMode_IsValid(value);
  }
  static constexpr WhiteBalanceMode WhiteBalanceMode_MIN = WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_MIN;
  static constexpr WhiteBalanceMode WhiteBalanceMode_MAX = WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_MAX;
  static constexpr int WhiteBalanceMode_ARRAYSIZE = WhiteBalanceSettings_WhiteBalanceMode_WhiteBalanceMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* WhiteBalanceMode_descriptor() {
    return WhiteBalanceSettings_WhiteBalanceMode_descriptor();
  }
  template <typename T>
  static inline const std::string& WhiteBalanceMode_Name(T value) {
    return WhiteBalanceSettings_WhiteBalanceMode_Name(value);
  }
  static inline bool WhiteBalanceMode_Parse(absl::string_view name, WhiteBalanceMode* value) {
    return WhiteBalanceSettings_WhiteBalanceMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kManualWhiteBalanceFieldNumber = 2,
    kWhiteBalanceModeFieldNumber = 1,
  };
  // .WhiteBalanceSettings.ManualWhiteBalance manual_white_balance = 2;
  bool has_manual_white_balance() const;
  void clear_manual_white_balance() ;
  const ::WhiteBalanceSettings_ManualWhiteBalance& manual_white_balance() const;
  PROTOBUF_NODISCARD ::WhiteBalanceSettings_ManualWhiteBalance* release_manual_white_balance();
  ::WhiteBalanceSettings_ManualWhiteBalance* mutable_manual_white_balance();
  void set_allocated_manual_white_balance(::WhiteBalanceSettings_ManualWhiteBalance* value);
  void unsafe_arena_set_allocated_manual_white_balance(::WhiteBalanceSettings_ManualWhiteBalance* value);
  ::WhiteBalanceSettings_ManualWhiteBalance* unsafe_arena_release_manual_white_balance();

  private:
  const ::WhiteBalanceSettings_ManualWhiteBalance& _internal_manual_white_balance() const;
  ::WhiteBalanceSettings_ManualWhiteBalance* _internal_mutable_manual_white_balance();

  public:
  // .WhiteBalanceSettings.WhiteBalanceMode white_balance_mode = 1;
  void clear_white_balance_mode() ;
  ::WhiteBalanceSettings_WhiteBalanceMode white_balance_mode() const;
  void set_white_balance_mode(::WhiteBalanceSettings_WhiteBalanceMode value);

  private:
  ::WhiteBalanceSettings_WhiteBalanceMode _internal_white_balance_mode() const;
  void _internal_set_white_balance_mode(::WhiteBalanceSettings_WhiteBalanceMode value);

  public:
  // @@protoc_insertion_point(class_scope:WhiteBalanceSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WhiteBalanceSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhiteBalanceSettings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::WhiteBalanceSettings_ManualWhiteBalance* manual_white_balance_;
    int white_balance_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class TrackingScan final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TrackingScan) */ {
 public:
  inline TrackingScan() : TrackingScan(nullptr) {}
  ~TrackingScan() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackingScan(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackingScan(const TrackingScan& from) : TrackingScan(nullptr, from) {}
  inline TrackingScan(TrackingScan&& from) noexcept
      : TrackingScan(nullptr, std::move(from)) {}
  inline TrackingScan& operator=(const TrackingScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingScan& operator=(TrackingScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingScan* internal_default_instance() {
    return reinterpret_cast<const TrackingScan*>(
        &_TrackingScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(TrackingScan& a, TrackingScan& b) { a.Swap(&b); }
  inline void Swap(TrackingScan* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingScan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TrackingScan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackingScan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackingScan& from) { TrackingScan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrackingScan* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TrackingScan"; }

 protected:
  explicit TrackingScan(::google::protobuf::Arena* arena);
  TrackingScan(::google::protobuf::Arena* arena, const TrackingScan& from);
  TrackingScan(::google::protobuf::Arena* arena, TrackingScan&& from) noexcept
      : TrackingScan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCmdFieldNumber = 1,
  };
  // repeated .TrackingScanCmd cmd = 1;
  int cmd_size() const;
  private:
  int _internal_cmd_size() const;

  public:
  void clear_cmd() ;
  ::TrackingScanCmd* mutable_cmd(int index);
  ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>* mutable_cmd();

  private:
  const ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>& _internal_cmd() const;
  ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>* _internal_mutable_cmd();
  public:
  const ::TrackingScanCmd& cmd(int index) const;
  ::TrackingScanCmd* add_cmd();
  const ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>& cmd() const;
  // @@protoc_insertion_point(class_scope:TrackingScan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TrackingScan_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackingScan& from_msg);
    ::google::protobuf::RepeatedPtrField< ::TrackingScanCmd > cmd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class SystemLogsQuery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SystemLogsQuery) */ {
 public:
  inline SystemLogsQuery() : SystemLogsQuery(nullptr) {}
  ~SystemLogsQuery() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SystemLogsQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline SystemLogsQuery(const SystemLogsQuery& from) : SystemLogsQuery(nullptr, from) {}
  inline SystemLogsQuery(SystemLogsQuery&& from) noexcept
      : SystemLogsQuery(nullptr, std::move(from)) {}
  inline SystemLogsQuery& operator=(const SystemLogsQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemLogsQuery& operator=(SystemLogsQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemLogsQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemLogsQuery* internal_default_instance() {
    return reinterpret_cast<const SystemLogsQuery*>(
        &_SystemLogsQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(SystemLogsQuery& a, SystemLogsQuery& b) { a.Swap(&b); }
  inline void Swap(SystemLogsQuery* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemLogsQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemLogsQuery* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SystemLogsQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SystemLogsQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SystemLogsQuery& from) { SystemLogsQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SystemLogsQuery* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SystemLogsQuery"; }

 protected:
  explicit SystemLogsQuery(::google::protobuf::Arena* arena);
  SystemLogsQuery(::google::protobuf::Arena* arena, const SystemLogsQuery& from);
  SystemLogsQuery(::google::protobuf::Arena* arena, SystemLogsQuery&& from) noexcept
      : SystemLogsQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using QueryType = SystemLogsQuery_QueryType;
  static constexpr QueryType USER_ID = SystemLogsQuery_QueryType_USER_ID;
  static constexpr QueryType LOG_TYPE = SystemLogsQuery_QueryType_LOG_TYPE;
  static constexpr QueryType OP_TYPE = SystemLogsQuery_QueryType_OP_TYPE;
  static constexpr QueryType OP_DATE = SystemLogsQuery_QueryType_OP_DATE;
  static inline bool QueryType_IsValid(int value) {
    return SystemLogsQuery_QueryType_IsValid(value);
  }
  static constexpr QueryType QueryType_MIN = SystemLogsQuery_QueryType_QueryType_MIN;
  static constexpr QueryType QueryType_MAX = SystemLogsQuery_QueryType_QueryType_MAX;
  static constexpr int QueryType_ARRAYSIZE = SystemLogsQuery_QueryType_QueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* QueryType_descriptor() {
    return SystemLogsQuery_QueryType_descriptor();
  }
  template <typename T>
  static inline const std::string& QueryType_Name(T value) {
    return SystemLogsQuery_QueryType_Name(value);
  }
  static inline bool QueryType_Parse(absl::string_view name, QueryType* value) {
    return SystemLogsQuery_QueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLogEntriesFieldNumber = 3,
    kQueryPatternFieldNumber = 2,
    kTimeFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .LogEntry log_entries = 3;
  int log_entries_size() const;
  private:
  int _internal_log_entries_size() const;

  public:
  void clear_log_entries() ;
  ::LogEntry* mutable_log_entries(int index);
  ::google::protobuf::RepeatedPtrField<::LogEntry>* mutable_log_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::LogEntry>& _internal_log_entries() const;
  ::google::protobuf::RepeatedPtrField<::LogEntry>* _internal_mutable_log_entries();
  public:
  const ::LogEntry& log_entries(int index) const;
  ::LogEntry* add_log_entries();
  const ::google::protobuf::RepeatedPtrField<::LogEntry>& log_entries() const;
  // string query_pattern = 2;
  void clear_query_pattern() ;
  const std::string& query_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_query_pattern();
  PROTOBUF_NODISCARD std::string* release_query_pattern();
  void set_allocated_query_pattern(std::string* value);

  private:
  const std::string& _internal_query_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_pattern(
      const std::string& value);
  std::string* _internal_mutable_query_pattern();

  public:
  // uint64 time = 4;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // .SystemLogsQuery.QueryType type = 1;
  void clear_type() ;
  ::SystemLogsQuery_QueryType type() const;
  void set_type(::SystemLogsQuery_QueryType value);

  private:
  ::SystemLogsQuery_QueryType _internal_type() const;
  void _internal_set_type(::SystemLogsQuery_QueryType value);

  public:
  // @@protoc_insertion_point(class_scope:SystemLogsQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      37, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SystemLogsQuery_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SystemLogsQuery& from_msg);
    ::google::protobuf::RepeatedPtrField< ::LogEntry > log_entries_;
    ::google::protobuf::internal::ArenaStringPtr query_pattern_;
    ::uint64_t time_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Reboot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Reboot) */ {
 public:
  inline Reboot() : Reboot(nullptr) {}
  ~Reboot() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Reboot(
      ::google::protobuf::internal::ConstantInitialized);

  inline Reboot(const Reboot& from) : Reboot(nullptr, from) {}
  inline Reboot(Reboot&& from) noexcept
      : Reboot(nullptr, std::move(from)) {}
  inline Reboot& operator=(const Reboot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reboot& operator=(Reboot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reboot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reboot* internal_default_instance() {
    return reinterpret_cast<const Reboot*>(
        &_Reboot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(Reboot& a, Reboot& b) { a.Swap(&b); }
  inline void Swap(Reboot* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reboot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reboot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Reboot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Reboot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Reboot& from) { Reboot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Reboot* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Reboot"; }

 protected:
  explicit Reboot(::google::protobuf::Arena* arena);
  Reboot(::google::protobuf::Arena* arena, const Reboot& from);
  Reboot(::google::protobuf::Arena* arena, Reboot&& from) noexcept
      : Reboot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WeeklyRebootSchedule = Reboot_WeeklyRebootSchedule;

  // accessors -------------------------------------------------------
  enum : int {
    kSchedulesFieldNumber = 3,
    kRebootNowFieldNumber = 1,
    kEnableCustomRebootFieldNumber = 2,
    kResetFieldNumber = 4,
  };
  // repeated .Reboot.WeeklyRebootSchedule schedules = 3;
  int schedules_size() const;
  private:
  int _internal_schedules_size() const;

  public:
  void clear_schedules() ;
  ::Reboot_WeeklyRebootSchedule* mutable_schedules(int index);
  ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>* mutable_schedules();

  private:
  const ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>& _internal_schedules() const;
  ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>* _internal_mutable_schedules();
  public:
  const ::Reboot_WeeklyRebootSchedule& schedules(int index) const;
  ::Reboot_WeeklyRebootSchedule* add_schedules();
  const ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>& schedules() const;
  // bool reboot_now = 1;
  void clear_reboot_now() ;
  bool reboot_now() const;
  void set_reboot_now(bool value);

  private:
  bool _internal_reboot_now() const;
  void _internal_set_reboot_now(bool value);

  public:
  // bool enable_custom_reboot = 2;
  void clear_enable_custom_reboot() ;
  bool enable_custom_reboot() const;
  void set_enable_custom_reboot(bool value);

  private:
  bool _internal_enable_custom_reboot() const;
  void _internal_set_enable_custom_reboot(bool value);

  public:
  // bool reset = 4;
  void clear_reset() ;
  bool reset() const;
  void set_reset(bool value);

  private:
  bool _internal_reset() const;
  void _internal_set_reset(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Reboot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Reboot_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Reboot& from_msg);
    ::google::protobuf::RepeatedPtrField< ::Reboot_WeeklyRebootSchedule > schedules_;
    bool reboot_now_;
    bool enable_custom_reboot_;
    bool reset_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PresetList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PresetList) */ {
 public:
  inline PresetList() : PresetList(nullptr) {}
  ~PresetList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PresetList(
      ::google::protobuf::internal::ConstantInitialized);

  inline PresetList(const PresetList& from) : PresetList(nullptr, from) {}
  inline PresetList(PresetList&& from) noexcept
      : PresetList(nullptr, std::move(from)) {}
  inline PresetList& operator=(const PresetList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresetList& operator=(PresetList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PresetList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresetList* internal_default_instance() {
    return reinterpret_cast<const PresetList*>(
        &_PresetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(PresetList& a, PresetList& b) { a.Swap(&b); }
  inline void Swap(PresetList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresetList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresetList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PresetList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PresetList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PresetList& from) { PresetList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PresetList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PresetList"; }

 protected:
  explicit PresetList(::google::protobuf::Arena* arena);
  PresetList(::google::protobuf::Arena* arena, const PresetList& from);
  PresetList(::google::protobuf::Arena* arena, PresetList&& from) noexcept
      : PresetList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPresetPositionsFieldNumber = 1,
  };
  // repeated .PresetPosition preset_positions = 1;
  int preset_positions_size() const;
  private:
  int _internal_preset_positions_size() const;

  public:
  void clear_preset_positions() ;
  ::PresetPosition* mutable_preset_positions(int index);
  ::google::protobuf::RepeatedPtrField<::PresetPosition>* mutable_preset_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::PresetPosition>& _internal_preset_positions() const;
  ::google::protobuf::RepeatedPtrField<::PresetPosition>* _internal_mutable_preset_positions();
  public:
  const ::PresetPosition& preset_positions(int index) const;
  ::PresetPosition* add_preset_positions();
  const ::google::protobuf::RepeatedPtrField<::PresetPosition>& preset_positions() const;
  // @@protoc_insertion_point(class_scope:PresetList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PresetList_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PresetList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::PresetPosition > preset_positions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class ImageEnhancement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ImageEnhancement) */ {
 public:
  inline ImageEnhancement() : ImageEnhancement(nullptr) {}
  ~ImageEnhancement() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImageEnhancement(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImageEnhancement(const ImageEnhancement& from) : ImageEnhancement(nullptr, from) {}
  inline ImageEnhancement(ImageEnhancement&& from) noexcept
      : ImageEnhancement(nullptr, std::move(from)) {}
  inline ImageEnhancement& operator=(const ImageEnhancement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageEnhancement& operator=(ImageEnhancement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageEnhancement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageEnhancement* internal_default_instance() {
    return reinterpret_cast<const ImageEnhancement*>(
        &_ImageEnhancement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ImageEnhancement& a, ImageEnhancement& b) { a.Swap(&b); }
  inline void Swap(ImageEnhancement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageEnhancement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageEnhancement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImageEnhancement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImageEnhancement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImageEnhancement& from) { ImageEnhancement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImageEnhancement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ImageEnhancement"; }

 protected:
  explicit ImageEnhancement(::google::protobuf::Arena* arena);
  ImageEnhancement(::google::protobuf::Arena* arena, const ImageEnhancement& from);
  ImageEnhancement(::google::protobuf::Arena* arena, ImageEnhancement&& from) noexcept
      : ImageEnhancement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoiseReductionFieldNumber = 1,
    kFogEnhancementFieldNumber = 2,
    kStabilizationFieldNumber = 3,
    kGrayRangeFieldNumber = 4,
  };
  // .NoiseReduction noise_reduction = 1;
  bool has_noise_reduction() const;
  void clear_noise_reduction() ;
  const ::NoiseReduction& noise_reduction() const;
  PROTOBUF_NODISCARD ::NoiseReduction* release_noise_reduction();
  ::NoiseReduction* mutable_noise_reduction();
  void set_allocated_noise_reduction(::NoiseReduction* value);
  void unsafe_arena_set_allocated_noise_reduction(::NoiseReduction* value);
  ::NoiseReduction* unsafe_arena_release_noise_reduction();

  private:
  const ::NoiseReduction& _internal_noise_reduction() const;
  ::NoiseReduction* _internal_mutable_noise_reduction();

  public:
  // bool fog_enhancement = 2;
  void clear_fog_enhancement() ;
  bool fog_enhancement() const;
  void set_fog_enhancement(bool value);

  private:
  bool _internal_fog_enhancement() const;
  void _internal_set_fog_enhancement(bool value);

  public:
  // bool stabilization = 3;
  void clear_stabilization() ;
  bool stabilization() const;
  void set_stabilization(bool value);

  private:
  bool _internal_stabilization() const;
  void _internal_set_stabilization(bool value);

  public:
  // int32 gray_range = 4;
  void clear_gray_range() ;
  ::int32_t gray_range() const;
  void set_gray_range(::int32_t value);

  private:
  ::int32_t _internal_gray_range() const;
  void _internal_set_gray_range(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ImageEnhancement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ImageEnhancement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ImageEnhancement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NoiseReduction* noise_reduction_;
    bool fog_enhancement_;
    bool stabilization_;
    ::int32_t gray_range_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class CruiseGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CruiseGroup) */ {
 public:
  inline CruiseGroup() : CruiseGroup(nullptr) {}
  ~CruiseGroup() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CruiseGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline CruiseGroup(const CruiseGroup& from) : CruiseGroup(nullptr, from) {}
  inline CruiseGroup(CruiseGroup&& from) noexcept
      : CruiseGroup(nullptr, std::move(from)) {}
  inline CruiseGroup& operator=(const CruiseGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CruiseGroup& operator=(CruiseGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CruiseGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CruiseGroup* internal_default_instance() {
    return reinterpret_cast<const CruiseGroup*>(
        &_CruiseGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(CruiseGroup& a, CruiseGroup& b) { a.Swap(&b); }
  inline void Swap(CruiseGroup* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CruiseGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CruiseGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CruiseGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CruiseGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CruiseGroup& from) { CruiseGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CruiseGroup* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CruiseGroup"; }

 protected:
  explicit CruiseGroup(::google::protobuf::Arena* arena);
  CruiseGroup(::google::protobuf::Arena* arena, const CruiseGroup& from);
  CruiseGroup(::google::protobuf::Arena* arena, CruiseGroup&& from) noexcept
      : CruiseGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPresetPositionsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .PresetPosition preset_positions = 2;
  int preset_positions_size() const;
  private:
  int _internal_preset_positions_size() const;

  public:
  void clear_preset_positions() ;
  ::PresetPosition* mutable_preset_positions(int index);
  ::google::protobuf::RepeatedPtrField<::PresetPosition>* mutable_preset_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::PresetPosition>& _internal_preset_positions() const;
  ::google::protobuf::RepeatedPtrField<::PresetPosition>* _internal_mutable_preset_positions();
  public:
  const ::PresetPosition& preset_positions(int index) const;
  ::PresetPosition* add_preset_positions();
  const ::google::protobuf::RepeatedPtrField<::PresetPosition>& preset_positions() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:CruiseGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      24, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CruiseGroup_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CruiseGroup& from_msg);
    ::google::protobuf::RepeatedPtrField< ::PresetPosition > preset_positions_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class AlarmSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AlarmSettings) */ {
 public:
  inline AlarmSettings() : AlarmSettings(nullptr) {}
  ~AlarmSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlarmSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline AlarmSettings(const AlarmSettings& from) : AlarmSettings(nullptr, from) {}
  inline AlarmSettings(AlarmSettings&& from) noexcept
      : AlarmSettings(nullptr, std::move(from)) {}
  inline AlarmSettings& operator=(const AlarmSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmSettings& operator=(AlarmSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmSettings* internal_default_instance() {
    return reinterpret_cast<const AlarmSettings*>(
        &_AlarmSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(AlarmSettings& a, AlarmSettings& b) { a.Swap(&b); }
  inline void Swap(AlarmSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AlarmSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlarmSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlarmSettings& from) { AlarmSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlarmSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "AlarmSettings"; }

 protected:
  explicit AlarmSettings(::google::protobuf::Arena* arena);
  AlarmSettings(::google::protobuf::Arena* arena, const AlarmSettings& from);
  AlarmSettings(::google::protobuf::Arena* arena, AlarmSettings&& from) noexcept
      : AlarmSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AlarmType = AlarmSettings_AlarmType;
  static constexpr AlarmType MOTION = AlarmSettings_AlarmType_MOTION;
  static constexpr AlarmType COVER = AlarmSettings_AlarmType_COVER;
  static inline bool AlarmType_IsValid(int value) {
    return AlarmSettings_AlarmType_IsValid(value);
  }
  static constexpr AlarmType AlarmType_MIN = AlarmSettings_AlarmType_AlarmType_MIN;
  static constexpr AlarmType AlarmType_MAX = AlarmSettings_AlarmType_AlarmType_MAX;
  static constexpr int AlarmType_ARRAYSIZE = AlarmSettings_AlarmType_AlarmType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AlarmType_descriptor() {
    return AlarmSettings_AlarmType_descriptor();
  }
  template <typename T>
  static inline const std::string& AlarmType_Name(T value) {
    return AlarmSettings_AlarmType_Name(value);
  }
  static inline bool AlarmType_Parse(absl::string_view name, AlarmType* value) {
    return AlarmSettings_AlarmType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kAreasFieldNumber = 2,
    kSetupTimeFieldNumber = 3,
    kDetectionAreasFieldNumber = 12,
    kEmailAddressFieldNumber = 9,
    kEnabledFieldNumber = 1,
    kRecordVideoFieldNumber = 4,
    kAlarmOutputFieldNumber = 6,
    kSendEmailFieldNumber = 8,
    kRecordDelayFieldNumber = 5,
    kOutputDelayFieldNumber = 7,
    kSnapshotFieldNumber = 10,
    kSnapshotIntervalFieldNumber = 11,
    kAlarmTypeFieldNumber = 13,
  };
  // repeated .DetectionArea areas = 2;
  int areas_size() const;
  private:
  int _internal_areas_size() const;

  public:
  void clear_areas() ;
  ::DetectionArea* mutable_areas(int index);
  ::google::protobuf::RepeatedPtrField<::DetectionArea>* mutable_areas();

  private:
  const ::google::protobuf::RepeatedPtrField<::DetectionArea>& _internal_areas() const;
  ::google::protobuf::RepeatedPtrField<::DetectionArea>* _internal_mutable_areas();
  public:
  const ::DetectionArea& areas(int index) const;
  ::DetectionArea* add_areas();
  const ::google::protobuf::RepeatedPtrField<::DetectionArea>& areas() const;
  // repeated string setup_time = 3;
  int setup_time_size() const;
  private:
  int _internal_setup_time_size() const;

  public:
  void clear_setup_time() ;
  const std::string& setup_time(int index) const;
  std::string* mutable_setup_time(int index);
  void set_setup_time(int index, const std::string& value);
  void set_setup_time(int index, std::string&& value);
  void set_setup_time(int index, const char* value);
  void set_setup_time(int index, const char* value, std::size_t size);
  void set_setup_time(int index, absl::string_view value);
  std::string* add_setup_time();
  void add_setup_time(const std::string& value);
  void add_setup_time(std::string&& value);
  void add_setup_time(const char* value);
  void add_setup_time(const char* value, std::size_t size);
  void add_setup_time(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& setup_time() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_setup_time();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_setup_time() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_setup_time();

  public:
  // repeated .DetectionArea detection_areas = 12;
  int detection_areas_size() const;
  private:
  int _internal_detection_areas_size() const;

  public:
  void clear_detection_areas() ;
  ::DetectionArea* mutable_detection_areas(int index);
  ::google::protobuf::RepeatedPtrField<::DetectionArea>* mutable_detection_areas();

  private:
  const ::google::protobuf::RepeatedPtrField<::DetectionArea>& _internal_detection_areas() const;
  ::google::protobuf::RepeatedPtrField<::DetectionArea>* _internal_mutable_detection_areas();
  public:
  const ::DetectionArea& detection_areas(int index) const;
  ::DetectionArea* add_detection_areas();
  const ::google::protobuf::RepeatedPtrField<::DetectionArea>& detection_areas() const;
  // string email_address = 9;
  void clear_email_address() ;
  const std::string& email_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email_address(Arg_&& arg, Args_... args);
  std::string* mutable_email_address();
  PROTOBUF_NODISCARD std::string* release_email_address();
  void set_allocated_email_address(std::string* value);

  private:
  const std::string& _internal_email_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_address(
      const std::string& value);
  std::string* _internal_mutable_email_address();

  public:
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // bool record_video = 4;
  void clear_record_video() ;
  bool record_video() const;
  void set_record_video(bool value);

  private:
  bool _internal_record_video() const;
  void _internal_set_record_video(bool value);

  public:
  // bool alarm_output = 6;
  void clear_alarm_output() ;
  bool alarm_output() const;
  void set_alarm_output(bool value);

  private:
  bool _internal_alarm_output() const;
  void _internal_set_alarm_output(bool value);

  public:
  // bool send_email = 8;
  void clear_send_email() ;
  bool send_email() const;
  void set_send_email(bool value);

  private:
  bool _internal_send_email() const;
  void _internal_set_send_email(bool value);

  public:
  // int32 record_delay = 5;
  void clear_record_delay() ;
  ::int32_t record_delay() const;
  void set_record_delay(::int32_t value);

  private:
  ::int32_t _internal_record_delay() const;
  void _internal_set_record_delay(::int32_t value);

  public:
  // int32 output_delay = 7;
  void clear_output_delay() ;
  ::int32_t output_delay() const;
  void set_output_delay(::int32_t value);

  private:
  ::int32_t _internal_output_delay() const;
  void _internal_set_output_delay(::int32_t value);

  public:
  // bool snapshot = 10;
  void clear_snapshot() ;
  bool snapshot() const;
  void set_snapshot(bool value);

  private:
  bool _internal_snapshot() const;
  void _internal_set_snapshot(bool value);

  public:
  // int32 snapshot_interval = 11;
  void clear_snapshot_interval() ;
  ::int32_t snapshot_interval() const;
  void set_snapshot_interval(::int32_t value);

  private:
  ::int32_t _internal_snapshot_interval() const;
  void _internal_set_snapshot_interval(::int32_t value);

  public:
  // .AlarmSettings.AlarmType alarm_type = 13;
  void clear_alarm_type() ;
  ::AlarmSettings_AlarmType alarm_type() const;
  void set_alarm_type(::AlarmSettings_AlarmType value);

  private:
  ::AlarmSettings_AlarmType _internal_alarm_type() const;
  void _internal_set_alarm_type(::AlarmSettings_AlarmType value);

  public:
  // @@protoc_insertion_point(class_scope:AlarmSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 2,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AlarmSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AlarmSettings& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DetectionArea > areas_;
    ::google::protobuf::RepeatedPtrField<std::string> setup_time_;
    ::google::protobuf::RepeatedPtrField< ::DetectionArea > detection_areas_;
    ::google::protobuf::internal::ArenaStringPtr email_address_;
    bool enabled_;
    bool record_video_;
    bool alarm_output_;
    bool send_email_;
    ::int32_t record_delay_;
    ::int32_t output_delay_;
    bool snapshot_;
    ::int32_t snapshot_interval_;
    int alarm_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class PTZControlProtol final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PTZControlProtol) */ {
 public:
  inline PTZControlProtol() : PTZControlProtol(nullptr) {}
  ~PTZControlProtol() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PTZControlProtol(
      ::google::protobuf::internal::ConstantInitialized);

  inline PTZControlProtol(const PTZControlProtol& from) : PTZControlProtol(nullptr, from) {}
  inline PTZControlProtol(PTZControlProtol&& from) noexcept
      : PTZControlProtol(nullptr, std::move(from)) {}
  inline PTZControlProtol& operator=(const PTZControlProtol& from) {
    CopyFrom(from);
    return *this;
  }
  inline PTZControlProtol& operator=(PTZControlProtol&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PTZControlProtol& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kDevice = 4,
    kMediaSettings = 5,
    kImageSettings = 6,
    kImageEnhancement = 7,
    kVideoAdjustment = 8,
    kExposureSettings = 9,
    kDayNightSwitchSettings = 10,
    kWhiteBalanceSettings = 11,
    kInfraredImageSettings = 12,
    kOsdSettings = 13,
    kIpSettings = 14,
    kPortSettings = 15,
    kFtpSettings = 16,
    kPlatformSettings = 17,
    kAlarmSettings = 18,
    kGasLeakageAlarmSettings = 19,
    kUserAccountSettings = 20,
    kLoginSecuritySettings = 21,
    kTimeSettings = 22,
    kSystemInfo = 23,
    kReboot = 24,
    kSystemLogsQuery = 25,
    kLogEntry = 26,
    kPresetPositionOp = 27,
    kPresetList = 28,
    kTrackingScan = 29,
    kTrackingScanCmd = 30,
    kLinearScanSettings = 31,
    kLinearScanControl = 32,
    kRotation = 33,
    kLensControl = 34,
    kAccessoryControl = 35,
    kScanning = 36,
    kImageModeMessage = 37,
    CONTENT_NOT_SET = 0,
  };
  static inline const PTZControlProtol* internal_default_instance() {
    return reinterpret_cast<const PTZControlProtol*>(
        &_PTZControlProtol_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(PTZControlProtol& a, PTZControlProtol& b) { a.Swap(&b); }
  inline void Swap(PTZControlProtol* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PTZControlProtol* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PTZControlProtol* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PTZControlProtol>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PTZControlProtol& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PTZControlProtol& from) { PTZControlProtol::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PTZControlProtol* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PTZControlProtol"; }

 protected:
  explicit PTZControlProtol(::google::protobuf::Arena* arena);
  PTZControlProtol(::google::protobuf::Arena* arena, const PTZControlProtol& from);
  PTZControlProtol(::google::protobuf::Arena* arena, PTZControlProtol&& from) noexcept
      : PTZControlProtol(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kTypeFieldNumber = 1,
    kDeviceFieldNumber = 4,
    kMediaSettingsFieldNumber = 5,
    kImageSettingsFieldNumber = 6,
    kImageEnhancementFieldNumber = 7,
    kVideoAdjustmentFieldNumber = 8,
    kExposureSettingsFieldNumber = 9,
    kDayNightSwitchSettingsFieldNumber = 10,
    kWhiteBalanceSettingsFieldNumber = 11,
    kInfraredImageSettingsFieldNumber = 12,
    kOsdSettingsFieldNumber = 13,
    kIpSettingsFieldNumber = 14,
    kPortSettingsFieldNumber = 15,
    kFtpSettingsFieldNumber = 16,
    kPlatformSettingsFieldNumber = 17,
    kAlarmSettingsFieldNumber = 18,
    kGasLeakageAlarmSettingsFieldNumber = 19,
    kUserAccountSettingsFieldNumber = 20,
    kLoginSecuritySettingsFieldNumber = 21,
    kTimeSettingsFieldNumber = 22,
    kSystemInfoFieldNumber = 23,
    kRebootFieldNumber = 24,
    kSystemLogsQueryFieldNumber = 25,
    kLogEntryFieldNumber = 26,
    kPresetPositionOpFieldNumber = 27,
    kPresetListFieldNumber = 28,
    kTrackingScanFieldNumber = 29,
    kTrackingScanCmdFieldNumber = 30,
    kLinearScanSettingsFieldNumber = 31,
    kLinearScanControlFieldNumber = 32,
    kRotationFieldNumber = 33,
    kLensControlFieldNumber = 34,
    kAccessoryControlFieldNumber = 35,
    kScanningFieldNumber = 36,
    kImageModeMessageFieldNumber = 37,
  };
  // string device_id = 2;
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // uint64 timestamp = 3;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // .MessageType type = 1;
  void clear_type() ;
  ::MessageType type() const;
  void set_type(::MessageType value);

  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);

  public:
  // .PTZDevice device = 4;
  bool has_device() const;
  private:
  bool _internal_has_device() const;

  public:
  void clear_device() ;
  const ::PTZDevice& device() const;
  PROTOBUF_NODISCARD ::PTZDevice* release_device();
  ::PTZDevice* mutable_device();
  void set_allocated_device(::PTZDevice* value);
  void unsafe_arena_set_allocated_device(::PTZDevice* value);
  ::PTZDevice* unsafe_arena_release_device();

  private:
  const ::PTZDevice& _internal_device() const;
  ::PTZDevice* _internal_mutable_device();

  public:
  // .MediaSettings media_settings = 5;
  bool has_media_settings() const;
  private:
  bool _internal_has_media_settings() const;

  public:
  void clear_media_settings() ;
  const ::MediaSettings& media_settings() const;
  PROTOBUF_NODISCARD ::MediaSettings* release_media_settings();
  ::MediaSettings* mutable_media_settings();
  void set_allocated_media_settings(::MediaSettings* value);
  void unsafe_arena_set_allocated_media_settings(::MediaSettings* value);
  ::MediaSettings* unsafe_arena_release_media_settings();

  private:
  const ::MediaSettings& _internal_media_settings() const;
  ::MediaSettings* _internal_mutable_media_settings();

  public:
  // .ImageSettings image_settings = 6;
  bool has_image_settings() const;
  private:
  bool _internal_has_image_settings() const;

  public:
  void clear_image_settings() ;
  const ::ImageSettings& image_settings() const;
  PROTOBUF_NODISCARD ::ImageSettings* release_image_settings();
  ::ImageSettings* mutable_image_settings();
  void set_allocated_image_settings(::ImageSettings* value);
  void unsafe_arena_set_allocated_image_settings(::ImageSettings* value);
  ::ImageSettings* unsafe_arena_release_image_settings();

  private:
  const ::ImageSettings& _internal_image_settings() const;
  ::ImageSettings* _internal_mutable_image_settings();

  public:
  // .ImageEnhancement image_enhancement = 7;
  bool has_image_enhancement() const;
  private:
  bool _internal_has_image_enhancement() const;

  public:
  void clear_image_enhancement() ;
  const ::ImageEnhancement& image_enhancement() const;
  PROTOBUF_NODISCARD ::ImageEnhancement* release_image_enhancement();
  ::ImageEnhancement* mutable_image_enhancement();
  void set_allocated_image_enhancement(::ImageEnhancement* value);
  void unsafe_arena_set_allocated_image_enhancement(::ImageEnhancement* value);
  ::ImageEnhancement* unsafe_arena_release_image_enhancement();

  private:
  const ::ImageEnhancement& _internal_image_enhancement() const;
  ::ImageEnhancement* _internal_mutable_image_enhancement();

  public:
  // .VideoAdjustment video_adjustment = 8;
  bool has_video_adjustment() const;
  private:
  bool _internal_has_video_adjustment() const;

  public:
  void clear_video_adjustment() ;
  const ::VideoAdjustment& video_adjustment() const;
  PROTOBUF_NODISCARD ::VideoAdjustment* release_video_adjustment();
  ::VideoAdjustment* mutable_video_adjustment();
  void set_allocated_video_adjustment(::VideoAdjustment* value);
  void unsafe_arena_set_allocated_video_adjustment(::VideoAdjustment* value);
  ::VideoAdjustment* unsafe_arena_release_video_adjustment();

  private:
  const ::VideoAdjustment& _internal_video_adjustment() const;
  ::VideoAdjustment* _internal_mutable_video_adjustment();

  public:
  // .ExposureSettings exposure_settings = 9;
  bool has_exposure_settings() const;
  private:
  bool _internal_has_exposure_settings() const;

  public:
  void clear_exposure_settings() ;
  const ::ExposureSettings& exposure_settings() const;
  PROTOBUF_NODISCARD ::ExposureSettings* release_exposure_settings();
  ::ExposureSettings* mutable_exposure_settings();
  void set_allocated_exposure_settings(::ExposureSettings* value);
  void unsafe_arena_set_allocated_exposure_settings(::ExposureSettings* value);
  ::ExposureSettings* unsafe_arena_release_exposure_settings();

  private:
  const ::ExposureSettings& _internal_exposure_settings() const;
  ::ExposureSettings* _internal_mutable_exposure_settings();

  public:
  // .DayNightSwitchSettings day_night_switch_settings = 10;
  bool has_day_night_switch_settings() const;
  private:
  bool _internal_has_day_night_switch_settings() const;

  public:
  void clear_day_night_switch_settings() ;
  const ::DayNightSwitchSettings& day_night_switch_settings() const;
  PROTOBUF_NODISCARD ::DayNightSwitchSettings* release_day_night_switch_settings();
  ::DayNightSwitchSettings* mutable_day_night_switch_settings();
  void set_allocated_day_night_switch_settings(::DayNightSwitchSettings* value);
  void unsafe_arena_set_allocated_day_night_switch_settings(::DayNightSwitchSettings* value);
  ::DayNightSwitchSettings* unsafe_arena_release_day_night_switch_settings();

  private:
  const ::DayNightSwitchSettings& _internal_day_night_switch_settings() const;
  ::DayNightSwitchSettings* _internal_mutable_day_night_switch_settings();

  public:
  // .WhiteBalanceSettings white_balance_settings = 11;
  bool has_white_balance_settings() const;
  private:
  bool _internal_has_white_balance_settings() const;

  public:
  void clear_white_balance_settings() ;
  const ::WhiteBalanceSettings& white_balance_settings() const;
  PROTOBUF_NODISCARD ::WhiteBalanceSettings* release_white_balance_settings();
  ::WhiteBalanceSettings* mutable_white_balance_settings();
  void set_allocated_white_balance_settings(::WhiteBalanceSettings* value);
  void unsafe_arena_set_allocated_white_balance_settings(::WhiteBalanceSettings* value);
  ::WhiteBalanceSettings* unsafe_arena_release_white_balance_settings();

  private:
  const ::WhiteBalanceSettings& _internal_white_balance_settings() const;
  ::WhiteBalanceSettings* _internal_mutable_white_balance_settings();

  public:
  // .InfraredImageSettings infrared_image_settings = 12;
  bool has_infrared_image_settings() const;
  private:
  bool _internal_has_infrared_image_settings() const;

  public:
  void clear_infrared_image_settings() ;
  const ::InfraredImageSettings& infrared_image_settings() const;
  PROTOBUF_NODISCARD ::InfraredImageSettings* release_infrared_image_settings();
  ::InfraredImageSettings* mutable_infrared_image_settings();
  void set_allocated_infrared_image_settings(::InfraredImageSettings* value);
  void unsafe_arena_set_allocated_infrared_image_settings(::InfraredImageSettings* value);
  ::InfraredImageSettings* unsafe_arena_release_infrared_image_settings();

  private:
  const ::InfraredImageSettings& _internal_infrared_image_settings() const;
  ::InfraredImageSettings* _internal_mutable_infrared_image_settings();

  public:
  // .OSDSettings osd_settings = 13;
  bool has_osd_settings() const;
  private:
  bool _internal_has_osd_settings() const;

  public:
  void clear_osd_settings() ;
  const ::OSDSettings& osd_settings() const;
  PROTOBUF_NODISCARD ::OSDSettings* release_osd_settings();
  ::OSDSettings* mutable_osd_settings();
  void set_allocated_osd_settings(::OSDSettings* value);
  void unsafe_arena_set_allocated_osd_settings(::OSDSettings* value);
  ::OSDSettings* unsafe_arena_release_osd_settings();

  private:
  const ::OSDSettings& _internal_osd_settings() const;
  ::OSDSettings* _internal_mutable_osd_settings();

  public:
  // .IPSettings ip_settings = 14;
  bool has_ip_settings() const;
  private:
  bool _internal_has_ip_settings() const;

  public:
  void clear_ip_settings() ;
  const ::IPSettings& ip_settings() const;
  PROTOBUF_NODISCARD ::IPSettings* release_ip_settings();
  ::IPSettings* mutable_ip_settings();
  void set_allocated_ip_settings(::IPSettings* value);
  void unsafe_arena_set_allocated_ip_settings(::IPSettings* value);
  ::IPSettings* unsafe_arena_release_ip_settings();

  private:
  const ::IPSettings& _internal_ip_settings() const;
  ::IPSettings* _internal_mutable_ip_settings();

  public:
  // .PortSettings port_settings = 15;
  bool has_port_settings() const;
  private:
  bool _internal_has_port_settings() const;

  public:
  void clear_port_settings() ;
  const ::PortSettings& port_settings() const;
  PROTOBUF_NODISCARD ::PortSettings* release_port_settings();
  ::PortSettings* mutable_port_settings();
  void set_allocated_port_settings(::PortSettings* value);
  void unsafe_arena_set_allocated_port_settings(::PortSettings* value);
  ::PortSettings* unsafe_arena_release_port_settings();

  private:
  const ::PortSettings& _internal_port_settings() const;
  ::PortSettings* _internal_mutable_port_settings();

  public:
  // .FTPSettings ftp_settings = 16;
  bool has_ftp_settings() const;
  private:
  bool _internal_has_ftp_settings() const;

  public:
  void clear_ftp_settings() ;
  const ::FTPSettings& ftp_settings() const;
  PROTOBUF_NODISCARD ::FTPSettings* release_ftp_settings();
  ::FTPSettings* mutable_ftp_settings();
  void set_allocated_ftp_settings(::FTPSettings* value);
  void unsafe_arena_set_allocated_ftp_settings(::FTPSettings* value);
  ::FTPSettings* unsafe_arena_release_ftp_settings();

  private:
  const ::FTPSettings& _internal_ftp_settings() const;
  ::FTPSettings* _internal_mutable_ftp_settings();

  public:
  // .PlatformSettings platform_settings = 17;
  bool has_platform_settings() const;
  private:
  bool _internal_has_platform_settings() const;

  public:
  void clear_platform_settings() ;
  const ::PlatformSettings& platform_settings() const;
  PROTOBUF_NODISCARD ::PlatformSettings* release_platform_settings();
  ::PlatformSettings* mutable_platform_settings();
  void set_allocated_platform_settings(::PlatformSettings* value);
  void unsafe_arena_set_allocated_platform_settings(::PlatformSettings* value);
  ::PlatformSettings* unsafe_arena_release_platform_settings();

  private:
  const ::PlatformSettings& _internal_platform_settings() const;
  ::PlatformSettings* _internal_mutable_platform_settings();

  public:
  // .AlarmSettings alarm_settings = 18;
  bool has_alarm_settings() const;
  private:
  bool _internal_has_alarm_settings() const;

  public:
  void clear_alarm_settings() ;
  const ::AlarmSettings& alarm_settings() const;
  PROTOBUF_NODISCARD ::AlarmSettings* release_alarm_settings();
  ::AlarmSettings* mutable_alarm_settings();
  void set_allocated_alarm_settings(::AlarmSettings* value);
  void unsafe_arena_set_allocated_alarm_settings(::AlarmSettings* value);
  ::AlarmSettings* unsafe_arena_release_alarm_settings();

  private:
  const ::AlarmSettings& _internal_alarm_settings() const;
  ::AlarmSettings* _internal_mutable_alarm_settings();

  public:
  // .GasLeakageAlarmSettings gas_leakage_alarm_settings = 19;
  bool has_gas_leakage_alarm_settings() const;
  private:
  bool _internal_has_gas_leakage_alarm_settings() const;

  public:
  void clear_gas_leakage_alarm_settings() ;
  const ::GasLeakageAlarmSettings& gas_leakage_alarm_settings() const;
  PROTOBUF_NODISCARD ::GasLeakageAlarmSettings* release_gas_leakage_alarm_settings();
  ::GasLeakageAlarmSettings* mutable_gas_leakage_alarm_settings();
  void set_allocated_gas_leakage_alarm_settings(::GasLeakageAlarmSettings* value);
  void unsafe_arena_set_allocated_gas_leakage_alarm_settings(::GasLeakageAlarmSettings* value);
  ::GasLeakageAlarmSettings* unsafe_arena_release_gas_leakage_alarm_settings();

  private:
  const ::GasLeakageAlarmSettings& _internal_gas_leakage_alarm_settings() const;
  ::GasLeakageAlarmSettings* _internal_mutable_gas_leakage_alarm_settings();

  public:
  // .UserAccountSettings user_account_settings = 20;
  bool has_user_account_settings() const;
  private:
  bool _internal_has_user_account_settings() const;

  public:
  void clear_user_account_settings() ;
  const ::UserAccountSettings& user_account_settings() const;
  PROTOBUF_NODISCARD ::UserAccountSettings* release_user_account_settings();
  ::UserAccountSettings* mutable_user_account_settings();
  void set_allocated_user_account_settings(::UserAccountSettings* value);
  void unsafe_arena_set_allocated_user_account_settings(::UserAccountSettings* value);
  ::UserAccountSettings* unsafe_arena_release_user_account_settings();

  private:
  const ::UserAccountSettings& _internal_user_account_settings() const;
  ::UserAccountSettings* _internal_mutable_user_account_settings();

  public:
  // .LoginSecuritySettings login_security_settings = 21;
  bool has_login_security_settings() const;
  private:
  bool _internal_has_login_security_settings() const;

  public:
  void clear_login_security_settings() ;
  const ::LoginSecuritySettings& login_security_settings() const;
  PROTOBUF_NODISCARD ::LoginSecuritySettings* release_login_security_settings();
  ::LoginSecuritySettings* mutable_login_security_settings();
  void set_allocated_login_security_settings(::LoginSecuritySettings* value);
  void unsafe_arena_set_allocated_login_security_settings(::LoginSecuritySettings* value);
  ::LoginSecuritySettings* unsafe_arena_release_login_security_settings();

  private:
  const ::LoginSecuritySettings& _internal_login_security_settings() const;
  ::LoginSecuritySettings* _internal_mutable_login_security_settings();

  public:
  // .TimeSettings time_settings = 22;
  bool has_time_settings() const;
  private:
  bool _internal_has_time_settings() const;

  public:
  void clear_time_settings() ;
  const ::TimeSettings& time_settings() const;
  PROTOBUF_NODISCARD ::TimeSettings* release_time_settings();
  ::TimeSettings* mutable_time_settings();
  void set_allocated_time_settings(::TimeSettings* value);
  void unsafe_arena_set_allocated_time_settings(::TimeSettings* value);
  ::TimeSettings* unsafe_arena_release_time_settings();

  private:
  const ::TimeSettings& _internal_time_settings() const;
  ::TimeSettings* _internal_mutable_time_settings();

  public:
  // .SystemInfo system_info = 23;
  bool has_system_info() const;
  private:
  bool _internal_has_system_info() const;

  public:
  void clear_system_info() ;
  const ::SystemInfo& system_info() const;
  PROTOBUF_NODISCARD ::SystemInfo* release_system_info();
  ::SystemInfo* mutable_system_info();
  void set_allocated_system_info(::SystemInfo* value);
  void unsafe_arena_set_allocated_system_info(::SystemInfo* value);
  ::SystemInfo* unsafe_arena_release_system_info();

  private:
  const ::SystemInfo& _internal_system_info() const;
  ::SystemInfo* _internal_mutable_system_info();

  public:
  // .Reboot reboot = 24;
  bool has_reboot() const;
  private:
  bool _internal_has_reboot() const;

  public:
  void clear_reboot() ;
  const ::Reboot& reboot() const;
  PROTOBUF_NODISCARD ::Reboot* release_reboot();
  ::Reboot* mutable_reboot();
  void set_allocated_reboot(::Reboot* value);
  void unsafe_arena_set_allocated_reboot(::Reboot* value);
  ::Reboot* unsafe_arena_release_reboot();

  private:
  const ::Reboot& _internal_reboot() const;
  ::Reboot* _internal_mutable_reboot();

  public:
  // .SystemLogsQuery system_logs_query = 25;
  bool has_system_logs_query() const;
  private:
  bool _internal_has_system_logs_query() const;

  public:
  void clear_system_logs_query() ;
  const ::SystemLogsQuery& system_logs_query() const;
  PROTOBUF_NODISCARD ::SystemLogsQuery* release_system_logs_query();
  ::SystemLogsQuery* mutable_system_logs_query();
  void set_allocated_system_logs_query(::SystemLogsQuery* value);
  void unsafe_arena_set_allocated_system_logs_query(::SystemLogsQuery* value);
  ::SystemLogsQuery* unsafe_arena_release_system_logs_query();

  private:
  const ::SystemLogsQuery& _internal_system_logs_query() const;
  ::SystemLogsQuery* _internal_mutable_system_logs_query();

  public:
  // .LogEntry log_entry = 26;
  bool has_log_entry() const;
  private:
  bool _internal_has_log_entry() const;

  public:
  void clear_log_entry() ;
  const ::LogEntry& log_entry() const;
  PROTOBUF_NODISCARD ::LogEntry* release_log_entry();
  ::LogEntry* mutable_log_entry();
  void set_allocated_log_entry(::LogEntry* value);
  void unsafe_arena_set_allocated_log_entry(::LogEntry* value);
  ::LogEntry* unsafe_arena_release_log_entry();

  private:
  const ::LogEntry& _internal_log_entry() const;
  ::LogEntry* _internal_mutable_log_entry();

  public:
  // .PresetPositionOp preset_position_op = 27;
  bool has_preset_position_op() const;
  private:
  bool _internal_has_preset_position_op() const;

  public:
  void clear_preset_position_op() ;
  const ::PresetPositionOp& preset_position_op() const;
  PROTOBUF_NODISCARD ::PresetPositionOp* release_preset_position_op();
  ::PresetPositionOp* mutable_preset_position_op();
  void set_allocated_preset_position_op(::PresetPositionOp* value);
  void unsafe_arena_set_allocated_preset_position_op(::PresetPositionOp* value);
  ::PresetPositionOp* unsafe_arena_release_preset_position_op();

  private:
  const ::PresetPositionOp& _internal_preset_position_op() const;
  ::PresetPositionOp* _internal_mutable_preset_position_op();

  public:
  // .PresetList preset_list = 28;
  bool has_preset_list() const;
  private:
  bool _internal_has_preset_list() const;

  public:
  void clear_preset_list() ;
  const ::PresetList& preset_list() const;
  PROTOBUF_NODISCARD ::PresetList* release_preset_list();
  ::PresetList* mutable_preset_list();
  void set_allocated_preset_list(::PresetList* value);
  void unsafe_arena_set_allocated_preset_list(::PresetList* value);
  ::PresetList* unsafe_arena_release_preset_list();

  private:
  const ::PresetList& _internal_preset_list() const;
  ::PresetList* _internal_mutable_preset_list();

  public:
  // .TrackingScan tracking_scan = 29;
  bool has_tracking_scan() const;
  private:
  bool _internal_has_tracking_scan() const;

  public:
  void clear_tracking_scan() ;
  const ::TrackingScan& tracking_scan() const;
  PROTOBUF_NODISCARD ::TrackingScan* release_tracking_scan();
  ::TrackingScan* mutable_tracking_scan();
  void set_allocated_tracking_scan(::TrackingScan* value);
  void unsafe_arena_set_allocated_tracking_scan(::TrackingScan* value);
  ::TrackingScan* unsafe_arena_release_tracking_scan();

  private:
  const ::TrackingScan& _internal_tracking_scan() const;
  ::TrackingScan* _internal_mutable_tracking_scan();

  public:
  // .TrackingScanCmd tracking_scan_cmd = 30;
  bool has_tracking_scan_cmd() const;
  private:
  bool _internal_has_tracking_scan_cmd() const;

  public:
  void clear_tracking_scan_cmd() ;
  const ::TrackingScanCmd& tracking_scan_cmd() const;
  PROTOBUF_NODISCARD ::TrackingScanCmd* release_tracking_scan_cmd();
  ::TrackingScanCmd* mutable_tracking_scan_cmd();
  void set_allocated_tracking_scan_cmd(::TrackingScanCmd* value);
  void unsafe_arena_set_allocated_tracking_scan_cmd(::TrackingScanCmd* value);
  ::TrackingScanCmd* unsafe_arena_release_tracking_scan_cmd();

  private:
  const ::TrackingScanCmd& _internal_tracking_scan_cmd() const;
  ::TrackingScanCmd* _internal_mutable_tracking_scan_cmd();

  public:
  // .LinearScanSettings linear_scan_settings = 31;
  bool has_linear_scan_settings() const;
  private:
  bool _internal_has_linear_scan_settings() const;

  public:
  void clear_linear_scan_settings() ;
  const ::LinearScanSettings& linear_scan_settings() const;
  PROTOBUF_NODISCARD ::LinearScanSettings* release_linear_scan_settings();
  ::LinearScanSettings* mutable_linear_scan_settings();
  void set_allocated_linear_scan_settings(::LinearScanSettings* value);
  void unsafe_arena_set_allocated_linear_scan_settings(::LinearScanSettings* value);
  ::LinearScanSettings* unsafe_arena_release_linear_scan_settings();

  private:
  const ::LinearScanSettings& _internal_linear_scan_settings() const;
  ::LinearScanSettings* _internal_mutable_linear_scan_settings();

  public:
  // .LinearScanControl linear_scan_control = 32;
  bool has_linear_scan_control() const;
  private:
  bool _internal_has_linear_scan_control() const;

  public:
  void clear_linear_scan_control() ;
  const ::LinearScanControl& linear_scan_control() const;
  PROTOBUF_NODISCARD ::LinearScanControl* release_linear_scan_control();
  ::LinearScanControl* mutable_linear_scan_control();
  void set_allocated_linear_scan_control(::LinearScanControl* value);
  void unsafe_arena_set_allocated_linear_scan_control(::LinearScanControl* value);
  ::LinearScanControl* unsafe_arena_release_linear_scan_control();

  private:
  const ::LinearScanControl& _internal_linear_scan_control() const;
  ::LinearScanControl* _internal_mutable_linear_scan_control();

  public:
  // .Rotation rotation = 33;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;

  public:
  void clear_rotation() ;
  const ::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::Rotation* release_rotation();
  ::Rotation* mutable_rotation();
  void set_allocated_rotation(::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::Rotation* value);
  ::Rotation* unsafe_arena_release_rotation();

  private:
  const ::Rotation& _internal_rotation() const;
  ::Rotation* _internal_mutable_rotation();

  public:
  // .LensControl lens_control = 34;
  bool has_lens_control() const;
  private:
  bool _internal_has_lens_control() const;

  public:
  void clear_lens_control() ;
  const ::LensControl& lens_control() const;
  PROTOBUF_NODISCARD ::LensControl* release_lens_control();
  ::LensControl* mutable_lens_control();
  void set_allocated_lens_control(::LensControl* value);
  void unsafe_arena_set_allocated_lens_control(::LensControl* value);
  ::LensControl* unsafe_arena_release_lens_control();

  private:
  const ::LensControl& _internal_lens_control() const;
  ::LensControl* _internal_mutable_lens_control();

  public:
  // .AccessoryControl accessory_control = 35;
  bool has_accessory_control() const;
  private:
  bool _internal_has_accessory_control() const;

  public:
  void clear_accessory_control() ;
  const ::AccessoryControl& accessory_control() const;
  PROTOBUF_NODISCARD ::AccessoryControl* release_accessory_control();
  ::AccessoryControl* mutable_accessory_control();
  void set_allocated_accessory_control(::AccessoryControl* value);
  void unsafe_arena_set_allocated_accessory_control(::AccessoryControl* value);
  ::AccessoryControl* unsafe_arena_release_accessory_control();

  private:
  const ::AccessoryControl& _internal_accessory_control() const;
  ::AccessoryControl* _internal_mutable_accessory_control();

  public:
  // .Scanning scanning = 36;
  bool has_scanning() const;
  private:
  bool _internal_has_scanning() const;

  public:
  void clear_scanning() ;
  const ::Scanning& scanning() const;
  PROTOBUF_NODISCARD ::Scanning* release_scanning();
  ::Scanning* mutable_scanning();
  void set_allocated_scanning(::Scanning* value);
  void unsafe_arena_set_allocated_scanning(::Scanning* value);
  ::Scanning* unsafe_arena_release_scanning();

  private:
  const ::Scanning& _internal_scanning() const;
  ::Scanning* _internal_mutable_scanning();

  public:
  // .ImageModeMessage image_mode_message = 37;
  bool has_image_mode_message() const;
  private:
  bool _internal_has_image_mode_message() const;

  public:
  void clear_image_mode_message() ;
  const ::ImageModeMessage& image_mode_message() const;
  PROTOBUF_NODISCARD ::ImageModeMessage* release_image_mode_message();
  ::ImageModeMessage* mutable_image_mode_message();
  void set_allocated_image_mode_message(::ImageModeMessage* value);
  void unsafe_arena_set_allocated_image_mode_message(::ImageModeMessage* value);
  ::ImageModeMessage* unsafe_arena_release_image_mode_message();

  private:
  const ::ImageModeMessage& _internal_image_mode_message() const;
  ::ImageModeMessage* _internal_mutable_image_mode_message();

  public:
  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:PTZControlProtol)
 private:
  class _Internal;
  void set_has_device();
  void set_has_media_settings();
  void set_has_image_settings();
  void set_has_image_enhancement();
  void set_has_video_adjustment();
  void set_has_exposure_settings();
  void set_has_day_night_switch_settings();
  void set_has_white_balance_settings();
  void set_has_infrared_image_settings();
  void set_has_osd_settings();
  void set_has_ip_settings();
  void set_has_port_settings();
  void set_has_ftp_settings();
  void set_has_platform_settings();
  void set_has_alarm_settings();
  void set_has_gas_leakage_alarm_settings();
  void set_has_user_account_settings();
  void set_has_login_security_settings();
  void set_has_time_settings();
  void set_has_system_info();
  void set_has_reboot();
  void set_has_system_logs_query();
  void set_has_log_entry();
  void set_has_preset_position_op();
  void set_has_preset_list();
  void set_has_tracking_scan();
  void set_has_tracking_scan_cmd();
  void set_has_linear_scan_settings();
  void set_has_linear_scan_control();
  void set_has_rotation();
  void set_has_lens_control();
  void set_has_accessory_control();
  void set_has_scanning();
  void set_has_image_mode_message();
  inline bool has_content() const;
  inline void clear_has_content();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 37, 34,
      66, 7>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PTZControlProtol_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PTZControlProtol& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::uint64_t timestamp_;
    int type_;
    union ContentUnion {
      constexpr ContentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PTZDevice* device_;
      ::MediaSettings* media_settings_;
      ::ImageSettings* image_settings_;
      ::ImageEnhancement* image_enhancement_;
      ::VideoAdjustment* video_adjustment_;
      ::ExposureSettings* exposure_settings_;
      ::DayNightSwitchSettings* day_night_switch_settings_;
      ::WhiteBalanceSettings* white_balance_settings_;
      ::InfraredImageSettings* infrared_image_settings_;
      ::OSDSettings* osd_settings_;
      ::IPSettings* ip_settings_;
      ::PortSettings* port_settings_;
      ::FTPSettings* ftp_settings_;
      ::PlatformSettings* platform_settings_;
      ::AlarmSettings* alarm_settings_;
      ::GasLeakageAlarmSettings* gas_leakage_alarm_settings_;
      ::UserAccountSettings* user_account_settings_;
      ::LoginSecuritySettings* login_security_settings_;
      ::TimeSettings* time_settings_;
      ::SystemInfo* system_info_;
      ::Reboot* reboot_;
      ::SystemLogsQuery* system_logs_query_;
      ::LogEntry* log_entry_;
      ::PresetPositionOp* preset_position_op_;
      ::PresetList* preset_list_;
      ::TrackingScan* tracking_scan_;
      ::TrackingScanCmd* tracking_scan_cmd_;
      ::LinearScanSettings* linear_scan_settings_;
      ::LinearScanControl* linear_scan_control_;
      ::Rotation* rotation_;
      ::LensControl* lens_control_;
      ::AccessoryControl* accessory_control_;
      ::Scanning* scanning_;
      ::ImageModeMessage* image_mode_message_;
    } content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interact_5fcmd_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PTZControlProtol

// .MessageType type = 1;
inline void PTZControlProtol::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::MessageType PTZControlProtol::type() const {
  // @@protoc_insertion_point(field_get:PTZControlProtol.type)
  return _internal_type();
}
inline void PTZControlProtol::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PTZControlProtol.type)
}
inline ::MessageType PTZControlProtol::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MessageType>(_impl_.type_);
}
inline void PTZControlProtol::_internal_set_type(::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string device_id = 2;
inline void PTZControlProtol::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& PTZControlProtol::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PTZControlProtol::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PTZControlProtol.device_id)
}
inline std::string* PTZControlProtol::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.device_id)
  return _s;
}
inline const std::string& PTZControlProtol::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_.Get();
}
inline void PTZControlProtol::_internal_set_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* PTZControlProtol::_internal_mutable_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* PTZControlProtol::release_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PTZControlProtol.device_id)
  return _impl_.device_id_.Release();
}
inline void PTZControlProtol::set_allocated_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_id_.IsDefault()) {
          _impl_.device_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTZControlProtol.device_id)
}

// uint64 timestamp = 3;
inline void PTZControlProtol::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PTZControlProtol::timestamp() const {
  // @@protoc_insertion_point(field_get:PTZControlProtol.timestamp)
  return _internal_timestamp();
}
inline void PTZControlProtol::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:PTZControlProtol.timestamp)
}
inline ::uint64_t PTZControlProtol::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void PTZControlProtol::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .PTZDevice device = 4;
inline bool PTZControlProtol::has_device() const {
  return content_case() == kDevice;
}
inline bool PTZControlProtol::_internal_has_device() const {
  return content_case() == kDevice;
}
inline void PTZControlProtol::set_has_device() {
  _impl_._oneof_case_[0] = kDevice;
}
inline void PTZControlProtol::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kDevice) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.device_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.device_);
    }
    clear_has_content();
  }
}
inline ::PTZDevice* PTZControlProtol::release_device() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.device)
  if (content_case() == kDevice) {
    clear_has_content();
    auto* temp = _impl_.content_.device_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PTZDevice& PTZControlProtol::_internal_device() const {
  return content_case() == kDevice ? *_impl_.content_.device_ : reinterpret_cast<::PTZDevice&>(::_PTZDevice_default_instance_);
}
inline const ::PTZDevice& PTZControlProtol::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.device)
  return _internal_device();
}
inline ::PTZDevice* PTZControlProtol::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.device)
  if (content_case() == kDevice) {
    clear_has_content();
    auto* temp = _impl_.content_.device_;
    _impl_.content_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_device(::PTZDevice* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_device();
    _impl_.content_.device_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.device)
}
inline ::PTZDevice* PTZControlProtol::_internal_mutable_device() {
  if (content_case() != kDevice) {
    clear_content();
    set_has_device();
    _impl_.content_.device_ =
        ::google::protobuf::Message::DefaultConstruct<::PTZDevice>(GetArena());
  }
  return _impl_.content_.device_;
}
inline ::PTZDevice* PTZControlProtol::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PTZDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.device)
  return _msg;
}

// .MediaSettings media_settings = 5;
inline bool PTZControlProtol::has_media_settings() const {
  return content_case() == kMediaSettings;
}
inline bool PTZControlProtol::_internal_has_media_settings() const {
  return content_case() == kMediaSettings;
}
inline void PTZControlProtol::set_has_media_settings() {
  _impl_._oneof_case_[0] = kMediaSettings;
}
inline void PTZControlProtol::clear_media_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kMediaSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.media_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.media_settings_);
    }
    clear_has_content();
  }
}
inline ::MediaSettings* PTZControlProtol::release_media_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.media_settings)
  if (content_case() == kMediaSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.media_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.media_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MediaSettings& PTZControlProtol::_internal_media_settings() const {
  return content_case() == kMediaSettings ? *_impl_.content_.media_settings_ : reinterpret_cast<::MediaSettings&>(::_MediaSettings_default_instance_);
}
inline const ::MediaSettings& PTZControlProtol::media_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.media_settings)
  return _internal_media_settings();
}
inline ::MediaSettings* PTZControlProtol::unsafe_arena_release_media_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.media_settings)
  if (content_case() == kMediaSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.media_settings_;
    _impl_.content_.media_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_media_settings(::MediaSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_media_settings();
    _impl_.content_.media_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.media_settings)
}
inline ::MediaSettings* PTZControlProtol::_internal_mutable_media_settings() {
  if (content_case() != kMediaSettings) {
    clear_content();
    set_has_media_settings();
    _impl_.content_.media_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::MediaSettings>(GetArena());
  }
  return _impl_.content_.media_settings_;
}
inline ::MediaSettings* PTZControlProtol::mutable_media_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MediaSettings* _msg = _internal_mutable_media_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.media_settings)
  return _msg;
}

// .ImageSettings image_settings = 6;
inline bool PTZControlProtol::has_image_settings() const {
  return content_case() == kImageSettings;
}
inline bool PTZControlProtol::_internal_has_image_settings() const {
  return content_case() == kImageSettings;
}
inline void PTZControlProtol::set_has_image_settings() {
  _impl_._oneof_case_[0] = kImageSettings;
}
inline void PTZControlProtol::clear_image_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kImageSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.image_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.image_settings_);
    }
    clear_has_content();
  }
}
inline ::ImageSettings* PTZControlProtol::release_image_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.image_settings)
  if (content_case() == kImageSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.image_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.image_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ImageSettings& PTZControlProtol::_internal_image_settings() const {
  return content_case() == kImageSettings ? *_impl_.content_.image_settings_ : reinterpret_cast<::ImageSettings&>(::_ImageSettings_default_instance_);
}
inline const ::ImageSettings& PTZControlProtol::image_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.image_settings)
  return _internal_image_settings();
}
inline ::ImageSettings* PTZControlProtol::unsafe_arena_release_image_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.image_settings)
  if (content_case() == kImageSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.image_settings_;
    _impl_.content_.image_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_image_settings(::ImageSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_image_settings();
    _impl_.content_.image_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.image_settings)
}
inline ::ImageSettings* PTZControlProtol::_internal_mutable_image_settings() {
  if (content_case() != kImageSettings) {
    clear_content();
    set_has_image_settings();
    _impl_.content_.image_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::ImageSettings>(GetArena());
  }
  return _impl_.content_.image_settings_;
}
inline ::ImageSettings* PTZControlProtol::mutable_image_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ImageSettings* _msg = _internal_mutable_image_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.image_settings)
  return _msg;
}

// .ImageEnhancement image_enhancement = 7;
inline bool PTZControlProtol::has_image_enhancement() const {
  return content_case() == kImageEnhancement;
}
inline bool PTZControlProtol::_internal_has_image_enhancement() const {
  return content_case() == kImageEnhancement;
}
inline void PTZControlProtol::set_has_image_enhancement() {
  _impl_._oneof_case_[0] = kImageEnhancement;
}
inline void PTZControlProtol::clear_image_enhancement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kImageEnhancement) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.image_enhancement_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.image_enhancement_);
    }
    clear_has_content();
  }
}
inline ::ImageEnhancement* PTZControlProtol::release_image_enhancement() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.image_enhancement)
  if (content_case() == kImageEnhancement) {
    clear_has_content();
    auto* temp = _impl_.content_.image_enhancement_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.image_enhancement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ImageEnhancement& PTZControlProtol::_internal_image_enhancement() const {
  return content_case() == kImageEnhancement ? *_impl_.content_.image_enhancement_ : reinterpret_cast<::ImageEnhancement&>(::_ImageEnhancement_default_instance_);
}
inline const ::ImageEnhancement& PTZControlProtol::image_enhancement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.image_enhancement)
  return _internal_image_enhancement();
}
inline ::ImageEnhancement* PTZControlProtol::unsafe_arena_release_image_enhancement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.image_enhancement)
  if (content_case() == kImageEnhancement) {
    clear_has_content();
    auto* temp = _impl_.content_.image_enhancement_;
    _impl_.content_.image_enhancement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_image_enhancement(::ImageEnhancement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_image_enhancement();
    _impl_.content_.image_enhancement_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.image_enhancement)
}
inline ::ImageEnhancement* PTZControlProtol::_internal_mutable_image_enhancement() {
  if (content_case() != kImageEnhancement) {
    clear_content();
    set_has_image_enhancement();
    _impl_.content_.image_enhancement_ =
        ::google::protobuf::Message::DefaultConstruct<::ImageEnhancement>(GetArena());
  }
  return _impl_.content_.image_enhancement_;
}
inline ::ImageEnhancement* PTZControlProtol::mutable_image_enhancement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ImageEnhancement* _msg = _internal_mutable_image_enhancement();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.image_enhancement)
  return _msg;
}

// .VideoAdjustment video_adjustment = 8;
inline bool PTZControlProtol::has_video_adjustment() const {
  return content_case() == kVideoAdjustment;
}
inline bool PTZControlProtol::_internal_has_video_adjustment() const {
  return content_case() == kVideoAdjustment;
}
inline void PTZControlProtol::set_has_video_adjustment() {
  _impl_._oneof_case_[0] = kVideoAdjustment;
}
inline void PTZControlProtol::clear_video_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kVideoAdjustment) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.video_adjustment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.video_adjustment_);
    }
    clear_has_content();
  }
}
inline ::VideoAdjustment* PTZControlProtol::release_video_adjustment() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.video_adjustment)
  if (content_case() == kVideoAdjustment) {
    clear_has_content();
    auto* temp = _impl_.content_.video_adjustment_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.video_adjustment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VideoAdjustment& PTZControlProtol::_internal_video_adjustment() const {
  return content_case() == kVideoAdjustment ? *_impl_.content_.video_adjustment_ : reinterpret_cast<::VideoAdjustment&>(::_VideoAdjustment_default_instance_);
}
inline const ::VideoAdjustment& PTZControlProtol::video_adjustment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.video_adjustment)
  return _internal_video_adjustment();
}
inline ::VideoAdjustment* PTZControlProtol::unsafe_arena_release_video_adjustment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.video_adjustment)
  if (content_case() == kVideoAdjustment) {
    clear_has_content();
    auto* temp = _impl_.content_.video_adjustment_;
    _impl_.content_.video_adjustment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_video_adjustment(::VideoAdjustment* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_video_adjustment();
    _impl_.content_.video_adjustment_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.video_adjustment)
}
inline ::VideoAdjustment* PTZControlProtol::_internal_mutable_video_adjustment() {
  if (content_case() != kVideoAdjustment) {
    clear_content();
    set_has_video_adjustment();
    _impl_.content_.video_adjustment_ =
        ::google::protobuf::Message::DefaultConstruct<::VideoAdjustment>(GetArena());
  }
  return _impl_.content_.video_adjustment_;
}
inline ::VideoAdjustment* PTZControlProtol::mutable_video_adjustment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::VideoAdjustment* _msg = _internal_mutable_video_adjustment();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.video_adjustment)
  return _msg;
}

// .ExposureSettings exposure_settings = 9;
inline bool PTZControlProtol::has_exposure_settings() const {
  return content_case() == kExposureSettings;
}
inline bool PTZControlProtol::_internal_has_exposure_settings() const {
  return content_case() == kExposureSettings;
}
inline void PTZControlProtol::set_has_exposure_settings() {
  _impl_._oneof_case_[0] = kExposureSettings;
}
inline void PTZControlProtol::clear_exposure_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kExposureSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.exposure_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.exposure_settings_);
    }
    clear_has_content();
  }
}
inline ::ExposureSettings* PTZControlProtol::release_exposure_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.exposure_settings)
  if (content_case() == kExposureSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.exposure_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.exposure_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExposureSettings& PTZControlProtol::_internal_exposure_settings() const {
  return content_case() == kExposureSettings ? *_impl_.content_.exposure_settings_ : reinterpret_cast<::ExposureSettings&>(::_ExposureSettings_default_instance_);
}
inline const ::ExposureSettings& PTZControlProtol::exposure_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.exposure_settings)
  return _internal_exposure_settings();
}
inline ::ExposureSettings* PTZControlProtol::unsafe_arena_release_exposure_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.exposure_settings)
  if (content_case() == kExposureSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.exposure_settings_;
    _impl_.content_.exposure_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_exposure_settings(::ExposureSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_exposure_settings();
    _impl_.content_.exposure_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.exposure_settings)
}
inline ::ExposureSettings* PTZControlProtol::_internal_mutable_exposure_settings() {
  if (content_case() != kExposureSettings) {
    clear_content();
    set_has_exposure_settings();
    _impl_.content_.exposure_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::ExposureSettings>(GetArena());
  }
  return _impl_.content_.exposure_settings_;
}
inline ::ExposureSettings* PTZControlProtol::mutable_exposure_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ExposureSettings* _msg = _internal_mutable_exposure_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.exposure_settings)
  return _msg;
}

// .DayNightSwitchSettings day_night_switch_settings = 10;
inline bool PTZControlProtol::has_day_night_switch_settings() const {
  return content_case() == kDayNightSwitchSettings;
}
inline bool PTZControlProtol::_internal_has_day_night_switch_settings() const {
  return content_case() == kDayNightSwitchSettings;
}
inline void PTZControlProtol::set_has_day_night_switch_settings() {
  _impl_._oneof_case_[0] = kDayNightSwitchSettings;
}
inline void PTZControlProtol::clear_day_night_switch_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kDayNightSwitchSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.day_night_switch_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.day_night_switch_settings_);
    }
    clear_has_content();
  }
}
inline ::DayNightSwitchSettings* PTZControlProtol::release_day_night_switch_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.day_night_switch_settings)
  if (content_case() == kDayNightSwitchSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.day_night_switch_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.day_night_switch_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DayNightSwitchSettings& PTZControlProtol::_internal_day_night_switch_settings() const {
  return content_case() == kDayNightSwitchSettings ? *_impl_.content_.day_night_switch_settings_ : reinterpret_cast<::DayNightSwitchSettings&>(::_DayNightSwitchSettings_default_instance_);
}
inline const ::DayNightSwitchSettings& PTZControlProtol::day_night_switch_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.day_night_switch_settings)
  return _internal_day_night_switch_settings();
}
inline ::DayNightSwitchSettings* PTZControlProtol::unsafe_arena_release_day_night_switch_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.day_night_switch_settings)
  if (content_case() == kDayNightSwitchSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.day_night_switch_settings_;
    _impl_.content_.day_night_switch_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_day_night_switch_settings(::DayNightSwitchSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_day_night_switch_settings();
    _impl_.content_.day_night_switch_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.day_night_switch_settings)
}
inline ::DayNightSwitchSettings* PTZControlProtol::_internal_mutable_day_night_switch_settings() {
  if (content_case() != kDayNightSwitchSettings) {
    clear_content();
    set_has_day_night_switch_settings();
    _impl_.content_.day_night_switch_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::DayNightSwitchSettings>(GetArena());
  }
  return _impl_.content_.day_night_switch_settings_;
}
inline ::DayNightSwitchSettings* PTZControlProtol::mutable_day_night_switch_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DayNightSwitchSettings* _msg = _internal_mutable_day_night_switch_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.day_night_switch_settings)
  return _msg;
}

// .WhiteBalanceSettings white_balance_settings = 11;
inline bool PTZControlProtol::has_white_balance_settings() const {
  return content_case() == kWhiteBalanceSettings;
}
inline bool PTZControlProtol::_internal_has_white_balance_settings() const {
  return content_case() == kWhiteBalanceSettings;
}
inline void PTZControlProtol::set_has_white_balance_settings() {
  _impl_._oneof_case_[0] = kWhiteBalanceSettings;
}
inline void PTZControlProtol::clear_white_balance_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kWhiteBalanceSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.white_balance_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.white_balance_settings_);
    }
    clear_has_content();
  }
}
inline ::WhiteBalanceSettings* PTZControlProtol::release_white_balance_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.white_balance_settings)
  if (content_case() == kWhiteBalanceSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.white_balance_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.white_balance_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WhiteBalanceSettings& PTZControlProtol::_internal_white_balance_settings() const {
  return content_case() == kWhiteBalanceSettings ? *_impl_.content_.white_balance_settings_ : reinterpret_cast<::WhiteBalanceSettings&>(::_WhiteBalanceSettings_default_instance_);
}
inline const ::WhiteBalanceSettings& PTZControlProtol::white_balance_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.white_balance_settings)
  return _internal_white_balance_settings();
}
inline ::WhiteBalanceSettings* PTZControlProtol::unsafe_arena_release_white_balance_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.white_balance_settings)
  if (content_case() == kWhiteBalanceSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.white_balance_settings_;
    _impl_.content_.white_balance_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_white_balance_settings(::WhiteBalanceSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_white_balance_settings();
    _impl_.content_.white_balance_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.white_balance_settings)
}
inline ::WhiteBalanceSettings* PTZControlProtol::_internal_mutable_white_balance_settings() {
  if (content_case() != kWhiteBalanceSettings) {
    clear_content();
    set_has_white_balance_settings();
    _impl_.content_.white_balance_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::WhiteBalanceSettings>(GetArena());
  }
  return _impl_.content_.white_balance_settings_;
}
inline ::WhiteBalanceSettings* PTZControlProtol::mutable_white_balance_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::WhiteBalanceSettings* _msg = _internal_mutable_white_balance_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.white_balance_settings)
  return _msg;
}

// .InfraredImageSettings infrared_image_settings = 12;
inline bool PTZControlProtol::has_infrared_image_settings() const {
  return content_case() == kInfraredImageSettings;
}
inline bool PTZControlProtol::_internal_has_infrared_image_settings() const {
  return content_case() == kInfraredImageSettings;
}
inline void PTZControlProtol::set_has_infrared_image_settings() {
  _impl_._oneof_case_[0] = kInfraredImageSettings;
}
inline void PTZControlProtol::clear_infrared_image_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kInfraredImageSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.infrared_image_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.infrared_image_settings_);
    }
    clear_has_content();
  }
}
inline ::InfraredImageSettings* PTZControlProtol::release_infrared_image_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.infrared_image_settings)
  if (content_case() == kInfraredImageSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.infrared_image_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.infrared_image_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InfraredImageSettings& PTZControlProtol::_internal_infrared_image_settings() const {
  return content_case() == kInfraredImageSettings ? *_impl_.content_.infrared_image_settings_ : reinterpret_cast<::InfraredImageSettings&>(::_InfraredImageSettings_default_instance_);
}
inline const ::InfraredImageSettings& PTZControlProtol::infrared_image_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.infrared_image_settings)
  return _internal_infrared_image_settings();
}
inline ::InfraredImageSettings* PTZControlProtol::unsafe_arena_release_infrared_image_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.infrared_image_settings)
  if (content_case() == kInfraredImageSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.infrared_image_settings_;
    _impl_.content_.infrared_image_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_infrared_image_settings(::InfraredImageSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_infrared_image_settings();
    _impl_.content_.infrared_image_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.infrared_image_settings)
}
inline ::InfraredImageSettings* PTZControlProtol::_internal_mutable_infrared_image_settings() {
  if (content_case() != kInfraredImageSettings) {
    clear_content();
    set_has_infrared_image_settings();
    _impl_.content_.infrared_image_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::InfraredImageSettings>(GetArena());
  }
  return _impl_.content_.infrared_image_settings_;
}
inline ::InfraredImageSettings* PTZControlProtol::mutable_infrared_image_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InfraredImageSettings* _msg = _internal_mutable_infrared_image_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.infrared_image_settings)
  return _msg;
}

// .OSDSettings osd_settings = 13;
inline bool PTZControlProtol::has_osd_settings() const {
  return content_case() == kOsdSettings;
}
inline bool PTZControlProtol::_internal_has_osd_settings() const {
  return content_case() == kOsdSettings;
}
inline void PTZControlProtol::set_has_osd_settings() {
  _impl_._oneof_case_[0] = kOsdSettings;
}
inline void PTZControlProtol::clear_osd_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kOsdSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.osd_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.osd_settings_);
    }
    clear_has_content();
  }
}
inline ::OSDSettings* PTZControlProtol::release_osd_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.osd_settings)
  if (content_case() == kOsdSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.osd_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.osd_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OSDSettings& PTZControlProtol::_internal_osd_settings() const {
  return content_case() == kOsdSettings ? *_impl_.content_.osd_settings_ : reinterpret_cast<::OSDSettings&>(::_OSDSettings_default_instance_);
}
inline const ::OSDSettings& PTZControlProtol::osd_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.osd_settings)
  return _internal_osd_settings();
}
inline ::OSDSettings* PTZControlProtol::unsafe_arena_release_osd_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.osd_settings)
  if (content_case() == kOsdSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.osd_settings_;
    _impl_.content_.osd_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_osd_settings(::OSDSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_osd_settings();
    _impl_.content_.osd_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.osd_settings)
}
inline ::OSDSettings* PTZControlProtol::_internal_mutable_osd_settings() {
  if (content_case() != kOsdSettings) {
    clear_content();
    set_has_osd_settings();
    _impl_.content_.osd_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::OSDSettings>(GetArena());
  }
  return _impl_.content_.osd_settings_;
}
inline ::OSDSettings* PTZControlProtol::mutable_osd_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::OSDSettings* _msg = _internal_mutable_osd_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.osd_settings)
  return _msg;
}

// .IPSettings ip_settings = 14;
inline bool PTZControlProtol::has_ip_settings() const {
  return content_case() == kIpSettings;
}
inline bool PTZControlProtol::_internal_has_ip_settings() const {
  return content_case() == kIpSettings;
}
inline void PTZControlProtol::set_has_ip_settings() {
  _impl_._oneof_case_[0] = kIpSettings;
}
inline void PTZControlProtol::clear_ip_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kIpSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.ip_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.ip_settings_);
    }
    clear_has_content();
  }
}
inline ::IPSettings* PTZControlProtol::release_ip_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.ip_settings)
  if (content_case() == kIpSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.ip_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.ip_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IPSettings& PTZControlProtol::_internal_ip_settings() const {
  return content_case() == kIpSettings ? *_impl_.content_.ip_settings_ : reinterpret_cast<::IPSettings&>(::_IPSettings_default_instance_);
}
inline const ::IPSettings& PTZControlProtol::ip_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.ip_settings)
  return _internal_ip_settings();
}
inline ::IPSettings* PTZControlProtol::unsafe_arena_release_ip_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.ip_settings)
  if (content_case() == kIpSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.ip_settings_;
    _impl_.content_.ip_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_ip_settings(::IPSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_ip_settings();
    _impl_.content_.ip_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.ip_settings)
}
inline ::IPSettings* PTZControlProtol::_internal_mutable_ip_settings() {
  if (content_case() != kIpSettings) {
    clear_content();
    set_has_ip_settings();
    _impl_.content_.ip_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::IPSettings>(GetArena());
  }
  return _impl_.content_.ip_settings_;
}
inline ::IPSettings* PTZControlProtol::mutable_ip_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::IPSettings* _msg = _internal_mutable_ip_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.ip_settings)
  return _msg;
}

// .PortSettings port_settings = 15;
inline bool PTZControlProtol::has_port_settings() const {
  return content_case() == kPortSettings;
}
inline bool PTZControlProtol::_internal_has_port_settings() const {
  return content_case() == kPortSettings;
}
inline void PTZControlProtol::set_has_port_settings() {
  _impl_._oneof_case_[0] = kPortSettings;
}
inline void PTZControlProtol::clear_port_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kPortSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.port_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.port_settings_);
    }
    clear_has_content();
  }
}
inline ::PortSettings* PTZControlProtol::release_port_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.port_settings)
  if (content_case() == kPortSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.port_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.port_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PortSettings& PTZControlProtol::_internal_port_settings() const {
  return content_case() == kPortSettings ? *_impl_.content_.port_settings_ : reinterpret_cast<::PortSettings&>(::_PortSettings_default_instance_);
}
inline const ::PortSettings& PTZControlProtol::port_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.port_settings)
  return _internal_port_settings();
}
inline ::PortSettings* PTZControlProtol::unsafe_arena_release_port_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.port_settings)
  if (content_case() == kPortSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.port_settings_;
    _impl_.content_.port_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_port_settings(::PortSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_port_settings();
    _impl_.content_.port_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.port_settings)
}
inline ::PortSettings* PTZControlProtol::_internal_mutable_port_settings() {
  if (content_case() != kPortSettings) {
    clear_content();
    set_has_port_settings();
    _impl_.content_.port_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::PortSettings>(GetArena());
  }
  return _impl_.content_.port_settings_;
}
inline ::PortSettings* PTZControlProtol::mutable_port_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PortSettings* _msg = _internal_mutable_port_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.port_settings)
  return _msg;
}

// .FTPSettings ftp_settings = 16;
inline bool PTZControlProtol::has_ftp_settings() const {
  return content_case() == kFtpSettings;
}
inline bool PTZControlProtol::_internal_has_ftp_settings() const {
  return content_case() == kFtpSettings;
}
inline void PTZControlProtol::set_has_ftp_settings() {
  _impl_._oneof_case_[0] = kFtpSettings;
}
inline void PTZControlProtol::clear_ftp_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kFtpSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.ftp_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.ftp_settings_);
    }
    clear_has_content();
  }
}
inline ::FTPSettings* PTZControlProtol::release_ftp_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.ftp_settings)
  if (content_case() == kFtpSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.ftp_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.ftp_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FTPSettings& PTZControlProtol::_internal_ftp_settings() const {
  return content_case() == kFtpSettings ? *_impl_.content_.ftp_settings_ : reinterpret_cast<::FTPSettings&>(::_FTPSettings_default_instance_);
}
inline const ::FTPSettings& PTZControlProtol::ftp_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.ftp_settings)
  return _internal_ftp_settings();
}
inline ::FTPSettings* PTZControlProtol::unsafe_arena_release_ftp_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.ftp_settings)
  if (content_case() == kFtpSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.ftp_settings_;
    _impl_.content_.ftp_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_ftp_settings(::FTPSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_ftp_settings();
    _impl_.content_.ftp_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.ftp_settings)
}
inline ::FTPSettings* PTZControlProtol::_internal_mutable_ftp_settings() {
  if (content_case() != kFtpSettings) {
    clear_content();
    set_has_ftp_settings();
    _impl_.content_.ftp_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::FTPSettings>(GetArena());
  }
  return _impl_.content_.ftp_settings_;
}
inline ::FTPSettings* PTZControlProtol::mutable_ftp_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::FTPSettings* _msg = _internal_mutable_ftp_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.ftp_settings)
  return _msg;
}

// .PlatformSettings platform_settings = 17;
inline bool PTZControlProtol::has_platform_settings() const {
  return content_case() == kPlatformSettings;
}
inline bool PTZControlProtol::_internal_has_platform_settings() const {
  return content_case() == kPlatformSettings;
}
inline void PTZControlProtol::set_has_platform_settings() {
  _impl_._oneof_case_[0] = kPlatformSettings;
}
inline void PTZControlProtol::clear_platform_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kPlatformSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.platform_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.platform_settings_);
    }
    clear_has_content();
  }
}
inline ::PlatformSettings* PTZControlProtol::release_platform_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.platform_settings)
  if (content_case() == kPlatformSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.platform_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.platform_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlatformSettings& PTZControlProtol::_internal_platform_settings() const {
  return content_case() == kPlatformSettings ? *_impl_.content_.platform_settings_ : reinterpret_cast<::PlatformSettings&>(::_PlatformSettings_default_instance_);
}
inline const ::PlatformSettings& PTZControlProtol::platform_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.platform_settings)
  return _internal_platform_settings();
}
inline ::PlatformSettings* PTZControlProtol::unsafe_arena_release_platform_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.platform_settings)
  if (content_case() == kPlatformSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.platform_settings_;
    _impl_.content_.platform_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_platform_settings(::PlatformSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_platform_settings();
    _impl_.content_.platform_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.platform_settings)
}
inline ::PlatformSettings* PTZControlProtol::_internal_mutable_platform_settings() {
  if (content_case() != kPlatformSettings) {
    clear_content();
    set_has_platform_settings();
    _impl_.content_.platform_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::PlatformSettings>(GetArena());
  }
  return _impl_.content_.platform_settings_;
}
inline ::PlatformSettings* PTZControlProtol::mutable_platform_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlatformSettings* _msg = _internal_mutable_platform_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.platform_settings)
  return _msg;
}

// .AlarmSettings alarm_settings = 18;
inline bool PTZControlProtol::has_alarm_settings() const {
  return content_case() == kAlarmSettings;
}
inline bool PTZControlProtol::_internal_has_alarm_settings() const {
  return content_case() == kAlarmSettings;
}
inline void PTZControlProtol::set_has_alarm_settings() {
  _impl_._oneof_case_[0] = kAlarmSettings;
}
inline void PTZControlProtol::clear_alarm_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kAlarmSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.alarm_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.alarm_settings_);
    }
    clear_has_content();
  }
}
inline ::AlarmSettings* PTZControlProtol::release_alarm_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.alarm_settings)
  if (content_case() == kAlarmSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.alarm_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.alarm_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AlarmSettings& PTZControlProtol::_internal_alarm_settings() const {
  return content_case() == kAlarmSettings ? *_impl_.content_.alarm_settings_ : reinterpret_cast<::AlarmSettings&>(::_AlarmSettings_default_instance_);
}
inline const ::AlarmSettings& PTZControlProtol::alarm_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.alarm_settings)
  return _internal_alarm_settings();
}
inline ::AlarmSettings* PTZControlProtol::unsafe_arena_release_alarm_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.alarm_settings)
  if (content_case() == kAlarmSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.alarm_settings_;
    _impl_.content_.alarm_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_alarm_settings(::AlarmSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_alarm_settings();
    _impl_.content_.alarm_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.alarm_settings)
}
inline ::AlarmSettings* PTZControlProtol::_internal_mutable_alarm_settings() {
  if (content_case() != kAlarmSettings) {
    clear_content();
    set_has_alarm_settings();
    _impl_.content_.alarm_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::AlarmSettings>(GetArena());
  }
  return _impl_.content_.alarm_settings_;
}
inline ::AlarmSettings* PTZControlProtol::mutable_alarm_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AlarmSettings* _msg = _internal_mutable_alarm_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.alarm_settings)
  return _msg;
}

// .GasLeakageAlarmSettings gas_leakage_alarm_settings = 19;
inline bool PTZControlProtol::has_gas_leakage_alarm_settings() const {
  return content_case() == kGasLeakageAlarmSettings;
}
inline bool PTZControlProtol::_internal_has_gas_leakage_alarm_settings() const {
  return content_case() == kGasLeakageAlarmSettings;
}
inline void PTZControlProtol::set_has_gas_leakage_alarm_settings() {
  _impl_._oneof_case_[0] = kGasLeakageAlarmSettings;
}
inline void PTZControlProtol::clear_gas_leakage_alarm_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kGasLeakageAlarmSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.gas_leakage_alarm_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.gas_leakage_alarm_settings_);
    }
    clear_has_content();
  }
}
inline ::GasLeakageAlarmSettings* PTZControlProtol::release_gas_leakage_alarm_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.gas_leakage_alarm_settings)
  if (content_case() == kGasLeakageAlarmSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.gas_leakage_alarm_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.gas_leakage_alarm_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GasLeakageAlarmSettings& PTZControlProtol::_internal_gas_leakage_alarm_settings() const {
  return content_case() == kGasLeakageAlarmSettings ? *_impl_.content_.gas_leakage_alarm_settings_ : reinterpret_cast<::GasLeakageAlarmSettings&>(::_GasLeakageAlarmSettings_default_instance_);
}
inline const ::GasLeakageAlarmSettings& PTZControlProtol::gas_leakage_alarm_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.gas_leakage_alarm_settings)
  return _internal_gas_leakage_alarm_settings();
}
inline ::GasLeakageAlarmSettings* PTZControlProtol::unsafe_arena_release_gas_leakage_alarm_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.gas_leakage_alarm_settings)
  if (content_case() == kGasLeakageAlarmSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.gas_leakage_alarm_settings_;
    _impl_.content_.gas_leakage_alarm_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_gas_leakage_alarm_settings(::GasLeakageAlarmSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_gas_leakage_alarm_settings();
    _impl_.content_.gas_leakage_alarm_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.gas_leakage_alarm_settings)
}
inline ::GasLeakageAlarmSettings* PTZControlProtol::_internal_mutable_gas_leakage_alarm_settings() {
  if (content_case() != kGasLeakageAlarmSettings) {
    clear_content();
    set_has_gas_leakage_alarm_settings();
    _impl_.content_.gas_leakage_alarm_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::GasLeakageAlarmSettings>(GetArena());
  }
  return _impl_.content_.gas_leakage_alarm_settings_;
}
inline ::GasLeakageAlarmSettings* PTZControlProtol::mutable_gas_leakage_alarm_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GasLeakageAlarmSettings* _msg = _internal_mutable_gas_leakage_alarm_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.gas_leakage_alarm_settings)
  return _msg;
}

// .UserAccountSettings user_account_settings = 20;
inline bool PTZControlProtol::has_user_account_settings() const {
  return content_case() == kUserAccountSettings;
}
inline bool PTZControlProtol::_internal_has_user_account_settings() const {
  return content_case() == kUserAccountSettings;
}
inline void PTZControlProtol::set_has_user_account_settings() {
  _impl_._oneof_case_[0] = kUserAccountSettings;
}
inline void PTZControlProtol::clear_user_account_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kUserAccountSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.user_account_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.user_account_settings_);
    }
    clear_has_content();
  }
}
inline ::UserAccountSettings* PTZControlProtol::release_user_account_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.user_account_settings)
  if (content_case() == kUserAccountSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.user_account_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.user_account_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UserAccountSettings& PTZControlProtol::_internal_user_account_settings() const {
  return content_case() == kUserAccountSettings ? *_impl_.content_.user_account_settings_ : reinterpret_cast<::UserAccountSettings&>(::_UserAccountSettings_default_instance_);
}
inline const ::UserAccountSettings& PTZControlProtol::user_account_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.user_account_settings)
  return _internal_user_account_settings();
}
inline ::UserAccountSettings* PTZControlProtol::unsafe_arena_release_user_account_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.user_account_settings)
  if (content_case() == kUserAccountSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.user_account_settings_;
    _impl_.content_.user_account_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_user_account_settings(::UserAccountSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_user_account_settings();
    _impl_.content_.user_account_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.user_account_settings)
}
inline ::UserAccountSettings* PTZControlProtol::_internal_mutable_user_account_settings() {
  if (content_case() != kUserAccountSettings) {
    clear_content();
    set_has_user_account_settings();
    _impl_.content_.user_account_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::UserAccountSettings>(GetArena());
  }
  return _impl_.content_.user_account_settings_;
}
inline ::UserAccountSettings* PTZControlProtol::mutable_user_account_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UserAccountSettings* _msg = _internal_mutable_user_account_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.user_account_settings)
  return _msg;
}

// .LoginSecuritySettings login_security_settings = 21;
inline bool PTZControlProtol::has_login_security_settings() const {
  return content_case() == kLoginSecuritySettings;
}
inline bool PTZControlProtol::_internal_has_login_security_settings() const {
  return content_case() == kLoginSecuritySettings;
}
inline void PTZControlProtol::set_has_login_security_settings() {
  _impl_._oneof_case_[0] = kLoginSecuritySettings;
}
inline void PTZControlProtol::clear_login_security_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kLoginSecuritySettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.login_security_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.login_security_settings_);
    }
    clear_has_content();
  }
}
inline ::LoginSecuritySettings* PTZControlProtol::release_login_security_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.login_security_settings)
  if (content_case() == kLoginSecuritySettings) {
    clear_has_content();
    auto* temp = _impl_.content_.login_security_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.login_security_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoginSecuritySettings& PTZControlProtol::_internal_login_security_settings() const {
  return content_case() == kLoginSecuritySettings ? *_impl_.content_.login_security_settings_ : reinterpret_cast<::LoginSecuritySettings&>(::_LoginSecuritySettings_default_instance_);
}
inline const ::LoginSecuritySettings& PTZControlProtol::login_security_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.login_security_settings)
  return _internal_login_security_settings();
}
inline ::LoginSecuritySettings* PTZControlProtol::unsafe_arena_release_login_security_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.login_security_settings)
  if (content_case() == kLoginSecuritySettings) {
    clear_has_content();
    auto* temp = _impl_.content_.login_security_settings_;
    _impl_.content_.login_security_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_login_security_settings(::LoginSecuritySettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_login_security_settings();
    _impl_.content_.login_security_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.login_security_settings)
}
inline ::LoginSecuritySettings* PTZControlProtol::_internal_mutable_login_security_settings() {
  if (content_case() != kLoginSecuritySettings) {
    clear_content();
    set_has_login_security_settings();
    _impl_.content_.login_security_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::LoginSecuritySettings>(GetArena());
  }
  return _impl_.content_.login_security_settings_;
}
inline ::LoginSecuritySettings* PTZControlProtol::mutable_login_security_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LoginSecuritySettings* _msg = _internal_mutable_login_security_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.login_security_settings)
  return _msg;
}

// .TimeSettings time_settings = 22;
inline bool PTZControlProtol::has_time_settings() const {
  return content_case() == kTimeSettings;
}
inline bool PTZControlProtol::_internal_has_time_settings() const {
  return content_case() == kTimeSettings;
}
inline void PTZControlProtol::set_has_time_settings() {
  _impl_._oneof_case_[0] = kTimeSettings;
}
inline void PTZControlProtol::clear_time_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kTimeSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.time_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.time_settings_);
    }
    clear_has_content();
  }
}
inline ::TimeSettings* PTZControlProtol::release_time_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.time_settings)
  if (content_case() == kTimeSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.time_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.time_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TimeSettings& PTZControlProtol::_internal_time_settings() const {
  return content_case() == kTimeSettings ? *_impl_.content_.time_settings_ : reinterpret_cast<::TimeSettings&>(::_TimeSettings_default_instance_);
}
inline const ::TimeSettings& PTZControlProtol::time_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.time_settings)
  return _internal_time_settings();
}
inline ::TimeSettings* PTZControlProtol::unsafe_arena_release_time_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.time_settings)
  if (content_case() == kTimeSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.time_settings_;
    _impl_.content_.time_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_time_settings(::TimeSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_time_settings();
    _impl_.content_.time_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.time_settings)
}
inline ::TimeSettings* PTZControlProtol::_internal_mutable_time_settings() {
  if (content_case() != kTimeSettings) {
    clear_content();
    set_has_time_settings();
    _impl_.content_.time_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::TimeSettings>(GetArena());
  }
  return _impl_.content_.time_settings_;
}
inline ::TimeSettings* PTZControlProtol::mutable_time_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TimeSettings* _msg = _internal_mutable_time_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.time_settings)
  return _msg;
}

// .SystemInfo system_info = 23;
inline bool PTZControlProtol::has_system_info() const {
  return content_case() == kSystemInfo;
}
inline bool PTZControlProtol::_internal_has_system_info() const {
  return content_case() == kSystemInfo;
}
inline void PTZControlProtol::set_has_system_info() {
  _impl_._oneof_case_[0] = kSystemInfo;
}
inline void PTZControlProtol::clear_system_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kSystemInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.system_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.system_info_);
    }
    clear_has_content();
  }
}
inline ::SystemInfo* PTZControlProtol::release_system_info() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.system_info)
  if (content_case() == kSystemInfo) {
    clear_has_content();
    auto* temp = _impl_.content_.system_info_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.system_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SystemInfo& PTZControlProtol::_internal_system_info() const {
  return content_case() == kSystemInfo ? *_impl_.content_.system_info_ : reinterpret_cast<::SystemInfo&>(::_SystemInfo_default_instance_);
}
inline const ::SystemInfo& PTZControlProtol::system_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.system_info)
  return _internal_system_info();
}
inline ::SystemInfo* PTZControlProtol::unsafe_arena_release_system_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.system_info)
  if (content_case() == kSystemInfo) {
    clear_has_content();
    auto* temp = _impl_.content_.system_info_;
    _impl_.content_.system_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_system_info(::SystemInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_system_info();
    _impl_.content_.system_info_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.system_info)
}
inline ::SystemInfo* PTZControlProtol::_internal_mutable_system_info() {
  if (content_case() != kSystemInfo) {
    clear_content();
    set_has_system_info();
    _impl_.content_.system_info_ =
        ::google::protobuf::Message::DefaultConstruct<::SystemInfo>(GetArena());
  }
  return _impl_.content_.system_info_;
}
inline ::SystemInfo* PTZControlProtol::mutable_system_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SystemInfo* _msg = _internal_mutable_system_info();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.system_info)
  return _msg;
}

// .Reboot reboot = 24;
inline bool PTZControlProtol::has_reboot() const {
  return content_case() == kReboot;
}
inline bool PTZControlProtol::_internal_has_reboot() const {
  return content_case() == kReboot;
}
inline void PTZControlProtol::set_has_reboot() {
  _impl_._oneof_case_[0] = kReboot;
}
inline void PTZControlProtol::clear_reboot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kReboot) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.reboot_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.reboot_);
    }
    clear_has_content();
  }
}
inline ::Reboot* PTZControlProtol::release_reboot() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.reboot)
  if (content_case() == kReboot) {
    clear_has_content();
    auto* temp = _impl_.content_.reboot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Reboot& PTZControlProtol::_internal_reboot() const {
  return content_case() == kReboot ? *_impl_.content_.reboot_ : reinterpret_cast<::Reboot&>(::_Reboot_default_instance_);
}
inline const ::Reboot& PTZControlProtol::reboot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.reboot)
  return _internal_reboot();
}
inline ::Reboot* PTZControlProtol::unsafe_arena_release_reboot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.reboot)
  if (content_case() == kReboot) {
    clear_has_content();
    auto* temp = _impl_.content_.reboot_;
    _impl_.content_.reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_reboot(::Reboot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_reboot();
    _impl_.content_.reboot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.reboot)
}
inline ::Reboot* PTZControlProtol::_internal_mutable_reboot() {
  if (content_case() != kReboot) {
    clear_content();
    set_has_reboot();
    _impl_.content_.reboot_ =
        ::google::protobuf::Message::DefaultConstruct<::Reboot>(GetArena());
  }
  return _impl_.content_.reboot_;
}
inline ::Reboot* PTZControlProtol::mutable_reboot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Reboot* _msg = _internal_mutable_reboot();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.reboot)
  return _msg;
}

// .SystemLogsQuery system_logs_query = 25;
inline bool PTZControlProtol::has_system_logs_query() const {
  return content_case() == kSystemLogsQuery;
}
inline bool PTZControlProtol::_internal_has_system_logs_query() const {
  return content_case() == kSystemLogsQuery;
}
inline void PTZControlProtol::set_has_system_logs_query() {
  _impl_._oneof_case_[0] = kSystemLogsQuery;
}
inline void PTZControlProtol::clear_system_logs_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kSystemLogsQuery) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.system_logs_query_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.system_logs_query_);
    }
    clear_has_content();
  }
}
inline ::SystemLogsQuery* PTZControlProtol::release_system_logs_query() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.system_logs_query)
  if (content_case() == kSystemLogsQuery) {
    clear_has_content();
    auto* temp = _impl_.content_.system_logs_query_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.system_logs_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SystemLogsQuery& PTZControlProtol::_internal_system_logs_query() const {
  return content_case() == kSystemLogsQuery ? *_impl_.content_.system_logs_query_ : reinterpret_cast<::SystemLogsQuery&>(::_SystemLogsQuery_default_instance_);
}
inline const ::SystemLogsQuery& PTZControlProtol::system_logs_query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.system_logs_query)
  return _internal_system_logs_query();
}
inline ::SystemLogsQuery* PTZControlProtol::unsafe_arena_release_system_logs_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.system_logs_query)
  if (content_case() == kSystemLogsQuery) {
    clear_has_content();
    auto* temp = _impl_.content_.system_logs_query_;
    _impl_.content_.system_logs_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_system_logs_query(::SystemLogsQuery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_system_logs_query();
    _impl_.content_.system_logs_query_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.system_logs_query)
}
inline ::SystemLogsQuery* PTZControlProtol::_internal_mutable_system_logs_query() {
  if (content_case() != kSystemLogsQuery) {
    clear_content();
    set_has_system_logs_query();
    _impl_.content_.system_logs_query_ =
        ::google::protobuf::Message::DefaultConstruct<::SystemLogsQuery>(GetArena());
  }
  return _impl_.content_.system_logs_query_;
}
inline ::SystemLogsQuery* PTZControlProtol::mutable_system_logs_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SystemLogsQuery* _msg = _internal_mutable_system_logs_query();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.system_logs_query)
  return _msg;
}

// .LogEntry log_entry = 26;
inline bool PTZControlProtol::has_log_entry() const {
  return content_case() == kLogEntry;
}
inline bool PTZControlProtol::_internal_has_log_entry() const {
  return content_case() == kLogEntry;
}
inline void PTZControlProtol::set_has_log_entry() {
  _impl_._oneof_case_[0] = kLogEntry;
}
inline void PTZControlProtol::clear_log_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kLogEntry) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.log_entry_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.log_entry_);
    }
    clear_has_content();
  }
}
inline ::LogEntry* PTZControlProtol::release_log_entry() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.log_entry)
  if (content_case() == kLogEntry) {
    clear_has_content();
    auto* temp = _impl_.content_.log_entry_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.log_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LogEntry& PTZControlProtol::_internal_log_entry() const {
  return content_case() == kLogEntry ? *_impl_.content_.log_entry_ : reinterpret_cast<::LogEntry&>(::_LogEntry_default_instance_);
}
inline const ::LogEntry& PTZControlProtol::log_entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.log_entry)
  return _internal_log_entry();
}
inline ::LogEntry* PTZControlProtol::unsafe_arena_release_log_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.log_entry)
  if (content_case() == kLogEntry) {
    clear_has_content();
    auto* temp = _impl_.content_.log_entry_;
    _impl_.content_.log_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_log_entry(::LogEntry* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_log_entry();
    _impl_.content_.log_entry_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.log_entry)
}
inline ::LogEntry* PTZControlProtol::_internal_mutable_log_entry() {
  if (content_case() != kLogEntry) {
    clear_content();
    set_has_log_entry();
    _impl_.content_.log_entry_ =
        ::google::protobuf::Message::DefaultConstruct<::LogEntry>(GetArena());
  }
  return _impl_.content_.log_entry_;
}
inline ::LogEntry* PTZControlProtol::mutable_log_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LogEntry* _msg = _internal_mutable_log_entry();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.log_entry)
  return _msg;
}

// .PresetPositionOp preset_position_op = 27;
inline bool PTZControlProtol::has_preset_position_op() const {
  return content_case() == kPresetPositionOp;
}
inline bool PTZControlProtol::_internal_has_preset_position_op() const {
  return content_case() == kPresetPositionOp;
}
inline void PTZControlProtol::set_has_preset_position_op() {
  _impl_._oneof_case_[0] = kPresetPositionOp;
}
inline void PTZControlProtol::clear_preset_position_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kPresetPositionOp) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.preset_position_op_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.preset_position_op_);
    }
    clear_has_content();
  }
}
inline ::PresetPositionOp* PTZControlProtol::release_preset_position_op() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.preset_position_op)
  if (content_case() == kPresetPositionOp) {
    clear_has_content();
    auto* temp = _impl_.content_.preset_position_op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.preset_position_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PresetPositionOp& PTZControlProtol::_internal_preset_position_op() const {
  return content_case() == kPresetPositionOp ? *_impl_.content_.preset_position_op_ : reinterpret_cast<::PresetPositionOp&>(::_PresetPositionOp_default_instance_);
}
inline const ::PresetPositionOp& PTZControlProtol::preset_position_op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.preset_position_op)
  return _internal_preset_position_op();
}
inline ::PresetPositionOp* PTZControlProtol::unsafe_arena_release_preset_position_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.preset_position_op)
  if (content_case() == kPresetPositionOp) {
    clear_has_content();
    auto* temp = _impl_.content_.preset_position_op_;
    _impl_.content_.preset_position_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_preset_position_op(::PresetPositionOp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_preset_position_op();
    _impl_.content_.preset_position_op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.preset_position_op)
}
inline ::PresetPositionOp* PTZControlProtol::_internal_mutable_preset_position_op() {
  if (content_case() != kPresetPositionOp) {
    clear_content();
    set_has_preset_position_op();
    _impl_.content_.preset_position_op_ =
        ::google::protobuf::Message::DefaultConstruct<::PresetPositionOp>(GetArena());
  }
  return _impl_.content_.preset_position_op_;
}
inline ::PresetPositionOp* PTZControlProtol::mutable_preset_position_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PresetPositionOp* _msg = _internal_mutable_preset_position_op();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.preset_position_op)
  return _msg;
}

// .PresetList preset_list = 28;
inline bool PTZControlProtol::has_preset_list() const {
  return content_case() == kPresetList;
}
inline bool PTZControlProtol::_internal_has_preset_list() const {
  return content_case() == kPresetList;
}
inline void PTZControlProtol::set_has_preset_list() {
  _impl_._oneof_case_[0] = kPresetList;
}
inline void PTZControlProtol::clear_preset_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kPresetList) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.preset_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.preset_list_);
    }
    clear_has_content();
  }
}
inline ::PresetList* PTZControlProtol::release_preset_list() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.preset_list)
  if (content_case() == kPresetList) {
    clear_has_content();
    auto* temp = _impl_.content_.preset_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.preset_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PresetList& PTZControlProtol::_internal_preset_list() const {
  return content_case() == kPresetList ? *_impl_.content_.preset_list_ : reinterpret_cast<::PresetList&>(::_PresetList_default_instance_);
}
inline const ::PresetList& PTZControlProtol::preset_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.preset_list)
  return _internal_preset_list();
}
inline ::PresetList* PTZControlProtol::unsafe_arena_release_preset_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.preset_list)
  if (content_case() == kPresetList) {
    clear_has_content();
    auto* temp = _impl_.content_.preset_list_;
    _impl_.content_.preset_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_preset_list(::PresetList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_preset_list();
    _impl_.content_.preset_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.preset_list)
}
inline ::PresetList* PTZControlProtol::_internal_mutable_preset_list() {
  if (content_case() != kPresetList) {
    clear_content();
    set_has_preset_list();
    _impl_.content_.preset_list_ =
        ::google::protobuf::Message::DefaultConstruct<::PresetList>(GetArena());
  }
  return _impl_.content_.preset_list_;
}
inline ::PresetList* PTZControlProtol::mutable_preset_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PresetList* _msg = _internal_mutable_preset_list();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.preset_list)
  return _msg;
}

// .TrackingScan tracking_scan = 29;
inline bool PTZControlProtol::has_tracking_scan() const {
  return content_case() == kTrackingScan;
}
inline bool PTZControlProtol::_internal_has_tracking_scan() const {
  return content_case() == kTrackingScan;
}
inline void PTZControlProtol::set_has_tracking_scan() {
  _impl_._oneof_case_[0] = kTrackingScan;
}
inline void PTZControlProtol::clear_tracking_scan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kTrackingScan) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.tracking_scan_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.tracking_scan_);
    }
    clear_has_content();
  }
}
inline ::TrackingScan* PTZControlProtol::release_tracking_scan() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.tracking_scan)
  if (content_case() == kTrackingScan) {
    clear_has_content();
    auto* temp = _impl_.content_.tracking_scan_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.tracking_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TrackingScan& PTZControlProtol::_internal_tracking_scan() const {
  return content_case() == kTrackingScan ? *_impl_.content_.tracking_scan_ : reinterpret_cast<::TrackingScan&>(::_TrackingScan_default_instance_);
}
inline const ::TrackingScan& PTZControlProtol::tracking_scan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.tracking_scan)
  return _internal_tracking_scan();
}
inline ::TrackingScan* PTZControlProtol::unsafe_arena_release_tracking_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.tracking_scan)
  if (content_case() == kTrackingScan) {
    clear_has_content();
    auto* temp = _impl_.content_.tracking_scan_;
    _impl_.content_.tracking_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_tracking_scan(::TrackingScan* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_tracking_scan();
    _impl_.content_.tracking_scan_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.tracking_scan)
}
inline ::TrackingScan* PTZControlProtol::_internal_mutable_tracking_scan() {
  if (content_case() != kTrackingScan) {
    clear_content();
    set_has_tracking_scan();
    _impl_.content_.tracking_scan_ =
        ::google::protobuf::Message::DefaultConstruct<::TrackingScan>(GetArena());
  }
  return _impl_.content_.tracking_scan_;
}
inline ::TrackingScan* PTZControlProtol::mutable_tracking_scan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TrackingScan* _msg = _internal_mutable_tracking_scan();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.tracking_scan)
  return _msg;
}

// .TrackingScanCmd tracking_scan_cmd = 30;
inline bool PTZControlProtol::has_tracking_scan_cmd() const {
  return content_case() == kTrackingScanCmd;
}
inline bool PTZControlProtol::_internal_has_tracking_scan_cmd() const {
  return content_case() == kTrackingScanCmd;
}
inline void PTZControlProtol::set_has_tracking_scan_cmd() {
  _impl_._oneof_case_[0] = kTrackingScanCmd;
}
inline void PTZControlProtol::clear_tracking_scan_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kTrackingScanCmd) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.tracking_scan_cmd_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.tracking_scan_cmd_);
    }
    clear_has_content();
  }
}
inline ::TrackingScanCmd* PTZControlProtol::release_tracking_scan_cmd() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.tracking_scan_cmd)
  if (content_case() == kTrackingScanCmd) {
    clear_has_content();
    auto* temp = _impl_.content_.tracking_scan_cmd_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.tracking_scan_cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TrackingScanCmd& PTZControlProtol::_internal_tracking_scan_cmd() const {
  return content_case() == kTrackingScanCmd ? *_impl_.content_.tracking_scan_cmd_ : reinterpret_cast<::TrackingScanCmd&>(::_TrackingScanCmd_default_instance_);
}
inline const ::TrackingScanCmd& PTZControlProtol::tracking_scan_cmd() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.tracking_scan_cmd)
  return _internal_tracking_scan_cmd();
}
inline ::TrackingScanCmd* PTZControlProtol::unsafe_arena_release_tracking_scan_cmd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.tracking_scan_cmd)
  if (content_case() == kTrackingScanCmd) {
    clear_has_content();
    auto* temp = _impl_.content_.tracking_scan_cmd_;
    _impl_.content_.tracking_scan_cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_tracking_scan_cmd(::TrackingScanCmd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_tracking_scan_cmd();
    _impl_.content_.tracking_scan_cmd_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.tracking_scan_cmd)
}
inline ::TrackingScanCmd* PTZControlProtol::_internal_mutable_tracking_scan_cmd() {
  if (content_case() != kTrackingScanCmd) {
    clear_content();
    set_has_tracking_scan_cmd();
    _impl_.content_.tracking_scan_cmd_ =
        ::google::protobuf::Message::DefaultConstruct<::TrackingScanCmd>(GetArena());
  }
  return _impl_.content_.tracking_scan_cmd_;
}
inline ::TrackingScanCmd* PTZControlProtol::mutable_tracking_scan_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TrackingScanCmd* _msg = _internal_mutable_tracking_scan_cmd();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.tracking_scan_cmd)
  return _msg;
}

// .LinearScanSettings linear_scan_settings = 31;
inline bool PTZControlProtol::has_linear_scan_settings() const {
  return content_case() == kLinearScanSettings;
}
inline bool PTZControlProtol::_internal_has_linear_scan_settings() const {
  return content_case() == kLinearScanSettings;
}
inline void PTZControlProtol::set_has_linear_scan_settings() {
  _impl_._oneof_case_[0] = kLinearScanSettings;
}
inline void PTZControlProtol::clear_linear_scan_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kLinearScanSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.linear_scan_settings_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.linear_scan_settings_);
    }
    clear_has_content();
  }
}
inline ::LinearScanSettings* PTZControlProtol::release_linear_scan_settings() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.linear_scan_settings)
  if (content_case() == kLinearScanSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.linear_scan_settings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.linear_scan_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LinearScanSettings& PTZControlProtol::_internal_linear_scan_settings() const {
  return content_case() == kLinearScanSettings ? *_impl_.content_.linear_scan_settings_ : reinterpret_cast<::LinearScanSettings&>(::_LinearScanSettings_default_instance_);
}
inline const ::LinearScanSettings& PTZControlProtol::linear_scan_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.linear_scan_settings)
  return _internal_linear_scan_settings();
}
inline ::LinearScanSettings* PTZControlProtol::unsafe_arena_release_linear_scan_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.linear_scan_settings)
  if (content_case() == kLinearScanSettings) {
    clear_has_content();
    auto* temp = _impl_.content_.linear_scan_settings_;
    _impl_.content_.linear_scan_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_linear_scan_settings(::LinearScanSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_linear_scan_settings();
    _impl_.content_.linear_scan_settings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.linear_scan_settings)
}
inline ::LinearScanSettings* PTZControlProtol::_internal_mutable_linear_scan_settings() {
  if (content_case() != kLinearScanSettings) {
    clear_content();
    set_has_linear_scan_settings();
    _impl_.content_.linear_scan_settings_ =
        ::google::protobuf::Message::DefaultConstruct<::LinearScanSettings>(GetArena());
  }
  return _impl_.content_.linear_scan_settings_;
}
inline ::LinearScanSettings* PTZControlProtol::mutable_linear_scan_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LinearScanSettings* _msg = _internal_mutable_linear_scan_settings();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.linear_scan_settings)
  return _msg;
}

// .LinearScanControl linear_scan_control = 32;
inline bool PTZControlProtol::has_linear_scan_control() const {
  return content_case() == kLinearScanControl;
}
inline bool PTZControlProtol::_internal_has_linear_scan_control() const {
  return content_case() == kLinearScanControl;
}
inline void PTZControlProtol::set_has_linear_scan_control() {
  _impl_._oneof_case_[0] = kLinearScanControl;
}
inline void PTZControlProtol::clear_linear_scan_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kLinearScanControl) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.linear_scan_control_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.linear_scan_control_);
    }
    clear_has_content();
  }
}
inline ::LinearScanControl* PTZControlProtol::release_linear_scan_control() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.linear_scan_control)
  if (content_case() == kLinearScanControl) {
    clear_has_content();
    auto* temp = _impl_.content_.linear_scan_control_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.linear_scan_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LinearScanControl& PTZControlProtol::_internal_linear_scan_control() const {
  return content_case() == kLinearScanControl ? *_impl_.content_.linear_scan_control_ : reinterpret_cast<::LinearScanControl&>(::_LinearScanControl_default_instance_);
}
inline const ::LinearScanControl& PTZControlProtol::linear_scan_control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.linear_scan_control)
  return _internal_linear_scan_control();
}
inline ::LinearScanControl* PTZControlProtol::unsafe_arena_release_linear_scan_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.linear_scan_control)
  if (content_case() == kLinearScanControl) {
    clear_has_content();
    auto* temp = _impl_.content_.linear_scan_control_;
    _impl_.content_.linear_scan_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_linear_scan_control(::LinearScanControl* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_linear_scan_control();
    _impl_.content_.linear_scan_control_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.linear_scan_control)
}
inline ::LinearScanControl* PTZControlProtol::_internal_mutable_linear_scan_control() {
  if (content_case() != kLinearScanControl) {
    clear_content();
    set_has_linear_scan_control();
    _impl_.content_.linear_scan_control_ =
        ::google::protobuf::Message::DefaultConstruct<::LinearScanControl>(GetArena());
  }
  return _impl_.content_.linear_scan_control_;
}
inline ::LinearScanControl* PTZControlProtol::mutable_linear_scan_control() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LinearScanControl* _msg = _internal_mutable_linear_scan_control();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.linear_scan_control)
  return _msg;
}

// .Rotation rotation = 33;
inline bool PTZControlProtol::has_rotation() const {
  return content_case() == kRotation;
}
inline bool PTZControlProtol::_internal_has_rotation() const {
  return content_case() == kRotation;
}
inline void PTZControlProtol::set_has_rotation() {
  _impl_._oneof_case_[0] = kRotation;
}
inline void PTZControlProtol::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kRotation) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.rotation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.rotation_);
    }
    clear_has_content();
  }
}
inline ::Rotation* PTZControlProtol::release_rotation() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.rotation)
  if (content_case() == kRotation) {
    clear_has_content();
    auto* temp = _impl_.content_.rotation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.rotation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Rotation& PTZControlProtol::_internal_rotation() const {
  return content_case() == kRotation ? *_impl_.content_.rotation_ : reinterpret_cast<::Rotation&>(::_Rotation_default_instance_);
}
inline const ::Rotation& PTZControlProtol::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.rotation)
  return _internal_rotation();
}
inline ::Rotation* PTZControlProtol::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.rotation)
  if (content_case() == kRotation) {
    clear_has_content();
    auto* temp = _impl_.content_.rotation_;
    _impl_.content_.rotation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_rotation(::Rotation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_rotation();
    _impl_.content_.rotation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.rotation)
}
inline ::Rotation* PTZControlProtol::_internal_mutable_rotation() {
  if (content_case() != kRotation) {
    clear_content();
    set_has_rotation();
    _impl_.content_.rotation_ =
        ::google::protobuf::Message::DefaultConstruct<::Rotation>(GetArena());
  }
  return _impl_.content_.rotation_;
}
inline ::Rotation* PTZControlProtol::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.rotation)
  return _msg;
}

// .LensControl lens_control = 34;
inline bool PTZControlProtol::has_lens_control() const {
  return content_case() == kLensControl;
}
inline bool PTZControlProtol::_internal_has_lens_control() const {
  return content_case() == kLensControl;
}
inline void PTZControlProtol::set_has_lens_control() {
  _impl_._oneof_case_[0] = kLensControl;
}
inline void PTZControlProtol::clear_lens_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kLensControl) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.lens_control_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.lens_control_);
    }
    clear_has_content();
  }
}
inline ::LensControl* PTZControlProtol::release_lens_control() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.lens_control)
  if (content_case() == kLensControl) {
    clear_has_content();
    auto* temp = _impl_.content_.lens_control_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.lens_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LensControl& PTZControlProtol::_internal_lens_control() const {
  return content_case() == kLensControl ? *_impl_.content_.lens_control_ : reinterpret_cast<::LensControl&>(::_LensControl_default_instance_);
}
inline const ::LensControl& PTZControlProtol::lens_control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.lens_control)
  return _internal_lens_control();
}
inline ::LensControl* PTZControlProtol::unsafe_arena_release_lens_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.lens_control)
  if (content_case() == kLensControl) {
    clear_has_content();
    auto* temp = _impl_.content_.lens_control_;
    _impl_.content_.lens_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_lens_control(::LensControl* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_lens_control();
    _impl_.content_.lens_control_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.lens_control)
}
inline ::LensControl* PTZControlProtol::_internal_mutable_lens_control() {
  if (content_case() != kLensControl) {
    clear_content();
    set_has_lens_control();
    _impl_.content_.lens_control_ =
        ::google::protobuf::Message::DefaultConstruct<::LensControl>(GetArena());
  }
  return _impl_.content_.lens_control_;
}
inline ::LensControl* PTZControlProtol::mutable_lens_control() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LensControl* _msg = _internal_mutable_lens_control();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.lens_control)
  return _msg;
}

// .AccessoryControl accessory_control = 35;
inline bool PTZControlProtol::has_accessory_control() const {
  return content_case() == kAccessoryControl;
}
inline bool PTZControlProtol::_internal_has_accessory_control() const {
  return content_case() == kAccessoryControl;
}
inline void PTZControlProtol::set_has_accessory_control() {
  _impl_._oneof_case_[0] = kAccessoryControl;
}
inline void PTZControlProtol::clear_accessory_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kAccessoryControl) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.accessory_control_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.accessory_control_);
    }
    clear_has_content();
  }
}
inline ::AccessoryControl* PTZControlProtol::release_accessory_control() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.accessory_control)
  if (content_case() == kAccessoryControl) {
    clear_has_content();
    auto* temp = _impl_.content_.accessory_control_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.accessory_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AccessoryControl& PTZControlProtol::_internal_accessory_control() const {
  return content_case() == kAccessoryControl ? *_impl_.content_.accessory_control_ : reinterpret_cast<::AccessoryControl&>(::_AccessoryControl_default_instance_);
}
inline const ::AccessoryControl& PTZControlProtol::accessory_control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.accessory_control)
  return _internal_accessory_control();
}
inline ::AccessoryControl* PTZControlProtol::unsafe_arena_release_accessory_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.accessory_control)
  if (content_case() == kAccessoryControl) {
    clear_has_content();
    auto* temp = _impl_.content_.accessory_control_;
    _impl_.content_.accessory_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_accessory_control(::AccessoryControl* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_accessory_control();
    _impl_.content_.accessory_control_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.accessory_control)
}
inline ::AccessoryControl* PTZControlProtol::_internal_mutable_accessory_control() {
  if (content_case() != kAccessoryControl) {
    clear_content();
    set_has_accessory_control();
    _impl_.content_.accessory_control_ =
        ::google::protobuf::Message::DefaultConstruct<::AccessoryControl>(GetArena());
  }
  return _impl_.content_.accessory_control_;
}
inline ::AccessoryControl* PTZControlProtol::mutable_accessory_control() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AccessoryControl* _msg = _internal_mutable_accessory_control();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.accessory_control)
  return _msg;
}

// .Scanning scanning = 36;
inline bool PTZControlProtol::has_scanning() const {
  return content_case() == kScanning;
}
inline bool PTZControlProtol::_internal_has_scanning() const {
  return content_case() == kScanning;
}
inline void PTZControlProtol::set_has_scanning() {
  _impl_._oneof_case_[0] = kScanning;
}
inline void PTZControlProtol::clear_scanning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kScanning) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.scanning_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.scanning_);
    }
    clear_has_content();
  }
}
inline ::Scanning* PTZControlProtol::release_scanning() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.scanning)
  if (content_case() == kScanning) {
    clear_has_content();
    auto* temp = _impl_.content_.scanning_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.scanning_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Scanning& PTZControlProtol::_internal_scanning() const {
  return content_case() == kScanning ? *_impl_.content_.scanning_ : reinterpret_cast<::Scanning&>(::_Scanning_default_instance_);
}
inline const ::Scanning& PTZControlProtol::scanning() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.scanning)
  return _internal_scanning();
}
inline ::Scanning* PTZControlProtol::unsafe_arena_release_scanning() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.scanning)
  if (content_case() == kScanning) {
    clear_has_content();
    auto* temp = _impl_.content_.scanning_;
    _impl_.content_.scanning_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_scanning(::Scanning* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_scanning();
    _impl_.content_.scanning_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.scanning)
}
inline ::Scanning* PTZControlProtol::_internal_mutable_scanning() {
  if (content_case() != kScanning) {
    clear_content();
    set_has_scanning();
    _impl_.content_.scanning_ =
        ::google::protobuf::Message::DefaultConstruct<::Scanning>(GetArena());
  }
  return _impl_.content_.scanning_;
}
inline ::Scanning* PTZControlProtol::mutable_scanning() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Scanning* _msg = _internal_mutable_scanning();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.scanning)
  return _msg;
}

// .ImageModeMessage image_mode_message = 37;
inline bool PTZControlProtol::has_image_mode_message() const {
  return content_case() == kImageModeMessage;
}
inline bool PTZControlProtol::_internal_has_image_mode_message() const {
  return content_case() == kImageModeMessage;
}
inline void PTZControlProtol::set_has_image_mode_message() {
  _impl_._oneof_case_[0] = kImageModeMessage;
}
inline void PTZControlProtol::clear_image_mode_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kImageModeMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.image_mode_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.image_mode_message_);
    }
    clear_has_content();
  }
}
inline ::ImageModeMessage* PTZControlProtol::release_image_mode_message() {
  // @@protoc_insertion_point(field_release:PTZControlProtol.image_mode_message)
  if (content_case() == kImageModeMessage) {
    clear_has_content();
    auto* temp = _impl_.content_.image_mode_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.image_mode_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ImageModeMessage& PTZControlProtol::_internal_image_mode_message() const {
  return content_case() == kImageModeMessage ? *_impl_.content_.image_mode_message_ : reinterpret_cast<::ImageModeMessage&>(::_ImageModeMessage_default_instance_);
}
inline const ::ImageModeMessage& PTZControlProtol::image_mode_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZControlProtol.image_mode_message)
  return _internal_image_mode_message();
}
inline ::ImageModeMessage* PTZControlProtol::unsafe_arena_release_image_mode_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PTZControlProtol.image_mode_message)
  if (content_case() == kImageModeMessage) {
    clear_has_content();
    auto* temp = _impl_.content_.image_mode_message_;
    _impl_.content_.image_mode_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PTZControlProtol::unsafe_arena_set_allocated_image_mode_message(::ImageModeMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_image_mode_message();
    _impl_.content_.image_mode_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTZControlProtol.image_mode_message)
}
inline ::ImageModeMessage* PTZControlProtol::_internal_mutable_image_mode_message() {
  if (content_case() != kImageModeMessage) {
    clear_content();
    set_has_image_mode_message();
    _impl_.content_.image_mode_message_ =
        ::google::protobuf::Message::DefaultConstruct<::ImageModeMessage>(GetArena());
  }
  return _impl_.content_.image_mode_message_;
}
inline ::ImageModeMessage* PTZControlProtol::mutable_image_mode_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ImageModeMessage* _msg = _internal_mutable_image_mode_message();
  // @@protoc_insertion_point(field_mutable:PTZControlProtol.image_mode_message)
  return _msg;
}

inline bool PTZControlProtol::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void PTZControlProtol::clear_has_content() {
  _impl_._oneof_case_[0] = CONTENT_NOT_SET;
}
inline PTZControlProtol::ContentCase PTZControlProtol::content_case() const {
  return PTZControlProtol::ContentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PTZDevice

// string name = 1;
inline void PTZDevice::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PTZDevice::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZDevice.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PTZDevice::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PTZDevice.name)
}
inline std::string* PTZDevice::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PTZDevice.name)
  return _s;
}
inline const std::string& PTZDevice::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PTZDevice::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PTZDevice::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PTZDevice::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PTZDevice.name)
  return _impl_.name_.Release();
}
inline void PTZDevice::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTZDevice.name)
}

// string username = 2;
inline void PTZDevice::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& PTZDevice::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZDevice.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PTZDevice::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PTZDevice.username)
}
inline std::string* PTZDevice::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:PTZDevice.username)
  return _s;
}
inline const std::string& PTZDevice::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void PTZDevice::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* PTZDevice::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* PTZDevice::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PTZDevice.username)
  return _impl_.username_.Release();
}
inline void PTZDevice::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTZDevice.username)
}

// int32 port = 3;
inline void PTZDevice::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t PTZDevice::port() const {
  // @@protoc_insertion_point(field_get:PTZDevice.port)
  return _internal_port();
}
inline void PTZDevice::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PTZDevice.port)
}
inline ::int32_t PTZDevice::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void PTZDevice::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// string ip_address = 4;
inline void PTZDevice::clear_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& PTZDevice::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZDevice.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PTZDevice::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PTZDevice.ip_address)
}
inline std::string* PTZDevice::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:PTZDevice.ip_address)
  return _s;
}
inline const std::string& PTZDevice::_internal_ip_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_address_.Get();
}
inline void PTZDevice::_internal_set_ip_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* PTZDevice::_internal_mutable_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* PTZDevice::release_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PTZDevice.ip_address)
  return _impl_.ip_address_.Release();
}
inline void PTZDevice::set_allocated_ip_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTZDevice.ip_address)
}

// string group = 5;
inline void PTZDevice::clear_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.ClearToEmpty();
}
inline const std::string& PTZDevice::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PTZDevice.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PTZDevice::set_group(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PTZDevice.group)
}
inline std::string* PTZDevice::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:PTZDevice.group)
  return _s;
}
inline const std::string& PTZDevice::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_.Get();
}
inline void PTZDevice::_internal_set_group(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.Set(value, GetArena());
}
inline std::string* PTZDevice::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.group_.Mutable( GetArena());
}
inline std::string* PTZDevice::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PTZDevice.group)
  return _impl_.group_.Release();
}
inline void PTZDevice::set_allocated_group(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTZDevice.group)
}

// .PTZDevice.DeviceStatus status = 6;
inline void PTZDevice::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::PTZDevice_DeviceStatus PTZDevice::status() const {
  // @@protoc_insertion_point(field_get:PTZDevice.status)
  return _internal_status();
}
inline void PTZDevice::set_status(::PTZDevice_DeviceStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:PTZDevice.status)
}
inline ::PTZDevice_DeviceStatus PTZDevice::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::PTZDevice_DeviceStatus>(_impl_.status_);
}
inline void PTZDevice::_internal_set_status(::PTZDevice_DeviceStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// MediaSettings

// .StreamType stream_type = 1;
inline void MediaSettings::clear_stream_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_type_ = 0;
}
inline ::StreamType MediaSettings::stream_type() const {
  // @@protoc_insertion_point(field_get:MediaSettings.stream_type)
  return _internal_stream_type();
}
inline void MediaSettings::set_stream_type(::StreamType value) {
  _internal_set_stream_type(value);
  // @@protoc_insertion_point(field_set:MediaSettings.stream_type)
}
inline ::StreamType MediaSettings::_internal_stream_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::StreamType>(_impl_.stream_type_);
}
inline void MediaSettings::_internal_set_stream_type(::StreamType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_type_ = value;
}

// .VideoStreamType video_stream_type = 2;
inline void MediaSettings::clear_video_stream_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_stream_type_ = 0;
}
inline ::VideoStreamType MediaSettings::video_stream_type() const {
  // @@protoc_insertion_point(field_get:MediaSettings.video_stream_type)
  return _internal_video_stream_type();
}
inline void MediaSettings::set_video_stream_type(::VideoStreamType value) {
  _internal_set_video_stream_type(value);
  // @@protoc_insertion_point(field_set:MediaSettings.video_stream_type)
}
inline ::VideoStreamType MediaSettings::_internal_video_stream_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::VideoStreamType>(_impl_.video_stream_type_);
}
inline void MediaSettings::_internal_set_video_stream_type(::VideoStreamType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_stream_type_ = value;
}

// .Resolution resolution = 3;
inline void MediaSettings::clear_resolution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_ = 0;
}
inline ::Resolution MediaSettings::resolution() const {
  // @@protoc_insertion_point(field_get:MediaSettings.resolution)
  return _internal_resolution();
}
inline void MediaSettings::set_resolution(::Resolution value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:MediaSettings.resolution)
}
inline ::Resolution MediaSettings::_internal_resolution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Resolution>(_impl_.resolution_);
}
inline void MediaSettings::_internal_set_resolution(::Resolution value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_ = value;
}

// .BitrateType bitrate_type = 4;
inline void MediaSettings::clear_bitrate_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_type_ = 0;
}
inline ::BitrateType MediaSettings::bitrate_type() const {
  // @@protoc_insertion_point(field_get:MediaSettings.bitrate_type)
  return _internal_bitrate_type();
}
inline void MediaSettings::set_bitrate_type(::BitrateType value) {
  _internal_set_bitrate_type(value);
  // @@protoc_insertion_point(field_set:MediaSettings.bitrate_type)
}
inline ::BitrateType MediaSettings::_internal_bitrate_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::BitrateType>(_impl_.bitrate_type_);
}
inline void MediaSettings::_internal_set_bitrate_type(::BitrateType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_type_ = value;
}

// int32 bitrate = 5;
inline void MediaSettings::clear_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_ = 0;
}
inline ::int32_t MediaSettings::bitrate() const {
  // @@protoc_insertion_point(field_get:MediaSettings.bitrate)
  return _internal_bitrate();
}
inline void MediaSettings::set_bitrate(::int32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:MediaSettings.bitrate)
}
inline ::int32_t MediaSettings::_internal_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bitrate_;
}
inline void MediaSettings::_internal_set_bitrate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_ = value;
}

// .FrameRate frame_rate = 6;
inline void MediaSettings::clear_frame_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rate_ = 0;
}
inline ::FrameRate MediaSettings::frame_rate() const {
  // @@protoc_insertion_point(field_get:MediaSettings.frame_rate)
  return _internal_frame_rate();
}
inline void MediaSettings::set_frame_rate(::FrameRate value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:MediaSettings.frame_rate)
}
inline ::FrameRate MediaSettings::_internal_frame_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::FrameRate>(_impl_.frame_rate_);
}
inline void MediaSettings::_internal_set_frame_rate(::FrameRate value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rate_ = value;
}

// .VideoCodec encoding_mode = 7;
inline void MediaSettings::clear_encoding_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_mode_ = 0;
}
inline ::VideoCodec MediaSettings::encoding_mode() const {
  // @@protoc_insertion_point(field_get:MediaSettings.encoding_mode)
  return _internal_encoding_mode();
}
inline void MediaSettings::set_encoding_mode(::VideoCodec value) {
  _internal_set_encoding_mode(value);
  // @@protoc_insertion_point(field_set:MediaSettings.encoding_mode)
}
inline ::VideoCodec MediaSettings::_internal_encoding_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::VideoCodec>(_impl_.encoding_mode_);
}
inline void MediaSettings::_internal_set_encoding_mode(::VideoCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_mode_ = value;
}

// int32 iframe_interval = 8;
inline void MediaSettings::clear_iframe_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iframe_interval_ = 0;
}
inline ::int32_t MediaSettings::iframe_interval() const {
  // @@protoc_insertion_point(field_get:MediaSettings.iframe_interval)
  return _internal_iframe_interval();
}
inline void MediaSettings::set_iframe_interval(::int32_t value) {
  _internal_set_iframe_interval(value);
  // @@protoc_insertion_point(field_set:MediaSettings.iframe_interval)
}
inline ::int32_t MediaSettings::_internal_iframe_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.iframe_interval_;
}
inline void MediaSettings::_internal_set_iframe_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iframe_interval_ = value;
}

// bool auxiliary_stream_enabled = 9;
inline void MediaSettings::clear_auxiliary_stream_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auxiliary_stream_enabled_ = false;
}
inline bool MediaSettings::auxiliary_stream_enabled() const {
  // @@protoc_insertion_point(field_get:MediaSettings.auxiliary_stream_enabled)
  return _internal_auxiliary_stream_enabled();
}
inline void MediaSettings::set_auxiliary_stream_enabled(bool value) {
  _internal_set_auxiliary_stream_enabled(value);
  // @@protoc_insertion_point(field_set:MediaSettings.auxiliary_stream_enabled)
}
inline bool MediaSettings::_internal_auxiliary_stream_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auxiliary_stream_enabled_;
}
inline void MediaSettings::_internal_set_auxiliary_stream_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auxiliary_stream_enabled_ = value;
}

// .AudioSource audio_input = 11;
inline void MediaSettings::clear_audio_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_input_ = 0;
}
inline ::AudioSource MediaSettings::audio_input() const {
  // @@protoc_insertion_point(field_get:MediaSettings.audio_input)
  return _internal_audio_input();
}
inline void MediaSettings::set_audio_input(::AudioSource value) {
  _internal_set_audio_input(value);
  // @@protoc_insertion_point(field_set:MediaSettings.audio_input)
}
inline ::AudioSource MediaSettings::_internal_audio_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::AudioSource>(_impl_.audio_input_);
}
inline void MediaSettings::_internal_set_audio_input(::AudioSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_input_ = value;
}

// int32 sampling_rate = 12;
inline void MediaSettings::clear_sampling_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_rate_ = 0;
}
inline ::int32_t MediaSettings::sampling_rate() const {
  // @@protoc_insertion_point(field_get:MediaSettings.sampling_rate)
  return _internal_sampling_rate();
}
inline void MediaSettings::set_sampling_rate(::int32_t value) {
  _internal_set_sampling_rate(value);
  // @@protoc_insertion_point(field_set:MediaSettings.sampling_rate)
}
inline ::int32_t MediaSettings::_internal_sampling_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sampling_rate_;
}
inline void MediaSettings::_internal_set_sampling_rate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_rate_ = value;
}

// bool noise_reduction_enabled = 13;
inline void MediaSettings::clear_noise_reduction_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.noise_reduction_enabled_ = false;
}
inline bool MediaSettings::noise_reduction_enabled() const {
  // @@protoc_insertion_point(field_get:MediaSettings.noise_reduction_enabled)
  return _internal_noise_reduction_enabled();
}
inline void MediaSettings::set_noise_reduction_enabled(bool value) {
  _internal_set_noise_reduction_enabled(value);
  // @@protoc_insertion_point(field_set:MediaSettings.noise_reduction_enabled)
}
inline bool MediaSettings::_internal_noise_reduction_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.noise_reduction_enabled_;
}
inline void MediaSettings::_internal_set_noise_reduction_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.noise_reduction_enabled_ = value;
}

// int32 microphone_volume = 14;
inline void MediaSettings::clear_microphone_volume() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.microphone_volume_ = 0;
}
inline ::int32_t MediaSettings::microphone_volume() const {
  // @@protoc_insertion_point(field_get:MediaSettings.microphone_volume)
  return _internal_microphone_volume();
}
inline void MediaSettings::set_microphone_volume(::int32_t value) {
  _internal_set_microphone_volume(value);
  // @@protoc_insertion_point(field_set:MediaSettings.microphone_volume)
}
inline ::int32_t MediaSettings::_internal_microphone_volume() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.microphone_volume_;
}
inline void MediaSettings::_internal_set_microphone_volume(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.microphone_volume_ = value;
}

// int32 speaker_volume = 15;
inline void MediaSettings::clear_speaker_volume() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speaker_volume_ = 0;
}
inline ::int32_t MediaSettings::speaker_volume() const {
  // @@protoc_insertion_point(field_get:MediaSettings.speaker_volume)
  return _internal_speaker_volume();
}
inline void MediaSettings::set_speaker_volume(::int32_t value) {
  _internal_set_speaker_volume(value);
  // @@protoc_insertion_point(field_set:MediaSettings.speaker_volume)
}
inline ::int32_t MediaSettings::_internal_speaker_volume() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speaker_volume_;
}
inline void MediaSettings::_internal_set_speaker_volume(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speaker_volume_ = value;
}

// -------------------------------------------------------------------

// ImageSettings

// int32 contrast = 1;
inline void ImageSettings::clear_contrast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contrast_ = 0;
}
inline ::int32_t ImageSettings::contrast() const {
  // @@protoc_insertion_point(field_get:ImageSettings.contrast)
  return _internal_contrast();
}
inline void ImageSettings::set_contrast(::int32_t value) {
  _internal_set_contrast(value);
  // @@protoc_insertion_point(field_set:ImageSettings.contrast)
}
inline ::int32_t ImageSettings::_internal_contrast() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contrast_;
}
inline void ImageSettings::_internal_set_contrast(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contrast_ = value;
}

// int32 brightness = 2;
inline void ImageSettings::clear_brightness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brightness_ = 0;
}
inline ::int32_t ImageSettings::brightness() const {
  // @@protoc_insertion_point(field_get:ImageSettings.brightness)
  return _internal_brightness();
}
inline void ImageSettings::set_brightness(::int32_t value) {
  _internal_set_brightness(value);
  // @@protoc_insertion_point(field_set:ImageSettings.brightness)
}
inline ::int32_t ImageSettings::_internal_brightness() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.brightness_;
}
inline void ImageSettings::_internal_set_brightness(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brightness_ = value;
}

// int32 saturation = 3;
inline void ImageSettings::clear_saturation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saturation_ = 0;
}
inline ::int32_t ImageSettings::saturation() const {
  // @@protoc_insertion_point(field_get:ImageSettings.saturation)
  return _internal_saturation();
}
inline void ImageSettings::set_saturation(::int32_t value) {
  _internal_set_saturation(value);
  // @@protoc_insertion_point(field_set:ImageSettings.saturation)
}
inline ::int32_t ImageSettings::_internal_saturation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saturation_;
}
inline void ImageSettings::_internal_set_saturation(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saturation_ = value;
}

// int32 sharpness = 4;
inline void ImageSettings::clear_sharpness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharpness_ = 0;
}
inline ::int32_t ImageSettings::sharpness() const {
  // @@protoc_insertion_point(field_get:ImageSettings.sharpness)
  return _internal_sharpness();
}
inline void ImageSettings::set_sharpness(::int32_t value) {
  _internal_set_sharpness(value);
  // @@protoc_insertion_point(field_set:ImageSettings.sharpness)
}
inline ::int32_t ImageSettings::_internal_sharpness() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sharpness_;
}
inline void ImageSettings::_internal_set_sharpness(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sharpness_ = value;
}

// bool wide_dynamic_range = 5;
inline void ImageSettings::clear_wide_dynamic_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wide_dynamic_range_ = false;
}
inline bool ImageSettings::wide_dynamic_range() const {
  // @@protoc_insertion_point(field_get:ImageSettings.wide_dynamic_range)
  return _internal_wide_dynamic_range();
}
inline void ImageSettings::set_wide_dynamic_range(bool value) {
  _internal_set_wide_dynamic_range(value);
  // @@protoc_insertion_point(field_set:ImageSettings.wide_dynamic_range)
}
inline bool ImageSettings::_internal_wide_dynamic_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wide_dynamic_range_;
}
inline void ImageSettings::_internal_set_wide_dynamic_range(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wide_dynamic_range_ = value;
}

// bool visible_light_enhancement = 6;
inline void ImageSettings::clear_visible_light_enhancement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.visible_light_enhancement_ = false;
}
inline bool ImageSettings::visible_light_enhancement() const {
  // @@protoc_insertion_point(field_get:ImageSettings.visible_light_enhancement)
  return _internal_visible_light_enhancement();
}
inline void ImageSettings::set_visible_light_enhancement(bool value) {
  _internal_set_visible_light_enhancement(value);
  // @@protoc_insertion_point(field_set:ImageSettings.visible_light_enhancement)
}
inline bool ImageSettings::_internal_visible_light_enhancement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.visible_light_enhancement_;
}
inline void ImageSettings::_internal_set_visible_light_enhancement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.visible_light_enhancement_ = value;
}

// .ImageSettings.CaptureType capture_type = 7;
inline void ImageSettings::clear_capture_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_type_ = 0;
}
inline ::ImageSettings_CaptureType ImageSettings::capture_type() const {
  // @@protoc_insertion_point(field_get:ImageSettings.capture_type)
  return _internal_capture_type();
}
inline void ImageSettings::set_capture_type(::ImageSettings_CaptureType value) {
  _internal_set_capture_type(value);
  // @@protoc_insertion_point(field_set:ImageSettings.capture_type)
}
inline ::ImageSettings_CaptureType ImageSettings::_internal_capture_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ImageSettings_CaptureType>(_impl_.capture_type_);
}
inline void ImageSettings::_internal_set_capture_type(::ImageSettings_CaptureType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_type_ = value;
}

// .ImageSettings.ImageQuality image_quality = 9;
inline void ImageSettings::clear_image_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_quality_ = 0;
}
inline ::ImageSettings_ImageQuality ImageSettings::image_quality() const {
  // @@protoc_insertion_point(field_get:ImageSettings.image_quality)
  return _internal_image_quality();
}
inline void ImageSettings::set_image_quality(::ImageSettings_ImageQuality value) {
  _internal_set_image_quality(value);
  // @@protoc_insertion_point(field_set:ImageSettings.image_quality)
}
inline ::ImageSettings_ImageQuality ImageSettings::_internal_image_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ImageSettings_ImageQuality>(_impl_.image_quality_);
}
inline void ImageSettings::_internal_set_image_quality(::ImageSettings_ImageQuality value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_quality_ = value;
}

// -------------------------------------------------------------------

// ImageEnhancement

// .NoiseReduction noise_reduction = 1;
inline bool ImageEnhancement::has_noise_reduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.noise_reduction_ != nullptr);
  return value;
}
inline void ImageEnhancement::clear_noise_reduction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.noise_reduction_ != nullptr) _impl_.noise_reduction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NoiseReduction& ImageEnhancement::_internal_noise_reduction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::NoiseReduction* p = _impl_.noise_reduction_;
  return p != nullptr ? *p : reinterpret_cast<const ::NoiseReduction&>(::_NoiseReduction_default_instance_);
}
inline const ::NoiseReduction& ImageEnhancement::noise_reduction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImageEnhancement.noise_reduction)
  return _internal_noise_reduction();
}
inline void ImageEnhancement::unsafe_arena_set_allocated_noise_reduction(::NoiseReduction* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.noise_reduction_);
  }
  _impl_.noise_reduction_ = reinterpret_cast<::NoiseReduction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ImageEnhancement.noise_reduction)
}
inline ::NoiseReduction* ImageEnhancement::release_noise_reduction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NoiseReduction* released = _impl_.noise_reduction_;
  _impl_.noise_reduction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NoiseReduction* ImageEnhancement::unsafe_arena_release_noise_reduction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ImageEnhancement.noise_reduction)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NoiseReduction* temp = _impl_.noise_reduction_;
  _impl_.noise_reduction_ = nullptr;
  return temp;
}
inline ::NoiseReduction* ImageEnhancement::_internal_mutable_noise_reduction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.noise_reduction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NoiseReduction>(GetArena());
    _impl_.noise_reduction_ = reinterpret_cast<::NoiseReduction*>(p);
  }
  return _impl_.noise_reduction_;
}
inline ::NoiseReduction* ImageEnhancement::mutable_noise_reduction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NoiseReduction* _msg = _internal_mutable_noise_reduction();
  // @@protoc_insertion_point(field_mutable:ImageEnhancement.noise_reduction)
  return _msg;
}
inline void ImageEnhancement::set_allocated_noise_reduction(::NoiseReduction* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.noise_reduction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.noise_reduction_ = reinterpret_cast<::NoiseReduction*>(value);
  // @@protoc_insertion_point(field_set_allocated:ImageEnhancement.noise_reduction)
}

// bool fog_enhancement = 2;
inline void ImageEnhancement::clear_fog_enhancement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fog_enhancement_ = false;
}
inline bool ImageEnhancement::fog_enhancement() const {
  // @@protoc_insertion_point(field_get:ImageEnhancement.fog_enhancement)
  return _internal_fog_enhancement();
}
inline void ImageEnhancement::set_fog_enhancement(bool value) {
  _internal_set_fog_enhancement(value);
  // @@protoc_insertion_point(field_set:ImageEnhancement.fog_enhancement)
}
inline bool ImageEnhancement::_internal_fog_enhancement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fog_enhancement_;
}
inline void ImageEnhancement::_internal_set_fog_enhancement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fog_enhancement_ = value;
}

// bool stabilization = 3;
inline void ImageEnhancement::clear_stabilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stabilization_ = false;
}
inline bool ImageEnhancement::stabilization() const {
  // @@protoc_insertion_point(field_get:ImageEnhancement.stabilization)
  return _internal_stabilization();
}
inline void ImageEnhancement::set_stabilization(bool value) {
  _internal_set_stabilization(value);
  // @@protoc_insertion_point(field_set:ImageEnhancement.stabilization)
}
inline bool ImageEnhancement::_internal_stabilization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stabilization_;
}
inline void ImageEnhancement::_internal_set_stabilization(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stabilization_ = value;
}

// int32 gray_range = 4;
inline void ImageEnhancement::clear_gray_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gray_range_ = 0;
}
inline ::int32_t ImageEnhancement::gray_range() const {
  // @@protoc_insertion_point(field_get:ImageEnhancement.gray_range)
  return _internal_gray_range();
}
inline void ImageEnhancement::set_gray_range(::int32_t value) {
  _internal_set_gray_range(value);
  // @@protoc_insertion_point(field_set:ImageEnhancement.gray_range)
}
inline ::int32_t ImageEnhancement::_internal_gray_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gray_range_;
}
inline void ImageEnhancement::_internal_set_gray_range(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gray_range_ = value;
}

// -------------------------------------------------------------------

// NoiseReduction

// bool enabled = 1;
inline void NoiseReduction::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool NoiseReduction::enabled() const {
  // @@protoc_insertion_point(field_get:NoiseReduction.enabled)
  return _internal_enabled();
}
inline void NoiseReduction::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:NoiseReduction.enabled)
}
inline bool NoiseReduction::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void NoiseReduction::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// int32 level = 2;
inline void NoiseReduction::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::int32_t NoiseReduction::level() const {
  // @@protoc_insertion_point(field_get:NoiseReduction.level)
  return _internal_level();
}
inline void NoiseReduction::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:NoiseReduction.level)
}
inline ::int32_t NoiseReduction::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void NoiseReduction::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// VideoAdjustment

// .VideoAdjustment.MirrorSetting mirror_setting = 1;
inline void VideoAdjustment::clear_mirror_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mirror_setting_ = 0;
}
inline ::VideoAdjustment_MirrorSetting VideoAdjustment::mirror_setting() const {
  // @@protoc_insertion_point(field_get:VideoAdjustment.mirror_setting)
  return _internal_mirror_setting();
}
inline void VideoAdjustment::set_mirror_setting(::VideoAdjustment_MirrorSetting value) {
  _internal_set_mirror_setting(value);
  // @@protoc_insertion_point(field_set:VideoAdjustment.mirror_setting)
}
inline ::VideoAdjustment_MirrorSetting VideoAdjustment::_internal_mirror_setting() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::VideoAdjustment_MirrorSetting>(_impl_.mirror_setting_);
}
inline void VideoAdjustment::_internal_set_mirror_setting(::VideoAdjustment_MirrorSetting value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mirror_setting_ = value;
}

// .VideoAdjustment.StabilizationSetting stabilization_setting = 2;
inline void VideoAdjustment::clear_stabilization_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stabilization_setting_ = 0;
}
inline ::VideoAdjustment_StabilizationSetting VideoAdjustment::stabilization_setting() const {
  // @@protoc_insertion_point(field_get:VideoAdjustment.stabilization_setting)
  return _internal_stabilization_setting();
}
inline void VideoAdjustment::set_stabilization_setting(::VideoAdjustment_StabilizationSetting value) {
  _internal_set_stabilization_setting(value);
  // @@protoc_insertion_point(field_set:VideoAdjustment.stabilization_setting)
}
inline ::VideoAdjustment_StabilizationSetting VideoAdjustment::_internal_stabilization_setting() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::VideoAdjustment_StabilizationSetting>(_impl_.stabilization_setting_);
}
inline void VideoAdjustment::_internal_set_stabilization_setting(::VideoAdjustment_StabilizationSetting value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stabilization_setting_ = value;
}

// -------------------------------------------------------------------

// ExposureSettings

// .ExposureSettings.ExposureMode exposure_mode = 1;
inline void ExposureSettings::clear_exposure_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exposure_mode_ = 0;
}
inline ::ExposureSettings_ExposureMode ExposureSettings::exposure_mode() const {
  // @@protoc_insertion_point(field_get:ExposureSettings.exposure_mode)
  return _internal_exposure_mode();
}
inline void ExposureSettings::set_exposure_mode(::ExposureSettings_ExposureMode value) {
  _internal_set_exposure_mode(value);
  // @@protoc_insertion_point(field_set:ExposureSettings.exposure_mode)
}
inline ::ExposureSettings_ExposureMode ExposureSettings::_internal_exposure_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ExposureSettings_ExposureMode>(_impl_.exposure_mode_);
}
inline void ExposureSettings::_internal_set_exposure_mode(::ExposureSettings_ExposureMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exposure_mode_ = value;
}

// int32 exposure_time = 2;
inline void ExposureSettings::clear_exposure_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exposure_time_ = 0;
}
inline ::int32_t ExposureSettings::exposure_time() const {
  // @@protoc_insertion_point(field_get:ExposureSettings.exposure_time)
  return _internal_exposure_time();
}
inline void ExposureSettings::set_exposure_time(::int32_t value) {
  _internal_set_exposure_time(value);
  // @@protoc_insertion_point(field_set:ExposureSettings.exposure_time)
}
inline ::int32_t ExposureSettings::_internal_exposure_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exposure_time_;
}
inline void ExposureSettings::_internal_set_exposure_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exposure_time_ = value;
}

// -------------------------------------------------------------------

// DayNightSwitchSettings

// .DayNightSwitchSettings.Mode mode = 1;
inline void DayNightSwitchSettings::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::DayNightSwitchSettings_Mode DayNightSwitchSettings::mode() const {
  // @@protoc_insertion_point(field_get:DayNightSwitchSettings.mode)
  return _internal_mode();
}
inline void DayNightSwitchSettings::set_mode(::DayNightSwitchSettings_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:DayNightSwitchSettings.mode)
}
inline ::DayNightSwitchSettings_Mode DayNightSwitchSettings::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::DayNightSwitchSettings_Mode>(_impl_.mode_);
}
inline void DayNightSwitchSettings::_internal_set_mode(::DayNightSwitchSettings_Mode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// string start_time = 2;
inline void DayNightSwitchSettings::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.ClearToEmpty();
}
inline const std::string& DayNightSwitchSettings::start_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DayNightSwitchSettings.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DayNightSwitchSettings::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DayNightSwitchSettings.start_time)
}
inline std::string* DayNightSwitchSettings::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:DayNightSwitchSettings.start_time)
  return _s;
}
inline const std::string& DayNightSwitchSettings::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_.Get();
}
inline void DayNightSwitchSettings::_internal_set_start_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.Set(value, GetArena());
}
inline std::string* DayNightSwitchSettings::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.start_time_.Mutable( GetArena());
}
inline std::string* DayNightSwitchSettings::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DayNightSwitchSettings.start_time)
  return _impl_.start_time_.Release();
}
inline void DayNightSwitchSettings::set_allocated_start_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_time_.IsDefault()) {
          _impl_.start_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DayNightSwitchSettings.start_time)
}

// string end_time = 3;
inline void DayNightSwitchSettings::clear_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.ClearToEmpty();
}
inline const std::string& DayNightSwitchSettings::end_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DayNightSwitchSettings.end_time)
  return _internal_end_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DayNightSwitchSettings::set_end_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DayNightSwitchSettings.end_time)
}
inline std::string* DayNightSwitchSettings::mutable_end_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:DayNightSwitchSettings.end_time)
  return _s;
}
inline const std::string& DayNightSwitchSettings::_internal_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_time_.Get();
}
inline void DayNightSwitchSettings::_internal_set_end_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.Set(value, GetArena());
}
inline std::string* DayNightSwitchSettings::_internal_mutable_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.end_time_.Mutable( GetArena());
}
inline std::string* DayNightSwitchSettings::release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DayNightSwitchSettings.end_time)
  return _impl_.end_time_.Release();
}
inline void DayNightSwitchSettings::set_allocated_end_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_time_.IsDefault()) {
          _impl_.end_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DayNightSwitchSettings.end_time)
}

// -------------------------------------------------------------------

// WhiteBalanceSettings_ManualWhiteBalance

// int32 red_gain = 1;
inline void WhiteBalanceSettings_ManualWhiteBalance::clear_red_gain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_gain_ = 0;
}
inline ::int32_t WhiteBalanceSettings_ManualWhiteBalance::red_gain() const {
  // @@protoc_insertion_point(field_get:WhiteBalanceSettings.ManualWhiteBalance.red_gain)
  return _internal_red_gain();
}
inline void WhiteBalanceSettings_ManualWhiteBalance::set_red_gain(::int32_t value) {
  _internal_set_red_gain(value);
  // @@protoc_insertion_point(field_set:WhiteBalanceSettings.ManualWhiteBalance.red_gain)
}
inline ::int32_t WhiteBalanceSettings_ManualWhiteBalance::_internal_red_gain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.red_gain_;
}
inline void WhiteBalanceSettings_ManualWhiteBalance::_internal_set_red_gain(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_gain_ = value;
}

// int32 blue_gain = 2;
inline void WhiteBalanceSettings_ManualWhiteBalance::clear_blue_gain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_gain_ = 0;
}
inline ::int32_t WhiteBalanceSettings_ManualWhiteBalance::blue_gain() const {
  // @@protoc_insertion_point(field_get:WhiteBalanceSettings.ManualWhiteBalance.blue_gain)
  return _internal_blue_gain();
}
inline void WhiteBalanceSettings_ManualWhiteBalance::set_blue_gain(::int32_t value) {
  _internal_set_blue_gain(value);
  // @@protoc_insertion_point(field_set:WhiteBalanceSettings.ManualWhiteBalance.blue_gain)
}
inline ::int32_t WhiteBalanceSettings_ManualWhiteBalance::_internal_blue_gain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blue_gain_;
}
inline void WhiteBalanceSettings_ManualWhiteBalance::_internal_set_blue_gain(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_gain_ = value;
}

// -------------------------------------------------------------------

// WhiteBalanceSettings

// .WhiteBalanceSettings.WhiteBalanceMode white_balance_mode = 1;
inline void WhiteBalanceSettings::clear_white_balance_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.white_balance_mode_ = 0;
}
inline ::WhiteBalanceSettings_WhiteBalanceMode WhiteBalanceSettings::white_balance_mode() const {
  // @@protoc_insertion_point(field_get:WhiteBalanceSettings.white_balance_mode)
  return _internal_white_balance_mode();
}
inline void WhiteBalanceSettings::set_white_balance_mode(::WhiteBalanceSettings_WhiteBalanceMode value) {
  _internal_set_white_balance_mode(value);
  // @@protoc_insertion_point(field_set:WhiteBalanceSettings.white_balance_mode)
}
inline ::WhiteBalanceSettings_WhiteBalanceMode WhiteBalanceSettings::_internal_white_balance_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::WhiteBalanceSettings_WhiteBalanceMode>(_impl_.white_balance_mode_);
}
inline void WhiteBalanceSettings::_internal_set_white_balance_mode(::WhiteBalanceSettings_WhiteBalanceMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.white_balance_mode_ = value;
}

// .WhiteBalanceSettings.ManualWhiteBalance manual_white_balance = 2;
inline bool WhiteBalanceSettings::has_manual_white_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.manual_white_balance_ != nullptr);
  return value;
}
inline void WhiteBalanceSettings::clear_manual_white_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.manual_white_balance_ != nullptr) _impl_.manual_white_balance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::WhiteBalanceSettings_ManualWhiteBalance& WhiteBalanceSettings::_internal_manual_white_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::WhiteBalanceSettings_ManualWhiteBalance* p = _impl_.manual_white_balance_;
  return p != nullptr ? *p : reinterpret_cast<const ::WhiteBalanceSettings_ManualWhiteBalance&>(::_WhiteBalanceSettings_ManualWhiteBalance_default_instance_);
}
inline const ::WhiteBalanceSettings_ManualWhiteBalance& WhiteBalanceSettings::manual_white_balance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:WhiteBalanceSettings.manual_white_balance)
  return _internal_manual_white_balance();
}
inline void WhiteBalanceSettings::unsafe_arena_set_allocated_manual_white_balance(::WhiteBalanceSettings_ManualWhiteBalance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.manual_white_balance_);
  }
  _impl_.manual_white_balance_ = reinterpret_cast<::WhiteBalanceSettings_ManualWhiteBalance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WhiteBalanceSettings.manual_white_balance)
}
inline ::WhiteBalanceSettings_ManualWhiteBalance* WhiteBalanceSettings::release_manual_white_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::WhiteBalanceSettings_ManualWhiteBalance* released = _impl_.manual_white_balance_;
  _impl_.manual_white_balance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::WhiteBalanceSettings_ManualWhiteBalance* WhiteBalanceSettings::unsafe_arena_release_manual_white_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:WhiteBalanceSettings.manual_white_balance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::WhiteBalanceSettings_ManualWhiteBalance* temp = _impl_.manual_white_balance_;
  _impl_.manual_white_balance_ = nullptr;
  return temp;
}
inline ::WhiteBalanceSettings_ManualWhiteBalance* WhiteBalanceSettings::_internal_mutable_manual_white_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.manual_white_balance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::WhiteBalanceSettings_ManualWhiteBalance>(GetArena());
    _impl_.manual_white_balance_ = reinterpret_cast<::WhiteBalanceSettings_ManualWhiteBalance*>(p);
  }
  return _impl_.manual_white_balance_;
}
inline ::WhiteBalanceSettings_ManualWhiteBalance* WhiteBalanceSettings::mutable_manual_white_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::WhiteBalanceSettings_ManualWhiteBalance* _msg = _internal_mutable_manual_white_balance();
  // @@protoc_insertion_point(field_mutable:WhiteBalanceSettings.manual_white_balance)
  return _msg;
}
inline void WhiteBalanceSettings::set_allocated_manual_white_balance(::WhiteBalanceSettings_ManualWhiteBalance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.manual_white_balance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.manual_white_balance_ = reinterpret_cast<::WhiteBalanceSettings_ManualWhiteBalance*>(value);
  // @@protoc_insertion_point(field_set_allocated:WhiteBalanceSettings.manual_white_balance)
}

// -------------------------------------------------------------------

// InfraredImageSettings

// int32 brightness = 1;
inline void InfraredImageSettings::clear_brightness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brightness_ = 0;
}
inline ::int32_t InfraredImageSettings::brightness() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.brightness)
  return _internal_brightness();
}
inline void InfraredImageSettings::set_brightness(::int32_t value) {
  _internal_set_brightness(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.brightness)
}
inline ::int32_t InfraredImageSettings::_internal_brightness() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.brightness_;
}
inline void InfraredImageSettings::_internal_set_brightness(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brightness_ = value;
}

// int32 contrast = 2;
inline void InfraredImageSettings::clear_contrast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contrast_ = 0;
}
inline ::int32_t InfraredImageSettings::contrast() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.contrast)
  return _internal_contrast();
}
inline void InfraredImageSettings::set_contrast(::int32_t value) {
  _internal_set_contrast(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.contrast)
}
inline ::int32_t InfraredImageSettings::_internal_contrast() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contrast_;
}
inline void InfraredImageSettings::_internal_set_contrast(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contrast_ = value;
}

// int32 denoise = 3;
inline void InfraredImageSettings::clear_denoise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.denoise_ = 0;
}
inline ::int32_t InfraredImageSettings::denoise() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.denoise)
  return _internal_denoise();
}
inline void InfraredImageSettings::set_denoise(::int32_t value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.denoise)
}
inline ::int32_t InfraredImageSettings::_internal_denoise() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.denoise_;
}
inline void InfraredImageSettings::_internal_set_denoise(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.denoise_ = value;
}

// int32 intensity = 4;
inline void InfraredImageSettings::clear_intensity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intensity_ = 0;
}
inline ::int32_t InfraredImageSettings::intensity() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.intensity)
  return _internal_intensity();
}
inline void InfraredImageSettings::set_intensity(::int32_t value) {
  _internal_set_intensity(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.intensity)
}
inline ::int32_t InfraredImageSettings::_internal_intensity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intensity_;
}
inline void InfraredImageSettings::_internal_set_intensity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intensity_ = value;
}

// bool detail_enhancement = 5;
inline void InfraredImageSettings::clear_detail_enhancement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_enhancement_ = false;
}
inline bool InfraredImageSettings::detail_enhancement() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.detail_enhancement)
  return _internal_detail_enhancement();
}
inline void InfraredImageSettings::set_detail_enhancement(bool value) {
  _internal_set_detail_enhancement(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.detail_enhancement)
}
inline bool InfraredImageSettings::_internal_detail_enhancement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detail_enhancement_;
}
inline void InfraredImageSettings::_internal_set_detail_enhancement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_enhancement_ = value;
}

// bool edge_enhancement = 6;
inline void InfraredImageSettings::clear_edge_enhancement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edge_enhancement_ = false;
}
inline bool InfraredImageSettings::edge_enhancement() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.edge_enhancement)
  return _internal_edge_enhancement();
}
inline void InfraredImageSettings::set_edge_enhancement(bool value) {
  _internal_set_edge_enhancement(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.edge_enhancement)
}
inline bool InfraredImageSettings::_internal_edge_enhancement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.edge_enhancement_;
}
inline void InfraredImageSettings::_internal_set_edge_enhancement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edge_enhancement_ = value;
}

// bool stripe_filter = 7;
inline void InfraredImageSettings::clear_stripe_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stripe_filter_ = false;
}
inline bool InfraredImageSettings::stripe_filter() const {
  // @@protoc_insertion_point(field_get:InfraredImageSettings.stripe_filter)
  return _internal_stripe_filter();
}
inline void InfraredImageSettings::set_stripe_filter(bool value) {
  _internal_set_stripe_filter(value);
  // @@protoc_insertion_point(field_set:InfraredImageSettings.stripe_filter)
}
inline bool InfraredImageSettings::_internal_stripe_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stripe_filter_;
}
inline void InfraredImageSettings::_internal_set_stripe_filter(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stripe_filter_ = value;
}

// -------------------------------------------------------------------

// OSDSettings

// bool enabled = 1;
inline void OSDSettings::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool OSDSettings::enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.enabled)
  return _internal_enabled();
}
inline void OSDSettings::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.enabled)
}
inline bool OSDSettings::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void OSDSettings::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// string name = 2;
inline void OSDSettings::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OSDSettings::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:OSDSettings.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OSDSettings::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:OSDSettings.name)
}
inline std::string* OSDSettings::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:OSDSettings.name)
  return _s;
}
inline const std::string& OSDSettings::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void OSDSettings::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* OSDSettings::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* OSDSettings::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:OSDSettings.name)
  return _impl_.name_.Release();
}
inline void OSDSettings::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OSDSettings.name)
}

// bool time_enabled = 3;
inline void OSDSettings::clear_time_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_enabled_ = false;
}
inline bool OSDSettings::time_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.time_enabled)
  return _internal_time_enabled();
}
inline void OSDSettings::set_time_enabled(bool value) {
  _internal_set_time_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.time_enabled)
}
inline bool OSDSettings::_internal_time_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_enabled_;
}
inline void OSDSettings::_internal_set_time_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_enabled_ = value;
}

// bool show_weekday = 4;
inline void OSDSettings::clear_show_weekday() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.show_weekday_ = false;
}
inline bool OSDSettings::show_weekday() const {
  // @@protoc_insertion_point(field_get:OSDSettings.show_weekday)
  return _internal_show_weekday();
}
inline void OSDSettings::set_show_weekday(bool value) {
  _internal_set_show_weekday(value);
  // @@protoc_insertion_point(field_set:OSDSettings.show_weekday)
}
inline bool OSDSettings::_internal_show_weekday() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.show_weekday_;
}
inline void OSDSettings::_internal_set_show_weekday(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.show_weekday_ = value;
}

// .OSDSettings.TimeFormat time_format = 5;
inline void OSDSettings::clear_time_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_format_ = 0;
}
inline ::OSDSettings_TimeFormat OSDSettings::time_format() const {
  // @@protoc_insertion_point(field_get:OSDSettings.time_format)
  return _internal_time_format();
}
inline void OSDSettings::set_time_format(::OSDSettings_TimeFormat value) {
  _internal_set_time_format(value);
  // @@protoc_insertion_point(field_set:OSDSettings.time_format)
}
inline ::OSDSettings_TimeFormat OSDSettings::_internal_time_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::OSDSettings_TimeFormat>(_impl_.time_format_);
}
inline void OSDSettings::_internal_set_time_format(::OSDSettings_TimeFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_format_ = value;
}

// .OSDSettings.DateFormat date_format = 6;
inline void OSDSettings::clear_date_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_format_ = 0;
}
inline ::OSDSettings_DateFormat OSDSettings::date_format() const {
  // @@protoc_insertion_point(field_get:OSDSettings.date_format)
  return _internal_date_format();
}
inline void OSDSettings::set_date_format(::OSDSettings_DateFormat value) {
  _internal_set_date_format(value);
  // @@protoc_insertion_point(field_set:OSDSettings.date_format)
}
inline ::OSDSettings_DateFormat OSDSettings::_internal_date_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::OSDSettings_DateFormat>(_impl_.date_format_);
}
inline void OSDSettings::_internal_set_date_format(::OSDSettings_DateFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_format_ = value;
}

// bool preset_enabled = 7;
inline void OSDSettings::clear_preset_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_enabled_ = false;
}
inline bool OSDSettings::preset_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.preset_enabled)
  return _internal_preset_enabled();
}
inline void OSDSettings::set_preset_enabled(bool value) {
  _internal_set_preset_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.preset_enabled)
}
inline bool OSDSettings::_internal_preset_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preset_enabled_;
}
inline void OSDSettings::_internal_set_preset_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_enabled_ = value;
}

// bool zoom_enabled = 8;
inline void OSDSettings::clear_zoom_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_enabled_ = false;
}
inline bool OSDSettings::zoom_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.zoom_enabled)
  return _internal_zoom_enabled();
}
inline void OSDSettings::set_zoom_enabled(bool value) {
  _internal_set_zoom_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.zoom_enabled)
}
inline bool OSDSettings::_internal_zoom_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zoom_enabled_;
}
inline void OSDSettings::_internal_set_zoom_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_enabled_ = value;
}

// bool cruise_enabled = 9;
inline void OSDSettings::clear_cruise_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cruise_enabled_ = false;
}
inline bool OSDSettings::cruise_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.cruise_enabled)
  return _internal_cruise_enabled();
}
inline void OSDSettings::set_cruise_enabled(bool value) {
  _internal_set_cruise_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.cruise_enabled)
}
inline bool OSDSettings::_internal_cruise_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cruise_enabled_;
}
inline void OSDSettings::_internal_set_cruise_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cruise_enabled_ = value;
}

// bool tracking_enabled = 10;
inline void OSDSettings::clear_tracking_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tracking_enabled_ = false;
}
inline bool OSDSettings::tracking_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.tracking_enabled)
  return _internal_tracking_enabled();
}
inline void OSDSettings::set_tracking_enabled(bool value) {
  _internal_set_tracking_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.tracking_enabled)
}
inline bool OSDSettings::_internal_tracking_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tracking_enabled_;
}
inline void OSDSettings::_internal_set_tracking_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tracking_enabled_ = value;
}

// bool scan_enabled = 11;
inline void OSDSettings::clear_scan_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_enabled_ = false;
}
inline bool OSDSettings::scan_enabled() const {
  // @@protoc_insertion_point(field_get:OSDSettings.scan_enabled)
  return _internal_scan_enabled();
}
inline void OSDSettings::set_scan_enabled(bool value) {
  _internal_set_scan_enabled(value);
  // @@protoc_insertion_point(field_set:OSDSettings.scan_enabled)
}
inline bool OSDSettings::_internal_scan_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scan_enabled_;
}
inline void OSDSettings::_internal_set_scan_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_enabled_ = value;
}

// .OSDSettings.Size size = 12;
inline void OSDSettings::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
}
inline ::OSDSettings_Size OSDSettings::size() const {
  // @@protoc_insertion_point(field_get:OSDSettings.size)
  return _internal_size();
}
inline void OSDSettings::set_size(::OSDSettings_Size value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:OSDSettings.size)
}
inline ::OSDSettings_Size OSDSettings::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::OSDSettings_Size>(_impl_.size_);
}
inline void OSDSettings::_internal_set_size(::OSDSettings_Size value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// .OSDSettings.Color color = 13;
inline void OSDSettings::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0;
}
inline ::OSDSettings_Color OSDSettings::color() const {
  // @@protoc_insertion_point(field_get:OSDSettings.color)
  return _internal_color();
}
inline void OSDSettings::set_color(::OSDSettings_Color value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:OSDSettings.color)
}
inline ::OSDSettings_Color OSDSettings::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::OSDSettings_Color>(_impl_.color_);
}
inline void OSDSettings::_internal_set_color(::OSDSettings_Color value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .OSDSettings.Alignment alignment = 14;
inline void OSDSettings::clear_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = 0;
}
inline ::OSDSettings_Alignment OSDSettings::alignment() const {
  // @@protoc_insertion_point(field_get:OSDSettings.alignment)
  return _internal_alignment();
}
inline void OSDSettings::set_alignment(::OSDSettings_Alignment value) {
  _internal_set_alignment(value);
  // @@protoc_insertion_point(field_set:OSDSettings.alignment)
}
inline ::OSDSettings_Alignment OSDSettings::_internal_alignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::OSDSettings_Alignment>(_impl_.alignment_);
}
inline void OSDSettings::_internal_set_alignment(::OSDSettings_Alignment value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = value;
}

// -------------------------------------------------------------------

// IPSettings_IPv4Config

// string ip_address = 1;
inline void IPSettings_IPv4Config::clear_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv4Config::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv4Config.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv4Config::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv4Config.ip_address)
}
inline std::string* IPSettings_IPv4Config::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv4Config.ip_address)
  return _s;
}
inline const std::string& IPSettings_IPv4Config::_internal_ip_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_address_.Get();
}
inline void IPSettings_IPv4Config::_internal_set_ip_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv4Config::_internal_mutable_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv4Config::release_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv4Config.ip_address)
  return _impl_.ip_address_.Release();
}
inline void IPSettings_IPv4Config::set_allocated_ip_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv4Config.ip_address)
}

// string subnet_mask = 2;
inline void IPSettings_IPv4Config::clear_subnet_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_mask_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv4Config::subnet_mask() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv4Config.subnet_mask)
  return _internal_subnet_mask();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv4Config::set_subnet_mask(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_mask_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv4Config.subnet_mask)
}
inline std::string* IPSettings_IPv4Config::mutable_subnet_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subnet_mask();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv4Config.subnet_mask)
  return _s;
}
inline const std::string& IPSettings_IPv4Config::_internal_subnet_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subnet_mask_.Get();
}
inline void IPSettings_IPv4Config::_internal_set_subnet_mask(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_mask_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv4Config::_internal_mutable_subnet_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.subnet_mask_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv4Config::release_subnet_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv4Config.subnet_mask)
  return _impl_.subnet_mask_.Release();
}
inline void IPSettings_IPv4Config::set_allocated_subnet_mask(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_mask_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subnet_mask_.IsDefault()) {
          _impl_.subnet_mask_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv4Config.subnet_mask)
}

// string default_gateway = 3;
inline void IPSettings_IPv4Config::clear_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv4Config::default_gateway() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv4Config.default_gateway)
  return _internal_default_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv4Config::set_default_gateway(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv4Config.default_gateway)
}
inline std::string* IPSettings_IPv4Config::mutable_default_gateway() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_gateway();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv4Config.default_gateway)
  return _s;
}
inline const std::string& IPSettings_IPv4Config::_internal_default_gateway() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_gateway_.Get();
}
inline void IPSettings_IPv4Config::_internal_set_default_gateway(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv4Config::_internal_mutable_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.default_gateway_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv4Config::release_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv4Config.default_gateway)
  return _impl_.default_gateway_.Release();
}
inline void IPSettings_IPv4Config::set_allocated_default_gateway(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_gateway_.IsDefault()) {
          _impl_.default_gateway_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv4Config.default_gateway)
}

// string primary_dns = 4;
inline void IPSettings_IPv4Config::clear_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv4Config::primary_dns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv4Config.primary_dns)
  return _internal_primary_dns();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv4Config::set_primary_dns(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv4Config.primary_dns)
}
inline std::string* IPSettings_IPv4Config::mutable_primary_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_dns();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv4Config.primary_dns)
  return _s;
}
inline const std::string& IPSettings_IPv4Config::_internal_primary_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_dns_.Get();
}
inline void IPSettings_IPv4Config::_internal_set_primary_dns(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv4Config::_internal_mutable_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_dns_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv4Config::release_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv4Config.primary_dns)
  return _impl_.primary_dns_.Release();
}
inline void IPSettings_IPv4Config::set_allocated_primary_dns(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.primary_dns_.IsDefault()) {
          _impl_.primary_dns_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv4Config.primary_dns)
}

// string secondary_dns = 5;
inline void IPSettings_IPv4Config::clear_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv4Config::secondary_dns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv4Config.secondary_dns)
  return _internal_secondary_dns();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv4Config::set_secondary_dns(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv4Config.secondary_dns)
}
inline std::string* IPSettings_IPv4Config::mutable_secondary_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secondary_dns();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv4Config.secondary_dns)
  return _s;
}
inline const std::string& IPSettings_IPv4Config::_internal_secondary_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secondary_dns_.Get();
}
inline void IPSettings_IPv4Config::_internal_set_secondary_dns(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv4Config::_internal_mutable_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secondary_dns_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv4Config::release_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv4Config.secondary_dns)
  return _impl_.secondary_dns_.Release();
}
inline void IPSettings_IPv4Config::set_allocated_secondary_dns(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secondary_dns_.IsDefault()) {
          _impl_.secondary_dns_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv4Config.secondary_dns)
}

// -------------------------------------------------------------------

// IPSettings_IPv6Config

// string ip_address = 1;
inline void IPSettings_IPv6Config::clear_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv6Config::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv6Config.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv6Config::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv6Config.ip_address)
}
inline std::string* IPSettings_IPv6Config::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv6Config.ip_address)
  return _s;
}
inline const std::string& IPSettings_IPv6Config::_internal_ip_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_address_.Get();
}
inline void IPSettings_IPv6Config::_internal_set_ip_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv6Config::_internal_mutable_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv6Config::release_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv6Config.ip_address)
  return _impl_.ip_address_.Release();
}
inline void IPSettings_IPv6Config::set_allocated_ip_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv6Config.ip_address)
}

// string subnet_prefix = 2;
inline void IPSettings_IPv6Config::clear_subnet_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_prefix_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv6Config::subnet_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv6Config.subnet_prefix)
  return _internal_subnet_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv6Config::set_subnet_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv6Config.subnet_prefix)
}
inline std::string* IPSettings_IPv6Config::mutable_subnet_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subnet_prefix();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv6Config.subnet_prefix)
  return _s;
}
inline const std::string& IPSettings_IPv6Config::_internal_subnet_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subnet_prefix_.Get();
}
inline void IPSettings_IPv6Config::_internal_set_subnet_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_prefix_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv6Config::_internal_mutable_subnet_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.subnet_prefix_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv6Config::release_subnet_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv6Config.subnet_prefix)
  return _impl_.subnet_prefix_.Release();
}
inline void IPSettings_IPv6Config::set_allocated_subnet_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subnet_prefix_.IsDefault()) {
          _impl_.subnet_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv6Config.subnet_prefix)
}

// string default_gateway = 3;
inline void IPSettings_IPv6Config::clear_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv6Config::default_gateway() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv6Config.default_gateway)
  return _internal_default_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv6Config::set_default_gateway(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv6Config.default_gateway)
}
inline std::string* IPSettings_IPv6Config::mutable_default_gateway() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_gateway();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv6Config.default_gateway)
  return _s;
}
inline const std::string& IPSettings_IPv6Config::_internal_default_gateway() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_gateway_.Get();
}
inline void IPSettings_IPv6Config::_internal_set_default_gateway(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv6Config::_internal_mutable_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.default_gateway_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv6Config::release_default_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv6Config.default_gateway)
  return _impl_.default_gateway_.Release();
}
inline void IPSettings_IPv6Config::set_allocated_default_gateway(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_gateway_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_gateway_.IsDefault()) {
          _impl_.default_gateway_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv6Config.default_gateway)
}

// string primary_dns = 4;
inline void IPSettings_IPv6Config::clear_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv6Config::primary_dns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv6Config.primary_dns)
  return _internal_primary_dns();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv6Config::set_primary_dns(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv6Config.primary_dns)
}
inline std::string* IPSettings_IPv6Config::mutable_primary_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_dns();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv6Config.primary_dns)
  return _s;
}
inline const std::string& IPSettings_IPv6Config::_internal_primary_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_dns_.Get();
}
inline void IPSettings_IPv6Config::_internal_set_primary_dns(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv6Config::_internal_mutable_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_dns_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv6Config::release_primary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv6Config.primary_dns)
  return _impl_.primary_dns_.Release();
}
inline void IPSettings_IPv6Config::set_allocated_primary_dns(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_dns_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.primary_dns_.IsDefault()) {
          _impl_.primary_dns_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv6Config.primary_dns)
}

// string secondary_dns = 5;
inline void IPSettings_IPv6Config::clear_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.ClearToEmpty();
}
inline const std::string& IPSettings_IPv6Config::secondary_dns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:IPSettings.IPv6Config.secondary_dns)
  return _internal_secondary_dns();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPSettings_IPv6Config::set_secondary_dns(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:IPSettings.IPv6Config.secondary_dns)
}
inline std::string* IPSettings_IPv6Config::mutable_secondary_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secondary_dns();
  // @@protoc_insertion_point(field_mutable:IPSettings.IPv6Config.secondary_dns)
  return _s;
}
inline const std::string& IPSettings_IPv6Config::_internal_secondary_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secondary_dns_.Get();
}
inline void IPSettings_IPv6Config::_internal_set_secondary_dns(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.Set(value, GetArena());
}
inline std::string* IPSettings_IPv6Config::_internal_mutable_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secondary_dns_.Mutable( GetArena());
}
inline std::string* IPSettings_IPv6Config::release_secondary_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:IPSettings.IPv6Config.secondary_dns)
  return _impl_.secondary_dns_.Release();
}
inline void IPSettings_IPv6Config::set_allocated_secondary_dns(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_dns_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secondary_dns_.IsDefault()) {
          _impl_.secondary_dns_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPSettings.IPv6Config.secondary_dns)
}

// -------------------------------------------------------------------

// IPSettings

// bool is_static_ip = 1;
inline void IPSettings::clear_is_static_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_static_ip_ = false;
}
inline bool IPSettings::is_static_ip() const {
  // @@protoc_insertion_point(field_get:IPSettings.is_static_ip)
  return _internal_is_static_ip();
}
inline void IPSettings::set_is_static_ip(bool value) {
  _internal_set_is_static_ip(value);
  // @@protoc_insertion_point(field_set:IPSettings.is_static_ip)
}
inline bool IPSettings::_internal_is_static_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_static_ip_;
}
inline void IPSettings::_internal_set_is_static_ip(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_static_ip_ = value;
}

// -------------------------------------------------------------------

// PortSettings

// string max_connections = 1;
inline void PortSettings::clear_max_connections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_.ClearToEmpty();
}
inline const std::string& PortSettings::max_connections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.max_connections)
  return _internal_max_connections();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_max_connections(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.max_connections)
}
inline std::string* PortSettings::mutable_max_connections() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_max_connections();
  // @@protoc_insertion_point(field_mutable:PortSettings.max_connections)
  return _s;
}
inline const std::string& PortSettings::_internal_max_connections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_connections_.Get();
}
inline void PortSettings::_internal_set_max_connections(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_max_connections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.max_connections_.Mutable( GetArena());
}
inline std::string* PortSettings::release_max_connections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.max_connections)
  return _impl_.max_connections_.Release();
}
inline void PortSettings::set_allocated_max_connections(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_connections_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_connections_.IsDefault()) {
          _impl_.max_connections_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.max_connections)
}

// string listen_port = 2;
inline void PortSettings::clear_listen_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_.ClearToEmpty();
}
inline const std::string& PortSettings::listen_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.listen_port)
  return _internal_listen_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_listen_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.listen_port)
}
inline std::string* PortSettings::mutable_listen_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_listen_port();
  // @@protoc_insertion_point(field_mutable:PortSettings.listen_port)
  return _s;
}
inline const std::string& PortSettings::_internal_listen_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listen_port_.Get();
}
inline void PortSettings::_internal_set_listen_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_listen_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.listen_port_.Mutable( GetArena());
}
inline std::string* PortSettings::release_listen_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.listen_port)
  return _impl_.listen_port_.Release();
}
inline void PortSettings::set_allocated_listen_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.listen_port_.IsDefault()) {
          _impl_.listen_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.listen_port)
}

// string video_data_port = 3;
inline void PortSettings::clear_video_data_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_data_port_.ClearToEmpty();
}
inline const std::string& PortSettings::video_data_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.video_data_port)
  return _internal_video_data_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_video_data_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_data_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.video_data_port)
}
inline std::string* PortSettings::mutable_video_data_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_video_data_port();
  // @@protoc_insertion_point(field_mutable:PortSettings.video_data_port)
  return _s;
}
inline const std::string& PortSettings::_internal_video_data_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_data_port_.Get();
}
inline void PortSettings::_internal_set_video_data_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_data_port_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_video_data_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.video_data_port_.Mutable( GetArena());
}
inline std::string* PortSettings::release_video_data_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.video_data_port)
  return _impl_.video_data_port_.Release();
}
inline void PortSettings::set_allocated_video_data_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_data_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.video_data_port_.IsDefault()) {
          _impl_.video_data_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.video_data_port)
}

// string http_port = 4;
inline void PortSettings::clear_http_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_port_.ClearToEmpty();
}
inline const std::string& PortSettings::http_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.http_port)
  return _internal_http_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_http_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.http_port)
}
inline std::string* PortSettings::mutable_http_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_http_port();
  // @@protoc_insertion_point(field_mutable:PortSettings.http_port)
  return _s;
}
inline const std::string& PortSettings::_internal_http_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_port_.Get();
}
inline void PortSettings::_internal_set_http_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_port_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_http_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.http_port_.Mutable( GetArena());
}
inline std::string* PortSettings::release_http_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.http_port)
  return _impl_.http_port_.Release();
}
inline void PortSettings::set_allocated_http_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.http_port_.IsDefault()) {
          _impl_.http_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.http_port)
}

// string rtsp_port = 5;
inline void PortSettings::clear_rtsp_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtsp_port_.ClearToEmpty();
}
inline const std::string& PortSettings::rtsp_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.rtsp_port)
  return _internal_rtsp_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_rtsp_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtsp_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.rtsp_port)
}
inline std::string* PortSettings::mutable_rtsp_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rtsp_port();
  // @@protoc_insertion_point(field_mutable:PortSettings.rtsp_port)
  return _s;
}
inline const std::string& PortSettings::_internal_rtsp_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rtsp_port_.Get();
}
inline void PortSettings::_internal_set_rtsp_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtsp_port_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_rtsp_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rtsp_port_.Mutable( GetArena());
}
inline std::string* PortSettings::release_rtsp_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.rtsp_port)
  return _impl_.rtsp_port_.Release();
}
inline void PortSettings::set_allocated_rtsp_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtsp_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rtsp_port_.IsDefault()) {
          _impl_.rtsp_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.rtsp_port)
}

// string https_port = 6;
inline void PortSettings::clear_https_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.https_port_.ClearToEmpty();
}
inline const std::string& PortSettings::https_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PortSettings.https_port)
  return _internal_https_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortSettings::set_https_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.https_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PortSettings.https_port)
}
inline std::string* PortSettings::mutable_https_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_https_port();
  // @@protoc_insertion_point(field_mutable:PortSettings.https_port)
  return _s;
}
inline const std::string& PortSettings::_internal_https_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.https_port_.Get();
}
inline void PortSettings::_internal_set_https_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.https_port_.Set(value, GetArena());
}
inline std::string* PortSettings::_internal_mutable_https_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.https_port_.Mutable( GetArena());
}
inline std::string* PortSettings::release_https_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PortSettings.https_port)
  return _impl_.https_port_.Release();
}
inline void PortSettings::set_allocated_https_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.https_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.https_port_.IsDefault()) {
          _impl_.https_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PortSettings.https_port)
}

// -------------------------------------------------------------------

// FTPSettings

// string ftp_ip = 1;
inline void FTPSettings::clear_ftp_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ftp_ip_.ClearToEmpty();
}
inline const std::string& FTPSettings::ftp_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FTPSettings.ftp_ip)
  return _internal_ftp_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FTPSettings::set_ftp_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ftp_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FTPSettings.ftp_ip)
}
inline std::string* FTPSettings::mutable_ftp_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ftp_ip();
  // @@protoc_insertion_point(field_mutable:FTPSettings.ftp_ip)
  return _s;
}
inline const std::string& FTPSettings::_internal_ftp_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ftp_ip_.Get();
}
inline void FTPSettings::_internal_set_ftp_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ftp_ip_.Set(value, GetArena());
}
inline std::string* FTPSettings::_internal_mutable_ftp_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ftp_ip_.Mutable( GetArena());
}
inline std::string* FTPSettings::release_ftp_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FTPSettings.ftp_ip)
  return _impl_.ftp_ip_.Release();
}
inline void FTPSettings::set_allocated_ftp_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ftp_ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ftp_ip_.IsDefault()) {
          _impl_.ftp_ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FTPSettings.ftp_ip)
}

// string storage_path = 2;
inline void FTPSettings::clear_storage_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_path_.ClearToEmpty();
}
inline const std::string& FTPSettings::storage_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FTPSettings.storage_path)
  return _internal_storage_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FTPSettings::set_storage_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FTPSettings.storage_path)
}
inline std::string* FTPSettings::mutable_storage_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_storage_path();
  // @@protoc_insertion_point(field_mutable:FTPSettings.storage_path)
  return _s;
}
inline const std::string& FTPSettings::_internal_storage_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.storage_path_.Get();
}
inline void FTPSettings::_internal_set_storage_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_path_.Set(value, GetArena());
}
inline std::string* FTPSettings::_internal_mutable_storage_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.storage_path_.Mutable( GetArena());
}
inline std::string* FTPSettings::release_storage_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FTPSettings.storage_path)
  return _impl_.storage_path_.Release();
}
inline void FTPSettings::set_allocated_storage_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.storage_path_.IsDefault()) {
          _impl_.storage_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FTPSettings.storage_path)
}

// string port = 3;
inline void FTPSettings::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_.ClearToEmpty();
}
inline const std::string& FTPSettings::port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FTPSettings.port)
  return _internal_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FTPSettings::set_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FTPSettings.port)
}
inline std::string* FTPSettings::mutable_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:FTPSettings.port)
  return _s;
}
inline const std::string& FTPSettings::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_.Get();
}
inline void FTPSettings::_internal_set_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_.Set(value, GetArena());
}
inline std::string* FTPSettings::_internal_mutable_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.port_.Mutable( GetArena());
}
inline std::string* FTPSettings::release_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FTPSettings.port)
  return _impl_.port_.Release();
}
inline void FTPSettings::set_allocated_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_.IsDefault()) {
          _impl_.port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FTPSettings.port)
}

// string username = 4;
inline void FTPSettings::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& FTPSettings::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FTPSettings.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FTPSettings::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FTPSettings.username)
}
inline std::string* FTPSettings::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:FTPSettings.username)
  return _s;
}
inline const std::string& FTPSettings::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void FTPSettings::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* FTPSettings::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* FTPSettings::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FTPSettings.username)
  return _impl_.username_.Release();
}
inline void FTPSettings::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FTPSettings.username)
}

// string password = 5;
inline void FTPSettings::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& FTPSettings::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FTPSettings.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FTPSettings::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FTPSettings.password)
}
inline std::string* FTPSettings::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:FTPSettings.password)
  return _s;
}
inline const std::string& FTPSettings::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void FTPSettings::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* FTPSettings::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* FTPSettings::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FTPSettings.password)
  return _impl_.password_.Release();
}
inline void FTPSettings::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FTPSettings.password)
}

// -------------------------------------------------------------------

// PlatformSettings

// string platform_ip = 1;
inline void PlatformSettings::clear_platform_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_ip_.ClearToEmpty();
}
inline const std::string& PlatformSettings::platform_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlatformSettings.platform_ip)
  return _internal_platform_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformSettings::set_platform_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PlatformSettings.platform_ip)
}
inline std::string* PlatformSettings::mutable_platform_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform_ip();
  // @@protoc_insertion_point(field_mutable:PlatformSettings.platform_ip)
  return _s;
}
inline const std::string& PlatformSettings::_internal_platform_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.platform_ip_.Get();
}
inline void PlatformSettings::_internal_set_platform_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_ip_.Set(value, GetArena());
}
inline std::string* PlatformSettings::_internal_mutable_platform_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.platform_ip_.Mutable( GetArena());
}
inline std::string* PlatformSettings::release_platform_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlatformSettings.platform_ip)
  return _impl_.platform_ip_.Release();
}
inline void PlatformSettings::set_allocated_platform_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_ip_.IsDefault()) {
          _impl_.platform_ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlatformSettings.platform_ip)
}

// string platform_port = 2;
inline void PlatformSettings::clear_platform_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_port_.ClearToEmpty();
}
inline const std::string& PlatformSettings::platform_port() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlatformSettings.platform_port)
  return _internal_platform_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformSettings::set_platform_port(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_port_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PlatformSettings.platform_port)
}
inline std::string* PlatformSettings::mutable_platform_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform_port();
  // @@protoc_insertion_point(field_mutable:PlatformSettings.platform_port)
  return _s;
}
inline const std::string& PlatformSettings::_internal_platform_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.platform_port_.Get();
}
inline void PlatformSettings::_internal_set_platform_port(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_port_.Set(value, GetArena());
}
inline std::string* PlatformSettings::_internal_mutable_platform_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.platform_port_.Mutable( GetArena());
}
inline std::string* PlatformSettings::release_platform_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlatformSettings.platform_port)
  return _impl_.platform_port_.Release();
}
inline void PlatformSettings::set_allocated_platform_port(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_port_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_port_.IsDefault()) {
          _impl_.platform_port_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlatformSettings.platform_port)
}

// .PlatformSettings.ProtocolType protocol = 3;
inline void PlatformSettings::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = 0;
}
inline ::PlatformSettings_ProtocolType PlatformSettings::protocol() const {
  // @@protoc_insertion_point(field_get:PlatformSettings.protocol)
  return _internal_protocol();
}
inline void PlatformSettings::set_protocol(::PlatformSettings_ProtocolType value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:PlatformSettings.protocol)
}
inline ::PlatformSettings_ProtocolType PlatformSettings::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::PlatformSettings_ProtocolType>(_impl_.protocol_);
}
inline void PlatformSettings::_internal_set_protocol(::PlatformSettings_ProtocolType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = value;
}

// string key = 4;
inline void PlatformSettings::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PlatformSettings::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlatformSettings.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformSettings::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PlatformSettings.key)
}
inline std::string* PlatformSettings::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:PlatformSettings.key)
  return _s;
}
inline const std::string& PlatformSettings::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void PlatformSettings::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* PlatformSettings::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* PlatformSettings::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlatformSettings.key)
  return _impl_.key_.Release();
}
inline void PlatformSettings::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlatformSettings.key)
}

// string secret = 5;
inline void PlatformSettings::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& PlatformSettings::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlatformSettings.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformSettings::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PlatformSettings.secret)
}
inline std::string* PlatformSettings::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:PlatformSettings.secret)
  return _s;
}
inline const std::string& PlatformSettings::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void PlatformSettings::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* PlatformSettings::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* PlatformSettings::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlatformSettings.secret)
  return _impl_.secret_.Release();
}
inline void PlatformSettings::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlatformSettings.secret)
}

// -------------------------------------------------------------------

// AlarmSettings

// bool enabled = 1;
inline void AlarmSettings::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool AlarmSettings::enabled() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.enabled)
  return _internal_enabled();
}
inline void AlarmSettings::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.enabled)
}
inline bool AlarmSettings::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void AlarmSettings::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// repeated .DetectionArea areas = 2;
inline int AlarmSettings::_internal_areas_size() const {
  return _internal_areas().size();
}
inline int AlarmSettings::areas_size() const {
  return _internal_areas_size();
}
inline void AlarmSettings::clear_areas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.areas_.Clear();
}
inline ::DetectionArea* AlarmSettings::mutable_areas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AlarmSettings.areas)
  return _internal_mutable_areas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DetectionArea>* AlarmSettings::mutable_areas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AlarmSettings.areas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_areas();
}
inline const ::DetectionArea& AlarmSettings::areas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AlarmSettings.areas)
  return _internal_areas().Get(index);
}
inline ::DetectionArea* AlarmSettings::add_areas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DetectionArea* _add = _internal_mutable_areas()->Add();
  // @@protoc_insertion_point(field_add:AlarmSettings.areas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DetectionArea>& AlarmSettings::areas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AlarmSettings.areas)
  return _internal_areas();
}
inline const ::google::protobuf::RepeatedPtrField<::DetectionArea>&
AlarmSettings::_internal_areas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.areas_;
}
inline ::google::protobuf::RepeatedPtrField<::DetectionArea>*
AlarmSettings::_internal_mutable_areas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.areas_;
}

// repeated string setup_time = 3;
inline int AlarmSettings::_internal_setup_time_size() const {
  return _internal_setup_time().size();
}
inline int AlarmSettings::setup_time_size() const {
  return _internal_setup_time_size();
}
inline void AlarmSettings::clear_setup_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.setup_time_.Clear();
}
inline std::string* AlarmSettings::add_setup_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_setup_time()->Add();
  // @@protoc_insertion_point(field_add_mutable:AlarmSettings.setup_time)
  return _s;
}
inline const std::string& AlarmSettings::setup_time(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AlarmSettings.setup_time)
  return _internal_setup_time().Get(index);
}
inline std::string* AlarmSettings::mutable_setup_time(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AlarmSettings.setup_time)
  return _internal_mutable_setup_time()->Mutable(index);
}
inline void AlarmSettings::set_setup_time(int index, const std::string& value) {
  _internal_mutable_setup_time()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.setup_time)
}
inline void AlarmSettings::set_setup_time(int index, std::string&& value) {
  _internal_mutable_setup_time()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:AlarmSettings.setup_time)
}
inline void AlarmSettings::set_setup_time(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_setup_time()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AlarmSettings.setup_time)
}
inline void AlarmSettings::set_setup_time(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_setup_time()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AlarmSettings.setup_time)
}
inline void AlarmSettings::set_setup_time(int index, absl::string_view value) {
  _internal_mutable_setup_time()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:AlarmSettings.setup_time)
}
inline void AlarmSettings::add_setup_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_setup_time()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:AlarmSettings.setup_time)
}
inline void AlarmSettings::add_setup_time(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_setup_time()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:AlarmSettings.setup_time)
}
inline void AlarmSettings::add_setup_time(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_setup_time()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AlarmSettings.setup_time)
}
inline void AlarmSettings::add_setup_time(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_setup_time()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AlarmSettings.setup_time)
}
inline void AlarmSettings::add_setup_time(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_setup_time()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:AlarmSettings.setup_time)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AlarmSettings::setup_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AlarmSettings.setup_time)
  return _internal_setup_time();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AlarmSettings::mutable_setup_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AlarmSettings.setup_time)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_setup_time();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AlarmSettings::_internal_setup_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.setup_time_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AlarmSettings::_internal_mutable_setup_time() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.setup_time_;
}

// bool record_video = 4;
inline void AlarmSettings::clear_record_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_video_ = false;
}
inline bool AlarmSettings::record_video() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.record_video)
  return _internal_record_video();
}
inline void AlarmSettings::set_record_video(bool value) {
  _internal_set_record_video(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.record_video)
}
inline bool AlarmSettings::_internal_record_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.record_video_;
}
inline void AlarmSettings::_internal_set_record_video(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_video_ = value;
}

// int32 record_delay = 5;
inline void AlarmSettings::clear_record_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_delay_ = 0;
}
inline ::int32_t AlarmSettings::record_delay() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.record_delay)
  return _internal_record_delay();
}
inline void AlarmSettings::set_record_delay(::int32_t value) {
  _internal_set_record_delay(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.record_delay)
}
inline ::int32_t AlarmSettings::_internal_record_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.record_delay_;
}
inline void AlarmSettings::_internal_set_record_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_delay_ = value;
}

// bool alarm_output = 6;
inline void AlarmSettings::clear_alarm_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_output_ = false;
}
inline bool AlarmSettings::alarm_output() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.alarm_output)
  return _internal_alarm_output();
}
inline void AlarmSettings::set_alarm_output(bool value) {
  _internal_set_alarm_output(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.alarm_output)
}
inline bool AlarmSettings::_internal_alarm_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alarm_output_;
}
inline void AlarmSettings::_internal_set_alarm_output(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_output_ = value;
}

// int32 output_delay = 7;
inline void AlarmSettings::clear_output_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_delay_ = 0;
}
inline ::int32_t AlarmSettings::output_delay() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.output_delay)
  return _internal_output_delay();
}
inline void AlarmSettings::set_output_delay(::int32_t value) {
  _internal_set_output_delay(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.output_delay)
}
inline ::int32_t AlarmSettings::_internal_output_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_delay_;
}
inline void AlarmSettings::_internal_set_output_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_delay_ = value;
}

// bool send_email = 8;
inline void AlarmSettings::clear_send_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_email_ = false;
}
inline bool AlarmSettings::send_email() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.send_email)
  return _internal_send_email();
}
inline void AlarmSettings::set_send_email(bool value) {
  _internal_set_send_email(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.send_email)
}
inline bool AlarmSettings::_internal_send_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.send_email_;
}
inline void AlarmSettings::_internal_set_send_email(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_email_ = value;
}

// string email_address = 9;
inline void AlarmSettings::clear_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.ClearToEmpty();
}
inline const std::string& AlarmSettings::email_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AlarmSettings.email_address)
  return _internal_email_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlarmSettings::set_email_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AlarmSettings.email_address)
}
inline std::string* AlarmSettings::mutable_email_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email_address();
  // @@protoc_insertion_point(field_mutable:AlarmSettings.email_address)
  return _s;
}
inline const std::string& AlarmSettings::_internal_email_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_address_.Get();
}
inline void AlarmSettings::_internal_set_email_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.Set(value, GetArena());
}
inline std::string* AlarmSettings::_internal_mutable_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_address_.Mutable( GetArena());
}
inline std::string* AlarmSettings::release_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AlarmSettings.email_address)
  return _impl_.email_address_.Release();
}
inline void AlarmSettings::set_allocated_email_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_address_.IsDefault()) {
          _impl_.email_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AlarmSettings.email_address)
}

// bool snapshot = 10;
inline void AlarmSettings::clear_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_ = false;
}
inline bool AlarmSettings::snapshot() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.snapshot)
  return _internal_snapshot();
}
inline void AlarmSettings::set_snapshot(bool value) {
  _internal_set_snapshot(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.snapshot)
}
inline bool AlarmSettings::_internal_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_;
}
inline void AlarmSettings::_internal_set_snapshot(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_ = value;
}

// int32 snapshot_interval = 11;
inline void AlarmSettings::clear_snapshot_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_interval_ = 0;
}
inline ::int32_t AlarmSettings::snapshot_interval() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.snapshot_interval)
  return _internal_snapshot_interval();
}
inline void AlarmSettings::set_snapshot_interval(::int32_t value) {
  _internal_set_snapshot_interval(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.snapshot_interval)
}
inline ::int32_t AlarmSettings::_internal_snapshot_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_interval_;
}
inline void AlarmSettings::_internal_set_snapshot_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_interval_ = value;
}

// repeated .DetectionArea detection_areas = 12;
inline int AlarmSettings::_internal_detection_areas_size() const {
  return _internal_detection_areas().size();
}
inline int AlarmSettings::detection_areas_size() const {
  return _internal_detection_areas_size();
}
inline void AlarmSettings::clear_detection_areas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_areas_.Clear();
}
inline ::DetectionArea* AlarmSettings::mutable_detection_areas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AlarmSettings.detection_areas)
  return _internal_mutable_detection_areas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DetectionArea>* AlarmSettings::mutable_detection_areas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AlarmSettings.detection_areas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detection_areas();
}
inline const ::DetectionArea& AlarmSettings::detection_areas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AlarmSettings.detection_areas)
  return _internal_detection_areas().Get(index);
}
inline ::DetectionArea* AlarmSettings::add_detection_areas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DetectionArea* _add = _internal_mutable_detection_areas()->Add();
  // @@protoc_insertion_point(field_add:AlarmSettings.detection_areas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DetectionArea>& AlarmSettings::detection_areas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AlarmSettings.detection_areas)
  return _internal_detection_areas();
}
inline const ::google::protobuf::RepeatedPtrField<::DetectionArea>&
AlarmSettings::_internal_detection_areas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_areas_;
}
inline ::google::protobuf::RepeatedPtrField<::DetectionArea>*
AlarmSettings::_internal_mutable_detection_areas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detection_areas_;
}

// .AlarmSettings.AlarmType alarm_type = 13;
inline void AlarmSettings::clear_alarm_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_type_ = 0;
}
inline ::AlarmSettings_AlarmType AlarmSettings::alarm_type() const {
  // @@protoc_insertion_point(field_get:AlarmSettings.alarm_type)
  return _internal_alarm_type();
}
inline void AlarmSettings::set_alarm_type(::AlarmSettings_AlarmType value) {
  _internal_set_alarm_type(value);
  // @@protoc_insertion_point(field_set:AlarmSettings.alarm_type)
}
inline ::AlarmSettings_AlarmType AlarmSettings::_internal_alarm_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::AlarmSettings_AlarmType>(_impl_.alarm_type_);
}
inline void AlarmSettings::_internal_set_alarm_type(::AlarmSettings_AlarmType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_type_ = value;
}

// -------------------------------------------------------------------

// DetectionArea

// -------------------------------------------------------------------

// GasLeakageAlarmSettings

// bool alarm_enable = 1;
inline void GasLeakageAlarmSettings::clear_alarm_enable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_enable_ = false;
}
inline bool GasLeakageAlarmSettings::alarm_enable() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.alarm_enable)
  return _internal_alarm_enable();
}
inline void GasLeakageAlarmSettings::set_alarm_enable(bool value) {
  _internal_set_alarm_enable(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.alarm_enable)
}
inline bool GasLeakageAlarmSettings::_internal_alarm_enable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alarm_enable_;
}
inline void GasLeakageAlarmSettings::_internal_set_alarm_enable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_enable_ = value;
}

// float alarm_concentration = 2;
inline void GasLeakageAlarmSettings::clear_alarm_concentration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_concentration_ = 0;
}
inline float GasLeakageAlarmSettings::alarm_concentration() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.alarm_concentration)
  return _internal_alarm_concentration();
}
inline void GasLeakageAlarmSettings::set_alarm_concentration(float value) {
  _internal_set_alarm_concentration(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.alarm_concentration)
}
inline float GasLeakageAlarmSettings::_internal_alarm_concentration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alarm_concentration_;
}
inline void GasLeakageAlarmSettings::_internal_set_alarm_concentration(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_concentration_ = value;
}

// bool auto_snapshot = 3;
inline void GasLeakageAlarmSettings::clear_auto_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_snapshot_ = false;
}
inline bool GasLeakageAlarmSettings::auto_snapshot() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.auto_snapshot)
  return _internal_auto_snapshot();
}
inline void GasLeakageAlarmSettings::set_auto_snapshot(bool value) {
  _internal_set_auto_snapshot(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.auto_snapshot)
}
inline bool GasLeakageAlarmSettings::_internal_auto_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_snapshot_;
}
inline void GasLeakageAlarmSettings::_internal_set_auto_snapshot(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_snapshot_ = value;
}

// int32 snapshot_interval = 4;
inline void GasLeakageAlarmSettings::clear_snapshot_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_interval_ = 0;
}
inline ::int32_t GasLeakageAlarmSettings::snapshot_interval() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.snapshot_interval)
  return _internal_snapshot_interval();
}
inline void GasLeakageAlarmSettings::set_snapshot_interval(::int32_t value) {
  _internal_set_snapshot_interval(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.snapshot_interval)
}
inline ::int32_t GasLeakageAlarmSettings::_internal_snapshot_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_interval_;
}
inline void GasLeakageAlarmSettings::_internal_set_snapshot_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_interval_ = value;
}

// bool auto_record_video = 5;
inline void GasLeakageAlarmSettings::clear_auto_record_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_record_video_ = false;
}
inline bool GasLeakageAlarmSettings::auto_record_video() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.auto_record_video)
  return _internal_auto_record_video();
}
inline void GasLeakageAlarmSettings::set_auto_record_video(bool value) {
  _internal_set_auto_record_video(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.auto_record_video)
}
inline bool GasLeakageAlarmSettings::_internal_auto_record_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_record_video_;
}
inline void GasLeakageAlarmSettings::_internal_set_auto_record_video(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_record_video_ = value;
}

// int32 record_delay = 6;
inline void GasLeakageAlarmSettings::clear_record_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_delay_ = 0;
}
inline ::int32_t GasLeakageAlarmSettings::record_delay() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.record_delay)
  return _internal_record_delay();
}
inline void GasLeakageAlarmSettings::set_record_delay(::int32_t value) {
  _internal_set_record_delay(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.record_delay)
}
inline ::int32_t GasLeakageAlarmSettings::_internal_record_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.record_delay_;
}
inline void GasLeakageAlarmSettings::_internal_set_record_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_delay_ = value;
}

// bool alarm_output = 7;
inline void GasLeakageAlarmSettings::clear_alarm_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_output_ = false;
}
inline bool GasLeakageAlarmSettings::alarm_output() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.alarm_output)
  return _internal_alarm_output();
}
inline void GasLeakageAlarmSettings::set_alarm_output(bool value) {
  _internal_set_alarm_output(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.alarm_output)
}
inline bool GasLeakageAlarmSettings::_internal_alarm_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alarm_output_;
}
inline void GasLeakageAlarmSettings::_internal_set_alarm_output(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_output_ = value;
}

// int32 alarm_delay = 8;
inline void GasLeakageAlarmSettings::clear_alarm_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_delay_ = 0;
}
inline ::int32_t GasLeakageAlarmSettings::alarm_delay() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.alarm_delay)
  return _internal_alarm_delay();
}
inline void GasLeakageAlarmSettings::set_alarm_delay(::int32_t value) {
  _internal_set_alarm_delay(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.alarm_delay)
}
inline ::int32_t GasLeakageAlarmSettings::_internal_alarm_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alarm_delay_;
}
inline void GasLeakageAlarmSettings::_internal_set_alarm_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alarm_delay_ = value;
}

// bool send_email = 9;
inline void GasLeakageAlarmSettings::clear_send_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_email_ = false;
}
inline bool GasLeakageAlarmSettings::send_email() const {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.send_email)
  return _internal_send_email();
}
inline void GasLeakageAlarmSettings::set_send_email(bool value) {
  _internal_set_send_email(value);
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.send_email)
}
inline bool GasLeakageAlarmSettings::_internal_send_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.send_email_;
}
inline void GasLeakageAlarmSettings::_internal_set_send_email(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_email_ = value;
}

// string email_address = 10;
inline void GasLeakageAlarmSettings::clear_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.ClearToEmpty();
}
inline const std::string& GasLeakageAlarmSettings::email_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GasLeakageAlarmSettings.email_address)
  return _internal_email_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GasLeakageAlarmSettings::set_email_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GasLeakageAlarmSettings.email_address)
}
inline std::string* GasLeakageAlarmSettings::mutable_email_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email_address();
  // @@protoc_insertion_point(field_mutable:GasLeakageAlarmSettings.email_address)
  return _s;
}
inline const std::string& GasLeakageAlarmSettings::_internal_email_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_address_.Get();
}
inline void GasLeakageAlarmSettings::_internal_set_email_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.Set(value, GetArena());
}
inline std::string* GasLeakageAlarmSettings::_internal_mutable_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_address_.Mutable( GetArena());
}
inline std::string* GasLeakageAlarmSettings::release_email_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:GasLeakageAlarmSettings.email_address)
  return _impl_.email_address_.Release();
}
inline void GasLeakageAlarmSettings::set_allocated_email_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_address_.IsDefault()) {
          _impl_.email_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GasLeakageAlarmSettings.email_address)
}

// -------------------------------------------------------------------

// UserAccountSettings

// string request_id = 1;
inline void UserAccountSettings::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& UserAccountSettings::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UserAccountSettings.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAccountSettings::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:UserAccountSettings.request_id)
}
inline std::string* UserAccountSettings::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:UserAccountSettings.request_id)
  return _s;
}
inline const std::string& UserAccountSettings::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void UserAccountSettings::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* UserAccountSettings::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* UserAccountSettings::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:UserAccountSettings.request_id)
  return _impl_.request_id_.Release();
}
inline void UserAccountSettings::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_id_.IsDefault()) {
          _impl_.request_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountSettings.request_id)
}

// string request_pwd = 2;
inline void UserAccountSettings::clear_request_pwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_pwd_.ClearToEmpty();
}
inline const std::string& UserAccountSettings::request_pwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UserAccountSettings.request_pwd)
  return _internal_request_pwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAccountSettings::set_request_pwd(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_pwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:UserAccountSettings.request_pwd)
}
inline std::string* UserAccountSettings::mutable_request_pwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_pwd();
  // @@protoc_insertion_point(field_mutable:UserAccountSettings.request_pwd)
  return _s;
}
inline const std::string& UserAccountSettings::_internal_request_pwd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_pwd_.Get();
}
inline void UserAccountSettings::_internal_set_request_pwd(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_pwd_.Set(value, GetArena());
}
inline std::string* UserAccountSettings::_internal_mutable_request_pwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_pwd_.Mutable( GetArena());
}
inline std::string* UserAccountSettings::release_request_pwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:UserAccountSettings.request_pwd)
  return _impl_.request_pwd_.Release();
}
inline void UserAccountSettings::set_allocated_request_pwd(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_pwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_pwd_.IsDefault()) {
          _impl_.request_pwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountSettings.request_pwd)
}

// .UserAccountSettings.OperationType operation_type = 3;
inline void UserAccountSettings::clear_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = 0;
}
inline ::UserAccountSettings_OperationType UserAccountSettings::operation_type() const {
  // @@protoc_insertion_point(field_get:UserAccountSettings.operation_type)
  return _internal_operation_type();
}
inline void UserAccountSettings::set_operation_type(::UserAccountSettings_OperationType value) {
  _internal_set_operation_type(value);
  // @@protoc_insertion_point(field_set:UserAccountSettings.operation_type)
}
inline ::UserAccountSettings_OperationType UserAccountSettings::_internal_operation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::UserAccountSettings_OperationType>(_impl_.operation_type_);
}
inline void UserAccountSettings::_internal_set_operation_type(::UserAccountSettings_OperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = value;
}

// string target_user_id = 4;
inline void UserAccountSettings::clear_target_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_id_.ClearToEmpty();
}
inline const std::string& UserAccountSettings::target_user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UserAccountSettings.target_user_id)
  return _internal_target_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAccountSettings::set_target_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:UserAccountSettings.target_user_id)
}
inline std::string* UserAccountSettings::mutable_target_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_user_id();
  // @@protoc_insertion_point(field_mutable:UserAccountSettings.target_user_id)
  return _s;
}
inline const std::string& UserAccountSettings::_internal_target_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_user_id_.Get();
}
inline void UserAccountSettings::_internal_set_target_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_id_.Set(value, GetArena());
}
inline std::string* UserAccountSettings::_internal_mutable_target_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_user_id_.Mutable( GetArena());
}
inline std::string* UserAccountSettings::release_target_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:UserAccountSettings.target_user_id)
  return _impl_.target_user_id_.Release();
}
inline void UserAccountSettings::set_allocated_target_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_user_id_.IsDefault()) {
          _impl_.target_user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountSettings.target_user_id)
}

// string new_password = 5;
inline void UserAccountSettings::clear_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& UserAccountSettings::new_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UserAccountSettings.new_password)
  return _internal_new_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAccountSettings::set_new_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:UserAccountSettings.new_password)
}
inline std::string* UserAccountSettings::mutable_new_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:UserAccountSettings.new_password)
  return _s;
}
inline const std::string& UserAccountSettings::_internal_new_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_password_.Get();
}
inline void UserAccountSettings::_internal_set_new_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.Set(value, GetArena());
}
inline std::string* UserAccountSettings::_internal_mutable_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_password_.Mutable( GetArena());
}
inline std::string* UserAccountSettings::release_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:UserAccountSettings.new_password)
  return _impl_.new_password_.Release();
}
inline void UserAccountSettings::set_allocated_new_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_password_.IsDefault()) {
          _impl_.new_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAccountSettings.new_password)
}

// -------------------------------------------------------------------

// LoginSecuritySettings

// int32 max_failed_attempts = 1;
inline void LoginSecuritySettings::clear_max_failed_attempts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_failed_attempts_ = 0;
}
inline ::int32_t LoginSecuritySettings::max_failed_attempts() const {
  // @@protoc_insertion_point(field_get:LoginSecuritySettings.max_failed_attempts)
  return _internal_max_failed_attempts();
}
inline void LoginSecuritySettings::set_max_failed_attempts(::int32_t value) {
  _internal_set_max_failed_attempts(value);
  // @@protoc_insertion_point(field_set:LoginSecuritySettings.max_failed_attempts)
}
inline ::int32_t LoginSecuritySettings::_internal_max_failed_attempts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_failed_attempts_;
}
inline void LoginSecuritySettings::_internal_set_max_failed_attempts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_failed_attempts_ = value;
}

// int32 lockout_duration = 2;
inline void LoginSecuritySettings::clear_lockout_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lockout_duration_ = 0;
}
inline ::int32_t LoginSecuritySettings::lockout_duration() const {
  // @@protoc_insertion_point(field_get:LoginSecuritySettings.lockout_duration)
  return _internal_lockout_duration();
}
inline void LoginSecuritySettings::set_lockout_duration(::int32_t value) {
  _internal_set_lockout_duration(value);
  // @@protoc_insertion_point(field_set:LoginSecuritySettings.lockout_duration)
}
inline ::int32_t LoginSecuritySettings::_internal_lockout_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lockout_duration_;
}
inline void LoginSecuritySettings::_internal_set_lockout_duration(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lockout_duration_ = value;
}

// -------------------------------------------------------------------

// TimeSettings

// int32 time_zone = 1;
inline void TimeSettings::clear_time_zone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_zone_ = 0;
}
inline ::int32_t TimeSettings::time_zone() const {
  // @@protoc_insertion_point(field_get:TimeSettings.time_zone)
  return _internal_time_zone();
}
inline void TimeSettings::set_time_zone(::int32_t value) {
  _internal_set_time_zone(value);
  // @@protoc_insertion_point(field_set:TimeSettings.time_zone)
}
inline ::int32_t TimeSettings::_internal_time_zone() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_zone_;
}
inline void TimeSettings::_internal_set_time_zone(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_zone_ = value;
}

// bool auto_sync_local_time = 2;
inline void TimeSettings::clear_auto_sync_local_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_sync_local_time_ = false;
}
inline bool TimeSettings::auto_sync_local_time() const {
  // @@protoc_insertion_point(field_get:TimeSettings.auto_sync_local_time)
  return _internal_auto_sync_local_time();
}
inline void TimeSettings::set_auto_sync_local_time(bool value) {
  _internal_set_auto_sync_local_time(value);
  // @@protoc_insertion_point(field_set:TimeSettings.auto_sync_local_time)
}
inline bool TimeSettings::_internal_auto_sync_local_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_sync_local_time_;
}
inline void TimeSettings::_internal_set_auto_sync_local_time(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_sync_local_time_ = value;
}

// bool enable_ntp_sync = 3;
inline void TimeSettings::clear_enable_ntp_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_ntp_sync_ = false;
}
inline bool TimeSettings::enable_ntp_sync() const {
  // @@protoc_insertion_point(field_get:TimeSettings.enable_ntp_sync)
  return _internal_enable_ntp_sync();
}
inline void TimeSettings::set_enable_ntp_sync(bool value) {
  _internal_set_enable_ntp_sync(value);
  // @@protoc_insertion_point(field_set:TimeSettings.enable_ntp_sync)
}
inline bool TimeSettings::_internal_enable_ntp_sync() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_ntp_sync_;
}
inline void TimeSettings::_internal_set_enable_ntp_sync(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_ntp_sync_ = value;
}

// string ntp_server = 4;
inline void TimeSettings::clear_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ntp_server_.ClearToEmpty();
}
inline const std::string& TimeSettings::ntp_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TimeSettings.ntp_server)
  return _internal_ntp_server();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeSettings::set_ntp_server(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ntp_server_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:TimeSettings.ntp_server)
}
inline std::string* TimeSettings::mutable_ntp_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ntp_server();
  // @@protoc_insertion_point(field_mutable:TimeSettings.ntp_server)
  return _s;
}
inline const std::string& TimeSettings::_internal_ntp_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ntp_server_.Get();
}
inline void TimeSettings::_internal_set_ntp_server(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ntp_server_.Set(value, GetArena());
}
inline std::string* TimeSettings::_internal_mutable_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ntp_server_.Mutable( GetArena());
}
inline std::string* TimeSettings::release_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:TimeSettings.ntp_server)
  return _impl_.ntp_server_.Release();
}
inline void TimeSettings::set_allocated_ntp_server(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ntp_server_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ntp_server_.IsDefault()) {
          _impl_.ntp_server_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TimeSettings.ntp_server)
}

// int32 sync_interval = 5;
inline void TimeSettings::clear_sync_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sync_interval_ = 0;
}
inline ::int32_t TimeSettings::sync_interval() const {
  // @@protoc_insertion_point(field_get:TimeSettings.sync_interval)
  return _internal_sync_interval();
}
inline void TimeSettings::set_sync_interval(::int32_t value) {
  _internal_set_sync_interval(value);
  // @@protoc_insertion_point(field_set:TimeSettings.sync_interval)
}
inline ::int32_t TimeSettings::_internal_sync_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sync_interval_;
}
inline void TimeSettings::_internal_set_sync_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sync_interval_ = value;
}

// string manual_time = 6;
inline void TimeSettings::clear_manual_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manual_time_.ClearToEmpty();
}
inline const std::string& TimeSettings::manual_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TimeSettings.manual_time)
  return _internal_manual_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeSettings::set_manual_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manual_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:TimeSettings.manual_time)
}
inline std::string* TimeSettings::mutable_manual_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_manual_time();
  // @@protoc_insertion_point(field_mutable:TimeSettings.manual_time)
  return _s;
}
inline const std::string& TimeSettings::_internal_manual_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.manual_time_.Get();
}
inline void TimeSettings::_internal_set_manual_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manual_time_.Set(value, GetArena());
}
inline std::string* TimeSettings::_internal_mutable_manual_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.manual_time_.Mutable( GetArena());
}
inline std::string* TimeSettings::release_manual_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:TimeSettings.manual_time)
  return _impl_.manual_time_.Release();
}
inline void TimeSettings::set_allocated_manual_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manual_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.manual_time_.IsDefault()) {
          _impl_.manual_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TimeSettings.manual_time)
}

// -------------------------------------------------------------------

// SystemInfo

// string device_name = 1;
inline void SystemInfo::clear_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& SystemInfo::device_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemInfo.device_name)
  return _internal_device_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_device_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SystemInfo.device_name)
}
inline std::string* SystemInfo::mutable_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:SystemInfo.device_name)
  return _s;
}
inline const std::string& SystemInfo::_internal_device_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_name_.Get();
}
inline void SystemInfo::_internal_set_device_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_name_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SystemInfo.device_name)
  return _impl_.device_name_.Release();
}
inline void SystemInfo::set_allocated_device_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_name_.IsDefault()) {
          _impl_.device_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemInfo.device_name)
}

// string main_controller_version = 3;
inline void SystemInfo::clear_main_controller_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.main_controller_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::main_controller_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemInfo.main_controller_version)
  return _internal_main_controller_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_main_controller_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.main_controller_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SystemInfo.main_controller_version)
}
inline std::string* SystemInfo::mutable_main_controller_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_main_controller_version();
  // @@protoc_insertion_point(field_mutable:SystemInfo.main_controller_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_main_controller_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.main_controller_version_.Get();
}
inline void SystemInfo::_internal_set_main_controller_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.main_controller_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_main_controller_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.main_controller_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_main_controller_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SystemInfo.main_controller_version)
  return _impl_.main_controller_version_.Release();
}
inline void SystemInfo::set_allocated_main_controller_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.main_controller_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.main_controller_version_.IsDefault()) {
          _impl_.main_controller_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemInfo.main_controller_version)
}

// string algorithm_version = 4;
inline void SystemInfo::clear_algorithm_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::algorithm_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemInfo.algorithm_version)
  return _internal_algorithm_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_algorithm_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SystemInfo.algorithm_version)
}
inline std::string* SystemInfo::mutable_algorithm_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_algorithm_version();
  // @@protoc_insertion_point(field_mutable:SystemInfo.algorithm_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_algorithm_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_version_.Get();
}
inline void SystemInfo::_internal_set_algorithm_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_algorithm_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.algorithm_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_algorithm_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SystemInfo.algorithm_version)
  return _impl_.algorithm_version_.Release();
}
inline void SystemInfo::set_allocated_algorithm_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.algorithm_version_.IsDefault()) {
          _impl_.algorithm_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemInfo.algorithm_version)
}

// string model_version = 5;
inline void SystemInfo::clear_model_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& SystemInfo::model_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemInfo.model_version)
  return _internal_model_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemInfo::set_model_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SystemInfo.model_version)
}
inline std::string* SystemInfo::mutable_model_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:SystemInfo.model_version)
  return _s;
}
inline const std::string& SystemInfo::_internal_model_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_version_.Get();
}
inline void SystemInfo::_internal_set_model_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_version_.Set(value, GetArena());
}
inline std::string* SystemInfo::_internal_mutable_model_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_version_.Mutable( GetArena());
}
inline std::string* SystemInfo::release_model_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SystemInfo.model_version)
  return _impl_.model_version_.Release();
}
inline void SystemInfo::set_allocated_model_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_version_.IsDefault()) {
          _impl_.model_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemInfo.model_version)
}

// -------------------------------------------------------------------

// Reboot_WeeklyRebootSchedule

// int32 day_of_week = 1;
inline void Reboot_WeeklyRebootSchedule::clear_day_of_week() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.day_of_week_ = 0;
}
inline ::int32_t Reboot_WeeklyRebootSchedule::day_of_week() const {
  // @@protoc_insertion_point(field_get:Reboot.WeeklyRebootSchedule.day_of_week)
  return _internal_day_of_week();
}
inline void Reboot_WeeklyRebootSchedule::set_day_of_week(::int32_t value) {
  _internal_set_day_of_week(value);
  // @@protoc_insertion_point(field_set:Reboot.WeeklyRebootSchedule.day_of_week)
}
inline ::int32_t Reboot_WeeklyRebootSchedule::_internal_day_of_week() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.day_of_week_;
}
inline void Reboot_WeeklyRebootSchedule::_internal_set_day_of_week(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.day_of_week_ = value;
}

// string time_of_day = 2;
inline void Reboot_WeeklyRebootSchedule::clear_time_of_day() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_of_day_.ClearToEmpty();
}
inline const std::string& Reboot_WeeklyRebootSchedule::time_of_day() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Reboot.WeeklyRebootSchedule.time_of_day)
  return _internal_time_of_day();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reboot_WeeklyRebootSchedule::set_time_of_day(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_of_day_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Reboot.WeeklyRebootSchedule.time_of_day)
}
inline std::string* Reboot_WeeklyRebootSchedule::mutable_time_of_day() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_of_day();
  // @@protoc_insertion_point(field_mutable:Reboot.WeeklyRebootSchedule.time_of_day)
  return _s;
}
inline const std::string& Reboot_WeeklyRebootSchedule::_internal_time_of_day() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_of_day_.Get();
}
inline void Reboot_WeeklyRebootSchedule::_internal_set_time_of_day(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_of_day_.Set(value, GetArena());
}
inline std::string* Reboot_WeeklyRebootSchedule::_internal_mutable_time_of_day() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_of_day_.Mutable( GetArena());
}
inline std::string* Reboot_WeeklyRebootSchedule::release_time_of_day() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Reboot.WeeklyRebootSchedule.time_of_day)
  return _impl_.time_of_day_.Release();
}
inline void Reboot_WeeklyRebootSchedule::set_allocated_time_of_day(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_of_day_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_of_day_.IsDefault()) {
          _impl_.time_of_day_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Reboot.WeeklyRebootSchedule.time_of_day)
}

// -------------------------------------------------------------------

// Reboot

// bool reboot_now = 1;
inline void Reboot::clear_reboot_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reboot_now_ = false;
}
inline bool Reboot::reboot_now() const {
  // @@protoc_insertion_point(field_get:Reboot.reboot_now)
  return _internal_reboot_now();
}
inline void Reboot::set_reboot_now(bool value) {
  _internal_set_reboot_now(value);
  // @@protoc_insertion_point(field_set:Reboot.reboot_now)
}
inline bool Reboot::_internal_reboot_now() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reboot_now_;
}
inline void Reboot::_internal_set_reboot_now(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reboot_now_ = value;
}

// bool enable_custom_reboot = 2;
inline void Reboot::clear_enable_custom_reboot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_custom_reboot_ = false;
}
inline bool Reboot::enable_custom_reboot() const {
  // @@protoc_insertion_point(field_get:Reboot.enable_custom_reboot)
  return _internal_enable_custom_reboot();
}
inline void Reboot::set_enable_custom_reboot(bool value) {
  _internal_set_enable_custom_reboot(value);
  // @@protoc_insertion_point(field_set:Reboot.enable_custom_reboot)
}
inline bool Reboot::_internal_enable_custom_reboot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_custom_reboot_;
}
inline void Reboot::_internal_set_enable_custom_reboot(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_custom_reboot_ = value;
}

// repeated .Reboot.WeeklyRebootSchedule schedules = 3;
inline int Reboot::_internal_schedules_size() const {
  return _internal_schedules().size();
}
inline int Reboot::schedules_size() const {
  return _internal_schedules_size();
}
inline void Reboot::clear_schedules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schedules_.Clear();
}
inline ::Reboot_WeeklyRebootSchedule* Reboot::mutable_schedules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Reboot.schedules)
  return _internal_mutable_schedules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>* Reboot::mutable_schedules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Reboot.schedules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_schedules();
}
inline const ::Reboot_WeeklyRebootSchedule& Reboot::schedules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Reboot.schedules)
  return _internal_schedules().Get(index);
}
inline ::Reboot_WeeklyRebootSchedule* Reboot::add_schedules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Reboot_WeeklyRebootSchedule* _add = _internal_mutable_schedules()->Add();
  // @@protoc_insertion_point(field_add:Reboot.schedules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>& Reboot::schedules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Reboot.schedules)
  return _internal_schedules();
}
inline const ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>&
Reboot::_internal_schedules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schedules_;
}
inline ::google::protobuf::RepeatedPtrField<::Reboot_WeeklyRebootSchedule>*
Reboot::_internal_mutable_schedules() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.schedules_;
}

// bool reset = 4;
inline void Reboot::clear_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reset_ = false;
}
inline bool Reboot::reset() const {
  // @@protoc_insertion_point(field_get:Reboot.reset)
  return _internal_reset();
}
inline void Reboot::set_reset(bool value) {
  _internal_set_reset(value);
  // @@protoc_insertion_point(field_set:Reboot.reset)
}
inline bool Reboot::_internal_reset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reset_;
}
inline void Reboot::_internal_set_reset(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reset_ = value;
}

// -------------------------------------------------------------------

// SystemLogsQuery

// .SystemLogsQuery.QueryType type = 1;
inline void SystemLogsQuery::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::SystemLogsQuery_QueryType SystemLogsQuery::type() const {
  // @@protoc_insertion_point(field_get:SystemLogsQuery.type)
  return _internal_type();
}
inline void SystemLogsQuery::set_type(::SystemLogsQuery_QueryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SystemLogsQuery.type)
}
inline ::SystemLogsQuery_QueryType SystemLogsQuery::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::SystemLogsQuery_QueryType>(_impl_.type_);
}
inline void SystemLogsQuery::_internal_set_type(::SystemLogsQuery_QueryType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string query_pattern = 2;
inline void SystemLogsQuery::clear_query_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_pattern_.ClearToEmpty();
}
inline const std::string& SystemLogsQuery::query_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemLogsQuery.query_pattern)
  return _internal_query_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SystemLogsQuery::set_query_pattern(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SystemLogsQuery.query_pattern)
}
inline std::string* SystemLogsQuery::mutable_query_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query_pattern();
  // @@protoc_insertion_point(field_mutable:SystemLogsQuery.query_pattern)
  return _s;
}
inline const std::string& SystemLogsQuery::_internal_query_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_pattern_.Get();
}
inline void SystemLogsQuery::_internal_set_query_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_pattern_.Set(value, GetArena());
}
inline std::string* SystemLogsQuery::_internal_mutable_query_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.query_pattern_.Mutable( GetArena());
}
inline std::string* SystemLogsQuery::release_query_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SystemLogsQuery.query_pattern)
  return _impl_.query_pattern_.Release();
}
inline void SystemLogsQuery::set_allocated_query_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_pattern_.IsDefault()) {
          _impl_.query_pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemLogsQuery.query_pattern)
}

// repeated .LogEntry log_entries = 3;
inline int SystemLogsQuery::_internal_log_entries_size() const {
  return _internal_log_entries().size();
}
inline int SystemLogsQuery::log_entries_size() const {
  return _internal_log_entries_size();
}
inline void SystemLogsQuery::clear_log_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_entries_.Clear();
}
inline ::LogEntry* SystemLogsQuery::mutable_log_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SystemLogsQuery.log_entries)
  return _internal_mutable_log_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::LogEntry>* SystemLogsQuery::mutable_log_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SystemLogsQuery.log_entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_log_entries();
}
inline const ::LogEntry& SystemLogsQuery::log_entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SystemLogsQuery.log_entries)
  return _internal_log_entries().Get(index);
}
inline ::LogEntry* SystemLogsQuery::add_log_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::LogEntry* _add = _internal_mutable_log_entries()->Add();
  // @@protoc_insertion_point(field_add:SystemLogsQuery.log_entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::LogEntry>& SystemLogsQuery::log_entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SystemLogsQuery.log_entries)
  return _internal_log_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::LogEntry>&
SystemLogsQuery::_internal_log_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_entries_;
}
inline ::google::protobuf::RepeatedPtrField<::LogEntry>*
SystemLogsQuery::_internal_mutable_log_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.log_entries_;
}

// uint64 time = 4;
inline void SystemLogsQuery::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t SystemLogsQuery::time() const {
  // @@protoc_insertion_point(field_get:SystemLogsQuery.time)
  return _internal_time();
}
inline void SystemLogsQuery::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:SystemLogsQuery.time)
}
inline ::uint64_t SystemLogsQuery::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void SystemLogsQuery::_internal_set_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// LogEntry

// .LogEntry.LogType log_type = 1;
inline void LogEntry::clear_log_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_type_ = 0;
}
inline ::LogEntry_LogType LogEntry::log_type() const {
  // @@protoc_insertion_point(field_get:LogEntry.log_type)
  return _internal_log_type();
}
inline void LogEntry::set_log_type(::LogEntry_LogType value) {
  _internal_set_log_type(value);
  // @@protoc_insertion_point(field_set:LogEntry.log_type)
}
inline ::LogEntry_LogType LogEntry::_internal_log_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LogEntry_LogType>(_impl_.log_type_);
}
inline void LogEntry::_internal_set_log_type(::LogEntry_LogType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_type_ = value;
}

// .LogEntry.AccountType account_type = 2;
inline void LogEntry::clear_account_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_type_ = 0;
}
inline ::LogEntry_AccountType LogEntry::account_type() const {
  // @@protoc_insertion_point(field_get:LogEntry.account_type)
  return _internal_account_type();
}
inline void LogEntry::set_account_type(::LogEntry_AccountType value) {
  _internal_set_account_type(value);
  // @@protoc_insertion_point(field_set:LogEntry.account_type)
}
inline ::LogEntry_AccountType LogEntry::_internal_account_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LogEntry_AccountType>(_impl_.account_type_);
}
inline void LogEntry::_internal_set_account_type(::LogEntry_AccountType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_type_ = value;
}

// string operation_datetime = 3;
inline void LogEntry::clear_operation_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_datetime_.ClearToEmpty();
}
inline const std::string& LogEntry::operation_datetime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LogEntry.operation_datetime)
  return _internal_operation_datetime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogEntry::set_operation_datetime(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_datetime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LogEntry.operation_datetime)
}
inline std::string* LogEntry::mutable_operation_datetime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_datetime();
  // @@protoc_insertion_point(field_mutable:LogEntry.operation_datetime)
  return _s;
}
inline const std::string& LogEntry::_internal_operation_datetime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_datetime_.Get();
}
inline void LogEntry::_internal_set_operation_datetime(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_datetime_.Set(value, GetArena());
}
inline std::string* LogEntry::_internal_mutable_operation_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_datetime_.Mutable( GetArena());
}
inline std::string* LogEntry::release_operation_datetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LogEntry.operation_datetime)
  return _impl_.operation_datetime_.Release();
}
inline void LogEntry::set_allocated_operation_datetime(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_datetime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_datetime_.IsDefault()) {
          _impl_.operation_datetime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogEntry.operation_datetime)
}

// string request_ip = 4;
inline void LogEntry::clear_request_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_ip_.ClearToEmpty();
}
inline const std::string& LogEntry::request_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LogEntry.request_ip)
  return _internal_request_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogEntry::set_request_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LogEntry.request_ip)
}
inline std::string* LogEntry::mutable_request_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_ip();
  // @@protoc_insertion_point(field_mutable:LogEntry.request_ip)
  return _s;
}
inline const std::string& LogEntry::_internal_request_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_ip_.Get();
}
inline void LogEntry::_internal_set_request_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_ip_.Set(value, GetArena());
}
inline std::string* LogEntry::_internal_mutable_request_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_ip_.Mutable( GetArena());
}
inline std::string* LogEntry::release_request_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LogEntry.request_ip)
  return _impl_.request_ip_.Release();
}
inline void LogEntry::set_allocated_request_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_ip_.IsDefault()) {
          _impl_.request_ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogEntry.request_ip)
}

// .LogEntry.OperationType operation_type = 5;
inline void LogEntry::clear_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = 0;
}
inline ::LogEntry_OperationType LogEntry::operation_type() const {
  // @@protoc_insertion_point(field_get:LogEntry.operation_type)
  return _internal_operation_type();
}
inline void LogEntry::set_operation_type(::LogEntry_OperationType value) {
  _internal_set_operation_type(value);
  // @@protoc_insertion_point(field_set:LogEntry.operation_type)
}
inline ::LogEntry_OperationType LogEntry::_internal_operation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LogEntry_OperationType>(_impl_.operation_type_);
}
inline void LogEntry::_internal_set_operation_type(::LogEntry_OperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = value;
}

// .LogEntry.OperationResult operation_result = 6;
inline void LogEntry::clear_operation_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_ = 0;
}
inline ::LogEntry_OperationResult LogEntry::operation_result() const {
  // @@protoc_insertion_point(field_get:LogEntry.operation_result)
  return _internal_operation_result();
}
inline void LogEntry::set_operation_result(::LogEntry_OperationResult value) {
  _internal_set_operation_result(value);
  // @@protoc_insertion_point(field_set:LogEntry.operation_result)
}
inline ::LogEntry_OperationResult LogEntry::_internal_operation_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LogEntry_OperationResult>(_impl_.operation_result_);
}
inline void LogEntry::_internal_set_operation_result(::LogEntry_OperationResult value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_ = value;
}

// -------------------------------------------------------------------

// PresetPositionOp

// string target = 1;
inline void PresetPositionOp::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& PresetPositionOp::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PresetPositionOp.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresetPositionOp::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PresetPositionOp.target)
}
inline std::string* PresetPositionOp::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:PresetPositionOp.target)
  return _s;
}
inline const std::string& PresetPositionOp::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void PresetPositionOp::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* PresetPositionOp::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* PresetPositionOp::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PresetPositionOp.target)
  return _impl_.target_.Release();
}
inline void PresetPositionOp::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PresetPositionOp.target)
}

// -------------------------------------------------------------------

// PresetList

// repeated .PresetPosition preset_positions = 1;
inline int PresetList::_internal_preset_positions_size() const {
  return _internal_preset_positions().size();
}
inline int PresetList::preset_positions_size() const {
  return _internal_preset_positions_size();
}
inline void PresetList::clear_preset_positions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_positions_.Clear();
}
inline ::PresetPosition* PresetList::mutable_preset_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PresetList.preset_positions)
  return _internal_mutable_preset_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::PresetPosition>* PresetList::mutable_preset_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PresetList.preset_positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_preset_positions();
}
inline const ::PresetPosition& PresetList::preset_positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PresetList.preset_positions)
  return _internal_preset_positions().Get(index);
}
inline ::PresetPosition* PresetList::add_preset_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::PresetPosition* _add = _internal_mutable_preset_positions()->Add();
  // @@protoc_insertion_point(field_add:PresetList.preset_positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::PresetPosition>& PresetList::preset_positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PresetList.preset_positions)
  return _internal_preset_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::PresetPosition>&
PresetList::_internal_preset_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preset_positions_;
}
inline ::google::protobuf::RepeatedPtrField<::PresetPosition>*
PresetList::_internal_mutable_preset_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.preset_positions_;
}

// -------------------------------------------------------------------

// CruiseGroup

// string name = 1;
inline void CruiseGroup::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CruiseGroup::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CruiseGroup.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CruiseGroup::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CruiseGroup.name)
}
inline std::string* CruiseGroup::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CruiseGroup.name)
  return _s;
}
inline const std::string& CruiseGroup::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CruiseGroup::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CruiseGroup::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CruiseGroup::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:CruiseGroup.name)
  return _impl_.name_.Release();
}
inline void CruiseGroup::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CruiseGroup.name)
}

// repeated .PresetPosition preset_positions = 2;
inline int CruiseGroup::_internal_preset_positions_size() const {
  return _internal_preset_positions().size();
}
inline int CruiseGroup::preset_positions_size() const {
  return _internal_preset_positions_size();
}
inline void CruiseGroup::clear_preset_positions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_positions_.Clear();
}
inline ::PresetPosition* CruiseGroup::mutable_preset_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CruiseGroup.preset_positions)
  return _internal_mutable_preset_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::PresetPosition>* CruiseGroup::mutable_preset_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CruiseGroup.preset_positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_preset_positions();
}
inline const ::PresetPosition& CruiseGroup::preset_positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CruiseGroup.preset_positions)
  return _internal_preset_positions().Get(index);
}
inline ::PresetPosition* CruiseGroup::add_preset_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::PresetPosition* _add = _internal_mutable_preset_positions()->Add();
  // @@protoc_insertion_point(field_add:CruiseGroup.preset_positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::PresetPosition>& CruiseGroup::preset_positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CruiseGroup.preset_positions)
  return _internal_preset_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::PresetPosition>&
CruiseGroup::_internal_preset_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preset_positions_;
}
inline ::google::protobuf::RepeatedPtrField<::PresetPosition>*
CruiseGroup::_internal_mutable_preset_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.preset_positions_;
}

// -------------------------------------------------------------------

// PresetPosition

// string name = 1;
inline void PresetPosition::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PresetPosition::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PresetPosition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresetPosition::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PresetPosition.name)
}
inline std::string* PresetPosition::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PresetPosition.name)
  return _s;
}
inline const std::string& PresetPosition::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PresetPosition::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PresetPosition::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PresetPosition::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PresetPosition.name)
  return _impl_.name_.Release();
}
inline void PresetPosition::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PresetPosition.name)
}

// int32 number = 2;
inline void PresetPosition::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = 0;
}
inline ::int32_t PresetPosition::number() const {
  // @@protoc_insertion_point(field_get:PresetPosition.number)
  return _internal_number();
}
inline void PresetPosition::set_number(::int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:PresetPosition.number)
}
inline ::int32_t PresetPosition::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void PresetPosition::_internal_set_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// int32 dwell_time_seconds = 3;
inline void PresetPosition::clear_dwell_time_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dwell_time_seconds_ = 0;
}
inline ::int32_t PresetPosition::dwell_time_seconds() const {
  // @@protoc_insertion_point(field_get:PresetPosition.dwell_time_seconds)
  return _internal_dwell_time_seconds();
}
inline void PresetPosition::set_dwell_time_seconds(::int32_t value) {
  _internal_set_dwell_time_seconds(value);
  // @@protoc_insertion_point(field_set:PresetPosition.dwell_time_seconds)
}
inline ::int32_t PresetPosition::_internal_dwell_time_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dwell_time_seconds_;
}
inline void PresetPosition::_internal_set_dwell_time_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dwell_time_seconds_ = value;
}

// -------------------------------------------------------------------

// TrackingScan

// repeated .TrackingScanCmd cmd = 1;
inline int TrackingScan::_internal_cmd_size() const {
  return _internal_cmd().size();
}
inline int TrackingScan::cmd_size() const {
  return _internal_cmd_size();
}
inline void TrackingScan::clear_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.Clear();
}
inline ::TrackingScanCmd* TrackingScan::mutable_cmd(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:TrackingScan.cmd)
  return _internal_mutable_cmd()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>* TrackingScan::mutable_cmd()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:TrackingScan.cmd)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cmd();
}
inline const ::TrackingScanCmd& TrackingScan::cmd(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TrackingScan.cmd)
  return _internal_cmd().Get(index);
}
inline ::TrackingScanCmd* TrackingScan::add_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::TrackingScanCmd* _add = _internal_mutable_cmd()->Add();
  // @@protoc_insertion_point(field_add:TrackingScan.cmd)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>& TrackingScan::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:TrackingScan.cmd)
  return _internal_cmd();
}
inline const ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>&
TrackingScan::_internal_cmd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_;
}
inline ::google::protobuf::RepeatedPtrField<::TrackingScanCmd>*
TrackingScan::_internal_mutable_cmd() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cmd_;
}

// -------------------------------------------------------------------

// TrackingScanCmd

// .TrackingScanCmd.OperationType type = 1;
inline void TrackingScanCmd::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::TrackingScanCmd_OperationType TrackingScanCmd::type() const {
  // @@protoc_insertion_point(field_get:TrackingScanCmd.type)
  return _internal_type();
}
inline void TrackingScanCmd::set_type(::TrackingScanCmd_OperationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TrackingScanCmd.type)
}
inline ::TrackingScanCmd_OperationType TrackingScanCmd::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::TrackingScanCmd_OperationType>(_impl_.type_);
}
inline void TrackingScanCmd::_internal_set_type(::TrackingScanCmd_OperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// float pan_angle = 2;
inline void TrackingScanCmd::clear_pan_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pan_angle_ = 0;
}
inline float TrackingScanCmd::pan_angle() const {
  // @@protoc_insertion_point(field_get:TrackingScanCmd.pan_angle)
  return _internal_pan_angle();
}
inline void TrackingScanCmd::set_pan_angle(float value) {
  _internal_set_pan_angle(value);
  // @@protoc_insertion_point(field_set:TrackingScanCmd.pan_angle)
}
inline float TrackingScanCmd::_internal_pan_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pan_angle_;
}
inline void TrackingScanCmd::_internal_set_pan_angle(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pan_angle_ = value;
}

// float tilt_angle = 3;
inline void TrackingScanCmd::clear_tilt_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tilt_angle_ = 0;
}
inline float TrackingScanCmd::tilt_angle() const {
  // @@protoc_insertion_point(field_get:TrackingScanCmd.tilt_angle)
  return _internal_tilt_angle();
}
inline void TrackingScanCmd::set_tilt_angle(float value) {
  _internal_set_tilt_angle(value);
  // @@protoc_insertion_point(field_set:TrackingScanCmd.tilt_angle)
}
inline float TrackingScanCmd::_internal_tilt_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tilt_angle_;
}
inline void TrackingScanCmd::_internal_set_tilt_angle(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tilt_angle_ = value;
}

// float zoom_factor = 4;
inline void TrackingScanCmd::clear_zoom_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_factor_ = 0;
}
inline float TrackingScanCmd::zoom_factor() const {
  // @@protoc_insertion_point(field_get:TrackingScanCmd.zoom_factor)
  return _internal_zoom_factor();
}
inline void TrackingScanCmd::set_zoom_factor(float value) {
  _internal_set_zoom_factor(value);
  // @@protoc_insertion_point(field_set:TrackingScanCmd.zoom_factor)
}
inline float TrackingScanCmd::_internal_zoom_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zoom_factor_;
}
inline void TrackingScanCmd::_internal_set_zoom_factor(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_factor_ = value;
}

// int32 preset_number = 5;
inline void TrackingScanCmd::clear_preset_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_number_ = 0;
}
inline ::int32_t TrackingScanCmd::preset_number() const {
  // @@protoc_insertion_point(field_get:TrackingScanCmd.preset_number)
  return _internal_preset_number();
}
inline void TrackingScanCmd::set_preset_number(::int32_t value) {
  _internal_set_preset_number(value);
  // @@protoc_insertion_point(field_set:TrackingScanCmd.preset_number)
}
inline ::int32_t TrackingScanCmd::_internal_preset_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preset_number_;
}
inline void TrackingScanCmd::_internal_set_preset_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_number_ = value;
}

// -------------------------------------------------------------------

// LinearScanSettings

// int32 scan_id = 1;
inline void LinearScanSettings::clear_scan_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_id_ = 0;
}
inline ::int32_t LinearScanSettings::scan_id() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.scan_id)
  return _internal_scan_id();
}
inline void LinearScanSettings::set_scan_id(::int32_t value) {
  _internal_set_scan_id(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.scan_id)
}
inline ::int32_t LinearScanSettings::_internal_scan_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scan_id_;
}
inline void LinearScanSettings::_internal_set_scan_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_id_ = value;
}

// int32 scan_speed = 2;
inline void LinearScanSettings::clear_scan_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_speed_ = 0;
}
inline ::int32_t LinearScanSettings::scan_speed() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.scan_speed)
  return _internal_scan_speed();
}
inline void LinearScanSettings::set_scan_speed(::int32_t value) {
  _internal_set_scan_speed(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.scan_speed)
}
inline ::int32_t LinearScanSettings::_internal_scan_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scan_speed_;
}
inline void LinearScanSettings::_internal_set_scan_speed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_speed_ = value;
}

// int32 left_pause_time = 3;
inline void LinearScanSettings::clear_left_pause_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_pause_time_ = 0;
}
inline ::int32_t LinearScanSettings::left_pause_time() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.left_pause_time)
  return _internal_left_pause_time();
}
inline void LinearScanSettings::set_left_pause_time(::int32_t value) {
  _internal_set_left_pause_time(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.left_pause_time)
}
inline ::int32_t LinearScanSettings::_internal_left_pause_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.left_pause_time_;
}
inline void LinearScanSettings::_internal_set_left_pause_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_pause_time_ = value;
}

// int32 right_pause_time = 4;
inline void LinearScanSettings::clear_right_pause_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_pause_time_ = 0;
}
inline ::int32_t LinearScanSettings::right_pause_time() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.right_pause_time)
  return _internal_right_pause_time();
}
inline void LinearScanSettings::set_right_pause_time(::int32_t value) {
  _internal_set_right_pause_time(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.right_pause_time)
}
inline ::int32_t LinearScanSettings::_internal_right_pause_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.right_pause_time_;
}
inline void LinearScanSettings::_internal_set_right_pause_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_pause_time_ = value;
}

// int32 left_boundary = 5;
inline void LinearScanSettings::clear_left_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_boundary_ = 0;
}
inline ::int32_t LinearScanSettings::left_boundary() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.left_boundary)
  return _internal_left_boundary();
}
inline void LinearScanSettings::set_left_boundary(::int32_t value) {
  _internal_set_left_boundary(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.left_boundary)
}
inline ::int32_t LinearScanSettings::_internal_left_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.left_boundary_;
}
inline void LinearScanSettings::_internal_set_left_boundary(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_boundary_ = value;
}

// int32 right_boundary = 6;
inline void LinearScanSettings::clear_right_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_boundary_ = 0;
}
inline ::int32_t LinearScanSettings::right_boundary() const {
  // @@protoc_insertion_point(field_get:LinearScanSettings.right_boundary)
  return _internal_right_boundary();
}
inline void LinearScanSettings::set_right_boundary(::int32_t value) {
  _internal_set_right_boundary(value);
  // @@protoc_insertion_point(field_set:LinearScanSettings.right_boundary)
}
inline ::int32_t LinearScanSettings::_internal_right_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.right_boundary_;
}
inline void LinearScanSettings::_internal_set_right_boundary(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_boundary_ = value;
}

// -------------------------------------------------------------------

// LinearScanControl

// int32 scan_id = 1;
inline void LinearScanControl::clear_scan_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_id_ = 0;
}
inline ::int32_t LinearScanControl::scan_id() const {
  // @@protoc_insertion_point(field_get:LinearScanControl.scan_id)
  return _internal_scan_id();
}
inline void LinearScanControl::set_scan_id(::int32_t value) {
  _internal_set_scan_id(value);
  // @@protoc_insertion_point(field_set:LinearScanControl.scan_id)
}
inline ::int32_t LinearScanControl::_internal_scan_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scan_id_;
}
inline void LinearScanControl::_internal_set_scan_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_id_ = value;
}

// bool start = 2;
inline void LinearScanControl::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = false;
}
inline bool LinearScanControl::start() const {
  // @@protoc_insertion_point(field_get:LinearScanControl.start)
  return _internal_start();
}
inline void LinearScanControl::set_start(bool value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:LinearScanControl.start)
}
inline bool LinearScanControl::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void LinearScanControl::_internal_set_start(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// -------------------------------------------------------------------

// Rotation

// .Direction direction = 1;
inline void Rotation::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = 0;
}
inline ::Direction Rotation::direction() const {
  // @@protoc_insertion_point(field_get:Rotation.direction)
  return _internal_direction();
}
inline void Rotation::set_direction(::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Rotation.direction)
}
inline ::Direction Rotation::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Direction>(_impl_.direction_);
}
inline void Rotation::_internal_set_direction(::Direction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = value;
}

// float speed = 2;
inline void Rotation::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
}
inline float Rotation::speed() const {
  // @@protoc_insertion_point(field_get:Rotation.speed)
  return _internal_speed();
}
inline void Rotation::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Rotation.speed)
}
inline float Rotation::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void Rotation::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// LensControl

// float zoom_level = 1;
inline void LensControl::clear_zoom_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_level_ = 0;
}
inline float LensControl::zoom_level() const {
  // @@protoc_insertion_point(field_get:LensControl.zoom_level)
  return _internal_zoom_level();
}
inline void LensControl::set_zoom_level(float value) {
  _internal_set_zoom_level(value);
  // @@protoc_insertion_point(field_set:LensControl.zoom_level)
}
inline float LensControl::_internal_zoom_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zoom_level_;
}
inline void LensControl::_internal_set_zoom_level(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zoom_level_ = value;
}

// float focus = 2;
inline void LensControl::clear_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.focus_ = 0;
}
inline float LensControl::focus() const {
  // @@protoc_insertion_point(field_get:LensControl.focus)
  return _internal_focus();
}
inline void LensControl::set_focus(float value) {
  _internal_set_focus(value);
  // @@protoc_insertion_point(field_set:LensControl.focus)
}
inline float LensControl::_internal_focus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.focus_;
}
inline void LensControl::_internal_set_focus(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.focus_ = value;
}

// float aperture = 3;
inline void LensControl::clear_aperture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aperture_ = 0;
}
inline float LensControl::aperture() const {
  // @@protoc_insertion_point(field_get:LensControl.aperture)
  return _internal_aperture();
}
inline void LensControl::set_aperture(float value) {
  _internal_set_aperture(value);
  // @@protoc_insertion_point(field_set:LensControl.aperture)
}
inline float LensControl::_internal_aperture() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aperture_;
}
inline void LensControl::_internal_set_aperture(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aperture_ = value;
}

// -------------------------------------------------------------------

// AccessoryControl

// bool light = 1;
inline void AccessoryControl::clear_light() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.light_ = false;
}
inline bool AccessoryControl::light() const {
  // @@protoc_insertion_point(field_get:AccessoryControl.light)
  return _internal_light();
}
inline void AccessoryControl::set_light(bool value) {
  _internal_set_light(value);
  // @@protoc_insertion_point(field_set:AccessoryControl.light)
}
inline bool AccessoryControl::_internal_light() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.light_;
}
inline void AccessoryControl::_internal_set_light(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.light_ = value;
}

// bool wiper = 2;
inline void AccessoryControl::clear_wiper() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wiper_ = false;
}
inline bool AccessoryControl::wiper() const {
  // @@protoc_insertion_point(field_get:AccessoryControl.wiper)
  return _internal_wiper();
}
inline void AccessoryControl::set_wiper(bool value) {
  _internal_set_wiper(value);
  // @@protoc_insertion_point(field_set:AccessoryControl.wiper)
}
inline bool AccessoryControl::_internal_wiper() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wiper_;
}
inline void AccessoryControl::_internal_set_wiper(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wiper_ = value;
}

// -------------------------------------------------------------------

// Scanning

// .Scanning.ScanType scan_type = 1;
inline void Scanning::clear_scan_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_type_ = 0;
}
inline ::Scanning_ScanType Scanning::scan_type() const {
  // @@protoc_insertion_point(field_get:Scanning.scan_type)
  return _internal_scan_type();
}
inline void Scanning::set_scan_type(::Scanning_ScanType value) {
  _internal_set_scan_type(value);
  // @@protoc_insertion_point(field_set:Scanning.scan_type)
}
inline ::Scanning_ScanType Scanning::_internal_scan_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Scanning_ScanType>(_impl_.scan_type_);
}
inline void Scanning::_internal_set_scan_type(::Scanning_ScanType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_type_ = value;
}

// -------------------------------------------------------------------

// ImageModeMessage

// .ImageModeMessage.ImageMode mode = 1;
inline void ImageModeMessage::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::ImageModeMessage_ImageMode ImageModeMessage::mode() const {
  // @@protoc_insertion_point(field_get:ImageModeMessage.mode)
  return _internal_mode();
}
inline void ImageModeMessage::set_mode(::ImageModeMessage_ImageMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:ImageModeMessage.mode)
}
inline ::ImageModeMessage_ImageMode ImageModeMessage::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ImageModeMessage_ImageMode>(_impl_.mode_);
}
inline void ImageModeMessage::_internal_set_mode(::ImageModeMessage_ImageMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::PTZDevice_DeviceStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::PTZDevice_DeviceStatus>() {
  return ::PTZDevice_DeviceStatus_descriptor();
}
template <>
struct is_proto_enum<::ImageSettings_CaptureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ImageSettings_CaptureType>() {
  return ::ImageSettings_CaptureType_descriptor();
}
template <>
struct is_proto_enum<::ImageSettings_ImageQuality> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ImageSettings_ImageQuality>() {
  return ::ImageSettings_ImageQuality_descriptor();
}
template <>
struct is_proto_enum<::VideoAdjustment_MirrorSetting> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::VideoAdjustment_MirrorSetting>() {
  return ::VideoAdjustment_MirrorSetting_descriptor();
}
template <>
struct is_proto_enum<::VideoAdjustment_StabilizationSetting> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::VideoAdjustment_StabilizationSetting>() {
  return ::VideoAdjustment_StabilizationSetting_descriptor();
}
template <>
struct is_proto_enum<::ExposureSettings_ExposureMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ExposureSettings_ExposureMode>() {
  return ::ExposureSettings_ExposureMode_descriptor();
}
template <>
struct is_proto_enum<::DayNightSwitchSettings_Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DayNightSwitchSettings_Mode>() {
  return ::DayNightSwitchSettings_Mode_descriptor();
}
template <>
struct is_proto_enum<::WhiteBalanceSettings_WhiteBalanceMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::WhiteBalanceSettings_WhiteBalanceMode>() {
  return ::WhiteBalanceSettings_WhiteBalanceMode_descriptor();
}
template <>
struct is_proto_enum<::OSDSettings_Size> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::OSDSettings_Size>() {
  return ::OSDSettings_Size_descriptor();
}
template <>
struct is_proto_enum<::OSDSettings_Color> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::OSDSettings_Color>() {
  return ::OSDSettings_Color_descriptor();
}
template <>
struct is_proto_enum<::OSDSettings_Alignment> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::OSDSettings_Alignment>() {
  return ::OSDSettings_Alignment_descriptor();
}
template <>
struct is_proto_enum<::OSDSettings_TimeFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::OSDSettings_TimeFormat>() {
  return ::OSDSettings_TimeFormat_descriptor();
}
template <>
struct is_proto_enum<::OSDSettings_DateFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::OSDSettings_DateFormat>() {
  return ::OSDSettings_DateFormat_descriptor();
}
template <>
struct is_proto_enum<::PlatformSettings_ProtocolType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::PlatformSettings_ProtocolType>() {
  return ::PlatformSettings_ProtocolType_descriptor();
}
template <>
struct is_proto_enum<::AlarmSettings_AlarmType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::AlarmSettings_AlarmType>() {
  return ::AlarmSettings_AlarmType_descriptor();
}
template <>
struct is_proto_enum<::UserAccountSettings_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UserAccountSettings_OperationType>() {
  return ::UserAccountSettings_OperationType_descriptor();
}
template <>
struct is_proto_enum<::SystemLogsQuery_QueryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SystemLogsQuery_QueryType>() {
  return ::SystemLogsQuery_QueryType_descriptor();
}
template <>
struct is_proto_enum<::LogEntry_LogType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::LogEntry_LogType>() {
  return ::LogEntry_LogType_descriptor();
}
template <>
struct is_proto_enum<::LogEntry_AccountType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::LogEntry_AccountType>() {
  return ::LogEntry_AccountType_descriptor();
}
template <>
struct is_proto_enum<::LogEntry_OperationResult> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::LogEntry_OperationResult>() {
  return ::LogEntry_OperationResult_descriptor();
}
template <>
struct is_proto_enum<::LogEntry_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::LogEntry_OperationType>() {
  return ::LogEntry_OperationType_descriptor();
}
template <>
struct is_proto_enum<::PresetPositionOp_PresetOperatType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::PresetPositionOp_PresetOperatType>() {
  return ::PresetPositionOp_PresetOperatType_descriptor();
}
template <>
struct is_proto_enum<::TrackingScanCmd_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TrackingScanCmd_OperationType>() {
  return ::TrackingScanCmd_OperationType_descriptor();
}
template <>
struct is_proto_enum<::Scanning_ScanType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Scanning_ScanType>() {
  return ::Scanning_ScanType_descriptor();
}
template <>
struct is_proto_enum<::ImageModeMessage_ImageMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ImageModeMessage_ImageMode>() {
  return ::ImageModeMessage_ImageMode_descriptor();
}
template <>
struct is_proto_enum<::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MessageType>() {
  return ::MessageType_descriptor();
}
template <>
struct is_proto_enum<::ControlType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ControlType>() {
  return ::ControlType_descriptor();
}
template <>
struct is_proto_enum<::Direction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Direction>() {
  return ::Direction_descriptor();
}
template <>
struct is_proto_enum<::StreamType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::StreamType>() {
  return ::StreamType_descriptor();
}
template <>
struct is_proto_enum<::VideoStreamType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::VideoStreamType>() {
  return ::VideoStreamType_descriptor();
}
template <>
struct is_proto_enum<::Resolution> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Resolution>() {
  return ::Resolution_descriptor();
}
template <>
struct is_proto_enum<::BitrateType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::BitrateType>() {
  return ::BitrateType_descriptor();
}
template <>
struct is_proto_enum<::AudioSource> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::AudioSource>() {
  return ::AudioSource_descriptor();
}
template <>
struct is_proto_enum<::VideoCodec> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::VideoCodec>() {
  return ::VideoCodec_descriptor();
}
template <>
struct is_proto_enum<::AudioCodec> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::AudioCodec>() {
  return ::AudioCodec_descriptor();
}
template <>
struct is_proto_enum<::FrameRate> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::FrameRate>() {
  return ::FrameRate_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_interact_5fcmd_2eproto_2epb_2eh
